<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.16 -->
<document source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/check_model.rst">
    <target refid="check-model"></target>
    <section ids="check-a-model check-model" names="check\ a\ model check_model">
        <title>Check a model</title>
        <paragraph>Two checker classes are provided in libCellML; the <literal classes="code">Validator</literal> and the <literal classes="code">Analyser</literal> classes.
            These can be used to check the syntax and structure of your model is correct (validating), and to check that its mathematical representation is solvable (analysing).</paragraph>
        <target refid="validate-model"></target>
        <section ids="validate-a-model validate-model" names="validate\ a\ model validate_model">
            <title>Validate a model</title>
            <paragraph>The <literal classes="code">Validator</literal> is the equivalent of a spelling checker: it can check that each item in a model has all of the information it needs, but it can’t check whether it means what you intend it to.
                Thus even if a model is valid, it could still be the equivalent of correctly-spelled nonsense.</paragraph>
            <target refid="snippet-validate-model"></target>
            <container classes="toggle" ids="snippet-validate-model" names="snippet_validate_model">
                <container classes="header-left">
                    <paragraph>Validate a model against the CellML specification</paragraph>
                </container>
                <container classes="sphinx-tabs">
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>C++ snippet</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-0-0 active">
                            <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/resources/code/simulation_tool_dev/simulationToolDev.cpp" xml:space="preserve">    // Validate the model: check for syntactic and semantic errors.

    // Create a Validator instance and pass the model for checking.
    auto validator = libcellml::Validator::create();
    validator-&gt;validateModel(model);
    auto isValid = validator-&gt;errorCount() == 0;
    printIssues(validator);

</literal_block>
                            <paragraph>Full context: <download_reference filename="89c84d26a969eb1182bbdc7a0ffbaf8a/simulationToolDev.cpp" refdoc="howto/check_model" refdomain="" refexplicit="True" reftarget="/resources/code/simulation_tool_dev/simulationToolDev.cpp" reftype="download" refwarn="False"><literal classes="xref download">example_simulationToolDev.cpp</literal></download_reference></paragraph>
                        </container>
                    </container>
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>Python snippet</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-0-1">
                            <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/resources/code/simulation_tool_dev/simulationToolDev.py" xml:space="preserve">    # Validate the model: check for syntactic and semantic errors.

    # Create a Validator instance and pass the model for checking.
    validator = Validator()
    validator.validateModel(model)
    print_issues_to_terminal(validator)

</literal_block>
                            <paragraph>Full context: <download_reference filename="b302646fbd7722934aed90a32900e1e2/simulationToolDev.py" refdoc="howto/check_model" refdomain="" refexplicit="True" reftarget="/resources/code/simulation_tool_dev/simulationToolDev.py" reftype="download" refwarn="False"><literal classes="xref download">example_simulationToolDev.py</literal></download_reference></paragraph>
                        </container>
                    </container>
                </container>
            </container>
            <paragraph>Once a model has been passed to a <literal classes="code">Validator</literal> instance, the validator’s internal logger will contain a list of any of the issues which have been encountered during the checking process.
                A model can be said to be valid - that is, conforming to the <reference internal="False" refuri="https://cellml-specification.readthedocs.io/en/latest/">CellML normative specification</reference> - if the validator’s logger contains no issues with a level of <literal classes="code">ERROR</literal>.</paragraph>
            <paragraph>For more information on how to use any of the classes which record issues, please see the <reference internal="True" refid="get-issues"><inline classes="std std-ref">Get Issues</inline></reference> section below.</paragraph>
            <target refid="get-issues"></target>
        </section>
        <section ids="retrieve-issue-items get-issues" names="retrieve\ issue\ items get_issues">
            <title>Retrieve Issue items</title>
            <paragraph>Selected libCellML classes contain a <literal classes="code">Logger</literal> whose job it is to curate any issues encountered within the class, and return them to the user when asked.</paragraph>
            <container classes="shortlist">
                <paragraph>The classes are:</paragraph>
                <block_quote>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>the <literal classes="code">Parser</literal> class;</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>the <literal classes="code">Validator</literal> class;</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>the <literal classes="code">Printer</literal> class;</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>the <literal classes="code">Analyser</literal> class;</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>the <literal classes="code">Importer</literal> class; and</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>the <literal classes="code">Generator</literal> class.</paragraph>
                        </list_item>
                    </bullet_list>
                </block_quote>
            </container>
            <paragraph>Individual issues can be retrieved from the parent class by their index, an integer between 0 and <literal classes="code">issueCount()-1</literal>.
                Each issue contains a severity level indicator, one of four levels (<literal classes="code">ERROR</literal>, <literal classes="code">WARNING</literal>, <literal classes="code">HINT</literal>, or <literal classes="code">MESSAGE</literal>):</paragraph>
            <container classes="shortlist">
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><literal classes="code">ERROR</literal> level indicates issues that must be resolved before the model is valid and runnable;</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal classes="code">WARNING</literal> level indicates a non-fatal issue, but one that may cause hidden or unintended consequences;</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal classes="code">HINT</literal> level indicates a commonly encountered valid-but-nonsense situation; and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal classes="code">MESSAGE</literal> level is for your information but does not require action.</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <paragraph>Issues can also be retrieved from subgroups based on their severity, as shown in the examples below.</paragraph>
            <container classes="sphinx-tabs">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                    </container>
                    <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Iterate through all the issues in a Validator, regardless of level, and print to the terminal.
for (size_t i = 0; i &lt; validator-&gt;issueCount(); ++i) {
  // Retrieve the i-th issue and store it in the variable "myIssue".
  libcellml::IssuePtr myIssue = validator-&gt;issue(i);

  // Print the issue's description:
  std::cout &lt;&lt; myIssue-&gt;description() &lt;&lt; std::endl;

  // Print the issue's URL.  This is a URL at which more
  // information could be found about the cause and corrections
  // are needed to avoid it.
  std::cout &lt;&lt; myIssue-&gt;url() &lt;&lt; std::endl;

  // Validator only: Print the issue's reference. This is
  // the heading reference in the normative specification which
  // relates to this issue.
  std::cout &lt;&lt; myIssue-&gt;referenceHeading() &lt;&lt; std::endl;
}

// Retrieve the second ERROR level issue from a Printer. Note indexing from 0.
auto secondError = printer-&gt;error(1);

// Retrieve the last WARNING level issue from a Parser.
auto lastWarning = parser-&gt;warning(parser-&gt;warningCount()-1);

// Iterate through all HINT level issues in a Generator.
for (size_t h = 0; h &lt; generator-&gt;hintCount(); ++h) {
  // Retrieve the h-th hint and store it in the variable "myHint".
  auto myHint = generator-&gt;hint(h);
}</literal_block>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                    </container>
                    <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Iterate through all the issues in a Validator, regardless of level, and print to the terminal.
for i in range(0, validator.issueCount()):
  # Retrieve the i-th issue and store it in the variable "my_issue".
  my_issue = validator.issue(i)

  # Print the issue's description:
  print(my_issue.description())

  # Print the issue's URL.  This is a URL at which more
  # information could be found about the cause and corrections
  # are needed to avoid it.
  print(my_issue.url())

  # Validator only: Print the issue's reference. This is
  # the heading reference in the normative specification which
  # relates to this issue.
  print(my_issue.referenceHeading())

# Retrieve the second ERROR level issue from a Printer. Note indexing from 0.
second_error = printer.error(1)

# Retrieve the last WARNING level issue from a Parser.
last_warning = parser.warning(parser.warningCount() - 1)

# Iterate through all HINT level issues in a Generator.
for h in range(0, generator.hintCount()):
  # Retrieve the h-th hint and store it in the variable "my_hint".
  my_hint = generator.hint(h)</literal_block>
                </container>
            </container>
            <paragraph>Each <literal classes="code">Issue</literal> also contains the following attributes:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>A description: a brief statement about the problem and how it might be fixed;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>A reference heading: a chapter number pertaining to the formal <reference internal="False" refuri="https://cellml-specification.readthedocs.io/en/latest/">CellML 2.0 Specification</reference> document, for issues related to formatting and specification;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>A URL: a web address at which more detailed information and examples pertaining to the issue are available;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>A cause: an <literal classes="code">enum</literal> which reports the type of item responsible for the issue.
                        This is one of the enums:</paragraph>
                </list_item>
            </bullet_list>
            <container classes="shortlist">
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><literal classes="code">COMPONENT</literal>,</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal classes="code">CONNECTION</literal>,</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal classes="code">ENCAPSULATION</literal>,</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal classes="code">IMPORT</literal>,</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal classes="code">MAP_VARIABLES</literal>,</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal classes="code">MATHML</literal>,</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal classes="code">MODEL</literal>,</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal classes="code">RESET</literal>,</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal classes="code">RESET_VALUE</literal>,</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal classes="code">TEST_VALUE</literal>,</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal classes="code">UNDEFINED</literal>,</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal classes="code">UNIT</literal>,</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal classes="code">UNITS</literal>,</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal classes="code">VARIABLE</literal>, and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal classes="code">XML</literal>.</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="sphinx-tabs">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                    </container>
                    <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Retrieve and print the description of the issue.
std::cout &lt;&lt; issue-&gt;description() &lt;&lt; std::endl;

// Retrieve and print the reference heading number, if related to CellML2.0 specification and format.
std::cout &lt;&lt; issue-&gt;referenceHeading() &lt;&lt; std::endl;

// Retrieve and print the URL for more help and information about the issue.
std::cout &lt;&lt; issue-&gt;url() &lt;&lt; std::endl;

// Retrieve the item type - a libcellml::CellmlElementType enum - for the issue.
auto myType = issue-&gt;CellmlElementType();

// Retrieve the level - a libcellml::Issue::LEVEL enum - for the issue.
auto myLevel = issue-&gt;level();</literal_block>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                    </container>
                    <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Retrieve and print the description of the issue.
print(issue.description())

# Retrieve and print the reference heading number, if related to CellML2.0 specification and format.
print(issue.referenceHeading())

# Retrieve and print the URL for more help and information about the issue.
print(issue.url())

# Retrieve the cause - a libcellml.CellmlElementType enum - for the issue.
my_type = issue.cellmlElementType()

# Retrieve the level - a libcellml.Issue.LEVEL enum - for the issue.
my_level = issue.level()</literal_block>
                </container>
            </container>
        </section>
        <section ids="useful-functions-for-dealing-with-issues" names="useful\ functions\ for\ dealing\ with\ issues">
            <title>Useful functions for dealing with Issues</title>
            <target refid="snippet-get-issues"></target>
            <container classes="toggle" ids="snippet-get-issues" names="snippet_get_issues">
                <container classes="header-left">
                    <paragraph>Utility functions to retrieve issues</paragraph>
                </container>
                <container classes="sphinx-tabs">
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>C++</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-3-0 active">
                            <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/utilities/utilities.cpp" xml:space="preserve">void printIssues(const libcellml::LoggerPtr &amp;item) {

    // Get the number of issues attached to the logger item.  Note that this will 
    // return issues of all levels.  To retrieve the total number of a specific level
    // of issues, use the errorCount(), warningCount(), hintCount(), or messageCount() functions. 
    size_t num = item-&gt;issueCount();
    std::cout &lt;&lt; "Recorded " &lt;&lt; num &lt;&lt; " issues";

    if (num != 0) {
        std::cout &lt;&lt; ":" &lt;&lt; std::endl;
        for (size_t i = 0; i &lt; num; ++i) {

            // Retrieve the issue at index i.  Note that this is agnostic as to the level of issue.
            // Specific issue levels can be retrieved using the functions item-&gt;error(i), item-&gt;warning(i) 
            // etc, where the index must be within appropriate limits.
            libcellml::IssuePtr issue = item-&gt;issue(i);

            // Issues created by the Validator class contain a reference heading number, which indicates
            // the section reference within the normative specification relevant to the issue.
            std::string errorReference = issue-&gt;referenceHeading();

            // The level of an issue is retrieved using the level() function as an enum value.  
            std::cout &lt;&lt; "Issue " &lt;&lt; i &lt;&lt; " is " &lt;&lt; getIssueLevelFromEnum(issue-&gt;level()) &lt;&lt; ":" &lt;&lt; std::endl;

            // Each issue has a descriptive text field, accessible through the description() function.
            std::cout &lt;&lt; "    description: " &lt;&lt; issue-&gt;description() &lt;&lt; std::endl;
            if (errorReference != "") {
                std::cout &lt;&lt; "    see section " &lt;&lt; errorReference
                          &lt;&lt; " in the CellML specification." &lt;&lt; std::endl;
            }

            // An optional URL is given for some issues which directs the user to more detailed information.
            if(!issue-&gt;url().empty()){
                std::cout &lt;&lt; "    more information at: " &lt;&lt;issue-&gt;url() &lt;&lt; std::endl;
            }

            // Each issue is associated with an item.  In order to properly deal with the item stored, its type is 
            // recorded too in an enumeration.
            std::cout &lt;&lt; "    stored item type: " &lt;&lt; getCellmlElementTypeFromEnum(issue-&gt;cellmlElementType()) &lt;&lt; std::endl;
        }
        std::cout &lt;&lt; std::endl &lt;&lt; std::endl;
    }
    else {
        std::cout &lt;&lt; "!" &lt;&lt; std::endl &lt;&lt; std::endl;
    }
}
</literal_block>
                            <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/utilities/utilities.cpp" xml:space="preserve">std::map&lt;libcellml::CellmlElementType, std::string&gt; itemTypeToString = 
    {{libcellml::CellmlElementType::COMPONENT, "COMPONENT"},
    {libcellml::CellmlElementType::COMPONENT_REF, "COMPONENT_REF"},
    {libcellml::CellmlElementType::CONNECTION, "CONNECTION"},
    {libcellml::CellmlElementType::ENCAPSULATION, "ENCAPSULATION" },
    {libcellml::CellmlElementType::IMPORT, "IMPORT"},
    {libcellml::CellmlElementType::MAP_VARIABLES, "MAP_VARIABLES"},
    {libcellml::CellmlElementType::MATH, "MATH"},
    {libcellml::CellmlElementType::MODEL, "MODEL"},
    {libcellml::CellmlElementType::RESET, "RESET"},
    {libcellml::CellmlElementType::RESET_VALUE, "RESET_VALUE"},
    {libcellml::CellmlElementType::TEST_VALUE, "TEST_VALUE"},
    {libcellml::CellmlElementType::UNDEFINED, "UNDEFINED"},
    {libcellml::CellmlElementType::UNIT, "UNIT"},
    {libcellml::CellmlElementType::UNITS, "UNITS"}, 
    {libcellml::CellmlElementType::VARIABLE, "VARIABLE"}};

std::string getCellmlElementTypeFromEnum(libcellml::CellmlElementType t) {
    return itemTypeToString.at(t);
}
</literal_block>
                            <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/utilities/utilities.cpp" xml:space="preserve">std::string getIssueLevelFromEnum(libcellml::Issue::Level myLevel)
{
    std::string myTypeAsString = "dunno";

    switch (myLevel) {
    case libcellml::Issue::Level::ERROR:
        myTypeAsString = "an ERROR";
        break;
    case libcellml::Issue::Level::WARNING:
        myTypeAsString = "a WARNING";
        break;
    case libcellml::Issue::Level::HINT:
        myTypeAsString = "a HINT";
        break;
    case libcellml::Issue::Level::MESSAGE:
        myTypeAsString = "a MESSAGE";
        break;
    }
    return myTypeAsString;
}
</literal_block>
                            <paragraph>Full context: <download_reference filename="e699ba6f50ebc871a03897b3830d2719/utilities.cpp" refdoc="howto/check_model" refdomain="" refexplicit="True" reftarget="/tutorials/utilities/utilities.cpp" reftype="download" refwarn="False"><literal classes="xref download">utilities.cpp</literal></download_reference></paragraph>
                        </container>
                    </container>
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>Python</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-3-1">
                            <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/utilities/utilities.py" xml:space="preserve">def print_issues(item):

    # Get the number of issues attached to the logger item.  Note that this will 
    # return issues of all levels.  To retrieve the total number of a specific level
    # of issues, use the errorCount(), warningCount(), hintCount(), or messageCount() functions. 
    number_of_issues = item.issueCount()

    if number_of_issues != 0:
        print("\nThe {t} has found {n} issues:".format(
            t=type(item).__name__,
            n=number_of_issues)
        )

        for e in range(0, number_of_issues):

            # Retrieve the issue at index i.  Note that this is agnostic as to the level of issue.
            # Specific issue levels can be retrieved using the functions item.error(e), item.warning(e) 
            # etc, where the index must be within appropriate limits.
            i = item.issue(e)

            # The level of an issue is retrieved using the level() function as an enum value. 
            level = i.level()
            print("  {l}[{e}]:".format(
                l=level_as_string[level],
                e=e))

            # Each issue has a descriptive text field, accessible through the description() function.
            print("    Description: {d}".format(
                d=i.description()))

            # Issues created by the Validator class contain a reference heading number, which indicates
            # the section reference within the normative specification relevant to the issue.
            specification = i.referenceHeading()
            if specification != "":
                print("    See section {s} in the CellML specification.".format(
                    s=specification))

            # An optional URL is given for some issues which directs the user to more detailed information.
            url = i.url()
            if url != "":
                print("    More information is available at {url}".format(
                    url=url))

            # Each issue is associated with an item.  In order to properly deal with the item stored, its type is 
            # recorded too in an enumeration.
            print("    Stored item type: {}".format(get_cellml_element_type_from_enum(i.cellmlElementType())))

    else:
        print("\nThe {t} has not found any issues!".format(
            t=type(item).__name__)
        )
</literal_block>
                            <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/utilities/utilities.py" xml:space="preserve">def get_cellml_element_type_from_enum(my_cause):

    my_type_as_string = "dunno"

    if my_cause == CellmlElementType.COMPONENT:
        my_type_as_string = "COMPONENT"

    elif my_cause == CellmlElementType.COMPONENT_REF:
        my_type_as_string = "COMPONENT_REf"

    elif my_cause == CellmlElementType.CONNECTION:
        my_type_as_string = "CONNECTION"

    elif my_cause == CellmlElementType.ENCAPSULATION:
        my_type_as_string = "ENCAPSULATION"

    elif my_cause == CellmlElementType.IMPORT:
        my_type_as_string = "IMPORT"

    elif my_cause == CellmlElementType.MATH:
        my_type_as_string = "MATH"

    elif my_cause == CellmlElementType.MAP_VARIABLES:
        my_type_as_string = "MAP_VARIABLES"

    elif my_cause == CellmlElementType.MODEL:
        my_type_as_string = "MODEL"

    elif my_cause == CellmlElementType.RESET:
        my_type_as_string = "RESET"

    elif my_cause == CellmlElementType.RESET_VALUE:
        my_type_as_string = "RESET_VALUE"

    elif my_cause == CellmlElementType.TEST_VALUE:
        my_type_as_string = "TEST_VALUE"

    elif my_cause == CellmlElementType.UNDEFINED:
        my_type_as_string = "UNDEFINED"

    elif my_cause == CellmlElementType.UNIT:
        my_type_as_string = "UNIT"

    elif my_cause == CellmlElementType.UNITS:
        my_type_as_string = "UNITS"

    elif my_cause == CellmlElementType.VARIABLE:
        my_type_as_string = "VARIABLE"

    return my_type_as_string
</literal_block>
                            <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/utilities/utilities.py" xml:space="preserve">def get_issue_level_from_enum(my_level):

    my_type_as_string = "dunno"

    if my_level == Issue.Level.ERROR:
        my_type_as_string = "ERROR"

    elif my_level == Issue.Level.WARNING:
        my_type_as_string = "WARNING"
        
    elif my_level == Issue.Level.HINT:
        my_type_as_string = "HINT"

    elif my_level == Issue.Level.MESSAGE:
        my_type_as_string = "MESSAGE"

    return my_type_as_string
</literal_block>
                            <paragraph>Full context: <download_reference filename="bdd36165f344361d452a18f7d3e3f141/utilities.py" refdoc="howto/check_model" refdomain="" refexplicit="True" reftarget="/tutorials/utilities/utilities.py" reftype="download" refwarn="False"><literal classes="xref download">utilities.py</literal></download_reference></paragraph>
                        </container>
                    </container>
                </container>
            </container>
            <target refid="analyse-model"></target>
        </section>
        <section ids="analyse-a-model-item analyse-model" names="analyse\ a\ model\ item analyse_model">
            <title>Analyse a Model item</title>
            <paragraph>The <literal classes="code">Analyser</literal> class takes an existing, valid <literal classes="code">Model</literal> item, and checks it for mathematical sense.
                This includes checking things like that all variables requiring initial values have them, that equations do not conflict with one another, and that any variables used in equations are actually defined in the model.</paragraph>
            <paragraph>The three basic steps to model analysis are:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>Creating an <literal classes="code">Analyser</literal> item and passing in a <literal classes="code">Model</literal> for analysis;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Checking for any <literal classes="code">Issues</literal> raised; and</paragraph>
                </list_item>
                <list_item>
                    <paragraph>(optional: for code generation only) Retrieving a <literal classes="code">AnalysedModel</literal> item to pass to a <literal classes="code">Generator</literal>, if required.</paragraph>
                </list_item>
            </enumerated_list>
            <target refid="snippet-analyser-analyse"></target>
            <container classes="sphinx-tabs" ids="snippet-analyser-analyse" names="snippet_analyser_analyse">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-4-0 active">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/resources/code/simulation_tool_dev/simulationToolDev.cpp" xml:space="preserve">    // Analyse the model: check for mathematical and modelling errors.
    auto analyser = libcellml::Analyser::create();
    analyser-&gt;analyseModel(model);
    printIssues(analyser);

</literal_block>
                        <paragraph>Full context: <download_reference filename="89c84d26a969eb1182bbdc7a0ffbaf8a/simulationToolDev.cpp" refdoc="howto/check_model" refdomain="" refexplicit="True" reftarget="/resources/code/simulation_tool_dev/simulationToolDev.cpp" reftype="download" refwarn="False"><literal classes="xref download">example_simulationToolDev.cpp</literal></download_reference></paragraph>
                    </container>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-4-1">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/resources/code/simulation_tool_dev/simulationToolDev.py" xml:space="preserve">    # Analyse a model: check for mathematical and modelling errors.
    analyser = Analyser()
    analyser.analyseModel(model)
    print_issues_to_terminal(analyser)

</literal_block>
                        <paragraph>Full context: <download_reference filename="b302646fbd7722934aed90a32900e1e2/simulationToolDev.py" refdoc="howto/check_model" refdomain="" refexplicit="True" reftarget="/resources/code/simulation_tool_dev/simulationToolDev.py" reftype="download" refwarn="False"><literal classes="xref download">example_simulationToolDev.py</literal></download_reference></paragraph>
                    </container>
                </container>
            </container>
            <paragraph>Any issues or messages raised are stored within the class’s logger.
                More information about accessing <literal classes="code">Issue</literal> items can be found on the <reference internal="True" refid="get-issues"><inline classes="std std-ref">Common actions &gt; Retrieve Issue items</inline></reference> page.</paragraph>
            <paragraph>Use of the <literal classes="code">Analyser</literal> class is a prerequisite for the <literal classes="code">Generator</literal> class.
                The generator makes use of the structures created during the analysis process, so takes a <literal classes="code">AnalyserModel</literal> as an input.</paragraph>
            <target refid="snippet-analyser-output"></target>
            <container classes="sphinx-tabs" ids="snippet-analyser-output" names="snippet_analyser_output">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-5-0 active">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/resources/code/simulation_tool_dev/simulationToolDev.cpp" xml:space="preserve">    // Generate runnable code in other language formats for this model.

    // Create a Generator instance.  Note that by default this uses the C language profile.
    auto generator = libcellml::Generator::create();

    // Pass the generator the model for processing.
    generator-&gt;setModel(analyser-&gt;model());
    printIssues(generator);

</literal_block>
                        <paragraph>Full context: <download_reference filename="89c84d26a969eb1182bbdc7a0ffbaf8a/simulationToolDev.cpp" refdoc="howto/check_model" refdomain="" refexplicit="True" reftarget="/resources/code/simulation_tool_dev/simulationToolDev.cpp" reftype="download" refwarn="False"><literal classes="xref download">example_simulationToolDev.cpp</literal></download_reference></paragraph>
                    </container>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-5-1">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/resources/code/simulation_tool_dev/simulationToolDev.py" xml:space="preserve">    # Generate runnable code in other language formats for this model.

    # Create a Generator instance.  Note that by default this is the C language.
    generator = Generator()

    # Pass the generator the analysed model for processing.
    generator.processModel(analyser.model())
    print_issues_to_terminal(generator)

</literal_block>
                        <paragraph>Full context: <download_reference filename="b302646fbd7722934aed90a32900e1e2/simulationToolDev.py" refdoc="howto/check_model" refdomain="" refexplicit="True" reftarget="/resources/code/simulation_tool_dev/simulationToolDev.py" reftype="download" refwarn="False"><literal classes="xref download">example_simulationToolDev.py</literal></download_reference></paragraph>
                    </container>
                </container>
            </container>
            <paragraph><strong>TODO</strong></paragraph>
        </section>
    </section>
</document>
