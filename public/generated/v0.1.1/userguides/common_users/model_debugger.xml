<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.16 -->
<document source="/Users/kmoy001/libcellml/libcellml-tutorials/common_users/model_debugger.rst">
    <target refid="users-model-debugger"></target>
    <section ids="model-debugger users-model-debugger" names="model\ debugger users_model_debugger">
        <title>Model debugger</title>
        <paragraph>This example walks through the process of using the <literal classes="code">Validator</literal> and <literal classes="code">Analyser</literal> classes to check a CellML model’s syntax and mathematical composition.</paragraph>
        <container classes="directorylist">
            <paragraph><strong>C++ resources</strong>: <download_reference filename="76fa68d918ea3275ce9943d297f090e4/" refdoc="common_users/model_debugger" refdomain="" refexplicit="True" reftarget="" reftype="download" refwarn="False"><literal classes="xref download">All C++ resources</literal></download_reference></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><download_reference filename="f76f86e7571b29abbfb29d6b335fc186/CMakeLists.txt" refdoc="common_users/model_debugger" refdomain="" refexplicit="True" reftarget="/resources/code/model_debugger/CMakeLists.txt" reftype="download" refwarn="False"><literal classes="xref download">CMakeLists.txt</literal></download_reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><download_reference filename="e4914561a85295d3fda12302a54c5e9a/modelDebugger.cpp" refdoc="common_users/model_debugger" refdomain="" refexplicit="True" reftarget="/resources/code/model_debugger/modelDebugger.cpp" reftype="download" refwarn="False"><literal classes="xref download">example_modelDebugger.cpp</literal></download_reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph>resources/</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph><download_reference filename="25cb45bd77432e33e5acd399a09e15c4/debugAnalysisExample.cellml" refdoc="common_users/model_debugger" refdomain="" refexplicit="True" reftarget="/resources/code/model_debugger/debugAnalysisExample.cellml" reftype="download" refwarn="False"><literal classes="xref download">debugAnalysisExample.cellml</literal></download_reference></paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><download_reference filename="f44a0b9eb7ed68068f2a938969e03d1d/debugAnalysisExampleImport.cellml" refdoc="common_users/model_debugger" refdomain="" refexplicit="True" reftarget="/resources/code/model_debugger/debugAnalysisExampleImport.cellml" reftype="download" refwarn="False"><literal classes="xref download">debugAnalysisExampleImport.cellml</literal></download_reference></paragraph>
                        </list_item>
                    </bullet_list>
                </list_item>
            </bullet_list>
            <paragraph><strong>Python resources</strong>: <download_reference filename="76fa68d918ea3275ce9943d297f090e4/" refdoc="common_users/model_debugger" refdomain="" refexplicit="True" reftarget="" reftype="download" refwarn="False"><literal classes="xref download">All Python resources</literal></download_reference></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><download_reference filename="bb681380812691710323aa809fad072f/modelDebugger.py" refdoc="common_users/model_debugger" refdomain="" refexplicit="True" reftarget="/resources/code/model_debugger/modelDebugger.py" reftype="download" refwarn="False"><literal classes="xref download">example_modelDebugger.py</literal></download_reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph>resources/</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph><download_reference filename="25cb45bd77432e33e5acd399a09e15c4/debugAnalysisExample.cellml" refdoc="common_users/model_debugger" refdomain="" refexplicit="True" reftarget="/resources/code/model_debugger/debugAnalysisExample.cellml" reftype="download" refwarn="False"><literal classes="xref download">debugAnalysisExample.cellml</literal></download_reference></paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><download_reference filename="f44a0b9eb7ed68068f2a938969e03d1d/debugAnalysisExampleImport.cellml" refdoc="common_users/model_debugger" refdomain="" refexplicit="True" reftarget="/resources/code/model_debugger/debugAnalysisExampleImport.cellml" reftype="download" refwarn="False"><literal classes="xref download">debugAnalysisExampleImport.cellml</literal></download_reference></paragraph>
                        </list_item>
                    </bullet_list>
                </list_item>
            </bullet_list>
        </container>
        <section ids="parse-an-existing-cellml-model" names="parse\ an\ existing\ cellml\ model">
            <title>Parse an existing CellML model</title>
            <paragraph>Here we use the <literal classes="code">Parser</literal> class to read the file, and deserialise the CellML into a <literal classes="code">Model</literal> object.
                The CellML file used in this example makes use of imports, so we need to have the main file (debugAnalysisExample.cellml) as well as the file which it imports (debugAnalysisExampleImport.cellml).</paragraph>
            <container classes="sphinx-tabs">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++ snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-0-0 active">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/resources/code/model_debugger/modelDebugger.cpp" xml:space="preserve">    // Parse an existing CellML model from a file.

    std::string inFileName = "debugAnalysisExample.cellml";
    std::ifstream inFile(inFileName);
    std::stringstream inFileContents;
    inFileContents &lt;&lt; inFile.rdbuf();

    auto parser = libcellml::Parser::create();
    auto model = parser-&gt;parseModel(inFileContents.str());

</literal_block>
                    </container>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-0-1">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/resources/code/model_debugger/modelDebugger.py" xml:space="preserve">    # Parse an existing CellML model from a file.
    read_file = open('debugAnalysisExample.cellml', 'r')
    parser = Parser()
    model = parser.parseModel(read_file.read())

</literal_block>
                    </container>
                </container>
            </container>
        </section>
        <section ids="resolve-the-imports-and-flatten-the-model" names="resolve\ the\ imports\ and\ flatten\ the\ model">
            <title>Resolve the imports and flatten the model</title>
            <paragraph>At present the <literal classes="code">Analyser</literal> class ignores the contents of imported items.
                This example shows a model which has imports, so we need to resolve these and flatten the model before any analysis can happen.
                For detailed information on debugging models with imports, please see the <reference internal="True" refuri="import_debugger#users-import-debugger"><inline classes="std std-ref">Import debugging</inline></reference> examples.</paragraph>
            <container classes="sphinx-tabs">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++ snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-1-0 active">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/resources/code/model_debugger/modelDebugger.cpp" xml:space="preserve">    // Resolve any imports and flatten the model for analysis.
    auto importer = libcellml::Importer::create();

    // Resolve the imports.
    importer-&gt;resolveImports(model, "");

    // Check for issues.
    std::cout &lt;&lt; "The importer found "&lt;&lt;importer-&gt;issueCount() &lt;&lt; " issues." &lt;&lt; std::endl;
    for(size_t i = 0; i &lt; importer-&gt;issueCount(); ++i) {
        auto issue = importer-&gt;issue(i);
        std::cout &lt;&lt; issue-&gt;description() &lt;&lt; std::endl;
    }

    // Flatten the model.
    model = importer-&gt;flattenModel(model);

</literal_block>
                    </container>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-1-1">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/resources/code/model_debugger/modelDebugger.py" xml:space="preserve">    # Resolve any imports and flatten the model for analysis.
    importer = Importer()

    # Resolve the imports.
    importer.resolveImports(model, '')

    # Check for issues.
    print('The importer found {} issues.'.format(importer.issueCount()))
    for i in range(0, importer.issueCount()):
        issue = importer.issue(i)
        print(issue.description())

    # Flatten the model.
    model = importer.flattenModel(model)

</literal_block>
                    </container>
                </container>
            </container>
        </section>
        <section ids="validate-the-model" names="validate\ the\ model">
            <title>Validate the model</title>
            <paragraph>The <literal classes="code">Validator</literal> class process is like a spelling checker: it will check the syntax of the model ahead of analysing its mathematical formulation in the <literal classes="code">Analyser</literal> later.
                Here we create a validator, use it to check the model, and retrieve the descriptions of any issues it found.</paragraph>
            <container classes="sphinx-tabs">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++ snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-2-0 active">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/resources/code/model_debugger/modelDebugger.cpp" xml:space="preserve">    // Create an Validator instance and pass the model to it for processing.
    auto validator = libcellml::Validator::create();
    validator-&gt;validateModel(model);

    // Print any issues to the terminal.
    std::cout &lt;&lt; "The validator found "&lt;&lt;validator-&gt;issueCount() &lt;&lt; " issues." &lt;&lt; std::endl;
    for(size_t i = 0; i &lt; validator-&gt;issueCount(); ++i) {
        auto issue = validator-&gt;issue(i);
        std::cout &lt;&lt; issue-&gt;description() &lt;&lt; std::endl;
    }

</literal_block>
                    </container>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-2-1">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/resources/code/model_debugger/modelDebugger.py" xml:space="preserve">    # Create an Validator instance and pass the model to it for processing.
    validator = Validator()
    validator.validateModel(model)

    # Print any issues to the terminal.
    print('The validator found {} issues.'.format(validator.issueCount()))
    for i in range(0, validator.issueCount()):
        issue = validator.issue(i)
        print(issue.description())

</literal_block>
                    </container>
                </container>
            </container>
            <paragraph>The validation issues raised can be used to fix any “spelling” problems with the model.</paragraph>
            <container classes="sphinx-tabs">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++ snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-3-0 active">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/resources/code/model_debugger/modelDebugger.cpp" xml:space="preserve">    // Fix the validation errors.

    // Add units to the variable 'b' in component 'validationErrors'.
    model-&gt;component("validationErrors")-&gt;variable("b")-&gt;setUnits("dimensionless");

    // Change the name of the variable 'iShouldBeNamed_c' to be 'c'.
    model-&gt;component("validationErrors")-&gt;variable("iShouldBeNamed_c")-&gt;setName("c");

    // Check again.
    validator-&gt;validateModel(model);
    std::cout &lt;&lt; "The validator found "&lt;&lt;validator-&gt;issueCount() &lt;&lt; " issues." &lt;&lt; std::endl;

</literal_block>
                    </container>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-3-1">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/resources/code/model_debugger/modelDebugger.py" xml:space="preserve">    # Fix the validation errors.

    # Add units to the variable 'b' in component 'validationErrors'.
    model.component('validationErrors').variable('b').setUnits('dimensionless')

    # Change the name of the variable 'iShouldBeNamed_c' to be 'c'.
    model.component('validationErrors').variable('iShouldBeNamed_c').setName('c')

    # Check again.
    validator.validateModel(model)
    print('The validator found {} issues.'.format(validator.issueCount()))

</literal_block>
                    </container>
                </container>
            </container>
        </section>
        <section ids="analyse-the-model" names="analyse\ the\ model">
            <title>Analyse the model</title>
            <paragraph>If the <literal classes="code">Validator</literal> is the spell-checker then the <literal classes="code">Analyser</literal> is the grammar-checker.
                It will check for errors of logic or mathematical definition in the model formulation, and also make sure that all of the information which a solver needs is available.
                The <literal classes="code">Analyser</literal> works in the same way as the other service classes: we create an instance, pass a model for checking, and then retrieve any issues it may have found.</paragraph>
            <container classes="sphinx-tabs">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++ snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-4-0 active">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/resources/code/model_debugger/modelDebugger.cpp" xml:space="preserve">    // The Analyser will find errors in the logic or mathematical formulation of the model's equations,
    // so may return issues even when the model is valid (syntactically correct).
    auto analyser = libcellml::Analyser::create();
    analyser-&gt;analyseModel(model);

    std::cout &lt;&lt; "The analyser found "&lt;&lt;analyser-&gt;issueCount() &lt;&lt; " issues." &lt;&lt; std::endl;
    for(size_t i = 0; i &lt; analyser-&gt;issueCount(); ++i) {
        auto issue = analyser-&gt;issue(i);
        std::cout &lt;&lt; issue-&gt;description() &lt;&lt; std::endl;
    }

</literal_block>
                    </container>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-4-1">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/resources/code/model_debugger/modelDebugger.py" xml:space="preserve">    # The Analyser will find errors in the logic or mathematical formulation of the model's equations,
    # so may return issues even when the model is valid (syntactically correct).
    analyser = Analyser()
    analyser.analyseModel(model)

    print('The analyser found {} issues.'.format(analyser.issueCount()))
    for i in range(0, analyser.issueCount()):
        issue = analyser.issue(i)
        print(issue.description())

</literal_block>
                    </container>
                </container>
            </container>
            <container classes="nb">
                <paragraph>In some situations both the <literal classes="code">Validator</literal> and <literal classes="code">Analyser</literal> classes may encounter errors that mean they’re unable to continue processing the model.
                    For this reason, you may need several iterations of checking and fixing before all of the issues are addressed.</paragraph>
            </container>
            <container classes="sphinx-tabs">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++ snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-5-0 active">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/resources/code/model_debugger/modelDebugger.cpp" xml:space="preserve">    // Fix the analysis errors.  This may need several iterations of checking before all errors have been 
    // resolved.

    // Variable 'd' in component 'importedComponent' is initialised using variable 'e', but it is not a constant.
    model-&gt;component("importedComponent")-&gt;variable("d")-&gt;setInitialValue(22);

    analyser-&gt;analyseModel(model);
    std::cout &lt;&lt; "The analyser found "&lt;&lt;analyser-&gt;issueCount() &lt;&lt; " issues." &lt;&lt; std::endl;
    for(size_t i = 0; i &lt; analyser-&gt;issueCount(); ++i) {
        auto issue = analyser-&gt;issue(i);
        std::cout &lt;&lt; issue-&gt;description() &lt;&lt; std::endl;
    }

    // Variable 'x' in component 'nonInitialisedStateVariable' is used in an ODE, but it is not initialised.
    model-&gt;component("nonInitialisedStateVariable", true)-&gt;variable("x")-&gt;setInitialValue(0.0);

    // Variable 'x' in component 'overconstrainedModel' is computed more than once.
    std::string mathml = 
        "&lt;math xmlns=\"http://www.w3.org/1998/Math/MathML\" xmlns:cellml=\"http://www.cellml.org/cellml/2.0#\"&gt;\n"
        "  &lt;apply&gt;\n"
        "    &lt;eq/&gt;\n"
        "    &lt;ci&gt;x&lt;/ci&gt;\n"
        "    &lt;cn cellml:units=\"dimensionless\"&gt;3&lt;/cn&gt;\n"
        "  &lt;/apply&gt;\n"
        "&lt;/math&gt;\n";
    model-&gt;component("overconstrainedModel", true)-&gt;setMath(mathml);

    // Variable 'x' in component 'uncomputedVariable' is not computed.
    model-&gt;component("uncomputedVariable")-&gt;setMath(mathml);

    // Variable 'a' in component 'validationErrors' is not computed.
    // Variable 'c' in component 'validationErrors' is not computed.
    model-&gt;component("validationErrors")-&gt;variable("c")-&gt;setInitialValue(1.0);

    // Check again.
    validator-&gt;validateModel(model);
    analyser-&gt;analyseModel(model);

    std::cout &lt;&lt; "The validator found "&lt;&lt;validator-&gt;issueCount() &lt;&lt; " issues." &lt;&lt; std::endl;
        for(size_t i = 0; i &lt; validator-&gt;issueCount(); ++i) {
        auto issue = validator-&gt;issue(i);
        std::cout &lt;&lt; issue-&gt;description() &lt;&lt; std::endl;
    }

    std::cout &lt;&lt; "The analyser found "&lt;&lt;analyser-&gt;issueCount() &lt;&lt; " issues." &lt;&lt; std::endl;

    for(size_t i = 0; i &lt; analyser-&gt;issueCount(); ++i) {
        auto issue = analyser-&gt;issue(i);
        std::cout &lt;&lt; issue-&gt;description() &lt;&lt; std::endl;
    }

</literal_block>
                    </container>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-5-1">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/resources/code/model_debugger/modelDebugger.py" xml:space="preserve">    # Fix the analysis errors.  This may need several iterations of checking before all errors have been 
    # resolved.

    # Variable 'd' in component 'importedComponent' is initialised using variable 'e', but it is not a constant.
    model.component('importedComponent').variable('d').setInitialValue(22)

    analyser.analyseModel(model)

    print('The analyser found {} issues.'.format(analyser.issueCount()))
    for i in range(0, analyser.issueCount()):
        issue = analyser.issue(i)
        print(issue.description())

    # Variable 'x' in component 'nonInitialisedStateVariable' is used in an ODE, but it is not initialised.
    model.component('nonInitialisedStateVariable', True).variable('x').setInitialValue(0.0)

    # Variable 'x' in component 'overconstrainedModel' is computed more than once.
    mathml = \
        '&lt;math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:cellml="http://www.cellml.org/cellml/2.0#"&gt;\n'\
        '  &lt;apply&gt;\n'\
        '    &lt;eq/&gt;\n'\
        '   &lt;ci&gt;x&lt;/ci&gt;\n'\
        '    &lt;cn cellml:units="dimensionless"&gt;3&lt;/cn&gt;\n'\
        '  &lt;/apply&gt;\n'\
        '&lt;/math&gt;'
    model.component('overconstrainedModel', True).setMath(mathml)

    # Variable 'x' in component 'uncomputedVariable' is not computed.
    model.component('uncomputedVariable').setMath(mathml)

    # Variable 'a' in component 'validationErrors' is not computed.
    # Variable 'c' in component 'validationErrors' is not computed.
    model.component('validationErrors').variable('c').setInitialValue(1.0)

    # Check again.
    validator.validateModel(model)
    print('The validator found {} issues.'.format(validator.issueCount()))
    for i in range(0, validator.issueCount()):
        issue = validator.issue(i)
        print(issue.description())

    analyser.analyseModel(model)
    print('The analyser found {} issues.'.format(analyser.issueCount()))
    for i in range(0, analyser.issueCount()):
        issue = analyser.issue(i)
        print(issue.description())

</literal_block>
                    </container>
                </container>
            </container>
        </section>
        <section ids="print-the-repaired-model-to-a-cellml-file" names="print\ the\ repaired\ model\ to\ a\ cellml\ file">
            <title>Print the repaired model to a CellML file</title>
            <paragraph>Finally, we can serialised the repaired model for output to a CellML file using the <literal classes="code">Printer</literal> class.
                Note that this prints the flattened model, so will not contain the import dependencies of the original one.</paragraph>
            <container classes="sphinx-tabs">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++ snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-6-0 active">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/resources/code/model_debugger/modelDebugger.cpp" xml:space="preserve">    // Write the flattened, validated, analysed model to a serialised CellML string.
    auto printer = libcellml::Printer::create();
    std::string serialisedModelString = printer-&gt;printModel(model);

    // Write the serialised string to a file.
    std::string outFileName = "debugAnalysisExampleFixed.cellml";
    std::ofstream outFile(outFileName);
    outFile &lt;&lt; serialisedModelString;
    outFile.close();

</literal_block>
                    </container>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-6-1">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/resources/code/model_debugger/modelDebugger.py" xml:space="preserve">    # Write the flattened, validated, analysed model to a serialised CellML string.
    printer = Printer()
    model_string = printer.printModel(model)

    # Write the serialised string to a file.
    write_file = open("debugAnalysisExampleFixed.cellml", "w")
    write_file.write(model_string)

</literal_block>
                    </container>
                </container>
            </container>
        </section>
    </section>
</document>
