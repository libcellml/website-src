<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/Users/hsor001/Projects/cellml/sandbox/userguides/resources/code_snippets/snippet_get_issues.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/" xmlns:todo="https://www.sphinx-doc.org/">
    <target refid="snippet-get-issues"></target>
    <container classes="toggle" ids="snippet-get-issues" names="snippet_get_issues">
        <container classes="header-left">
            <paragraph>Utility functions to retrieve issues</paragraph>
        </container>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" classes="closeable" role="tablist">
                <button aria-controls="panel-0-0-0" aria-selected="true" classes="sphinx-tabs-tab" ids="tab-0-0-0" name="0-0" role="tab" tabindex="0">C++</button>
                <button aria-controls="panel-0-0-1" aria-selected="false" classes="sphinx-tabs-tab" ids="tab-0-0-1" name="0-1" role="tab" tabindex="-1">Python</button>
            </div>
            <div aria-labelledby="tab-0-0-0" classes="sphinx-tabs-panel" ids="panel-0-0-0" name="0-0" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/hsor001/Projects/cellml/sandbox/userguides/tutorials/utilities/utilities.cpp" xml:space="preserve">void printIssues(const libcellml::LoggerPtr &amp;item) {

    // Get the number of issues attached to the logger item.  Note that this will 
    // return issues of all levels.  To retrieve the total number of a specific level
    // of issues, use the errorCount(), warningCount(), hintCount(), or messageCount() functions. 
    size_t num = item-&gt;issueCount();
    std::cout &lt;&lt; "Recorded " &lt;&lt; num &lt;&lt; " issues";

    if (num != 0) {
        std::cout &lt;&lt; ":" &lt;&lt; std::endl;
        for (size_t i = 0; i &lt; num; ++i) {

            // Retrieve the issue at index i.  Note that this is agnostic as to the level of issue.
            // Specific issue levels can be retrieved using the functions item-&gt;error(i), item-&gt;warning(i) 
            // etc, where the index must be within appropriate limits.
            libcellml::IssuePtr issue = item-&gt;issue(i);

            // Issues created by the Validator class contain a reference heading number, which indicates
            // the section reference within the normative specification relevant to the issue.
            std::string errorReference = issue-&gt;referenceHeading();

            // The level of an issue is retrieved using the level() function as an enum value.  
            std::cout &lt;&lt; "Issue " &lt;&lt; i &lt;&lt; " is " &lt;&lt; getIssueLevelFromEnum(issue-&gt;level()) &lt;&lt; ":" &lt;&lt; std::endl;

            // Each issue has a descriptive text field, accessible through the description() function.
            std::cout &lt;&lt; "    description: " &lt;&lt; issue-&gt;description() &lt;&lt; std::endl;
            if (errorReference != "") {
                std::cout &lt;&lt; "    see section " &lt;&lt; errorReference
                          &lt;&lt; " in the CellML specification." &lt;&lt; std::endl;
            }

            // An optional URL is given for some issues which directs the user to more detailed information.
            if(!issue-&gt;url().empty()){
                std::cout &lt;&lt; "    more information at: " &lt;&lt;issue-&gt;url() &lt;&lt; std::endl;
            }

            // Each issue is associated with an item.  In order to properly deal with the item stored, its type is 
            // recorded too in an enumeration.
            std::cout &lt;&lt; "    stored item type: " &lt;&lt; cellmlElementTypeAsString(issue-&gt;item()-&gt;type()) &lt;&lt; std::endl;
        }
        std::cout &lt;&lt; std::endl &lt;&lt; std::endl;
    }
    else {
        std::cout &lt;&lt; "!" &lt;&lt; std::endl &lt;&lt; std::endl;
    }
}
</literal_block>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/hsor001/Projects/cellml/sandbox/userguides/tutorials/utilities/utilities.cpp" xml:space="preserve">std::string getIssueLevelFromEnum(libcellml::Issue::Level myLevel)
{
    std::string myTypeAsString = "dunno";

    switch (myLevel) {
    case libcellml::Issue::Level::ERROR:
        myTypeAsString = "an ERROR";
        break;
    case libcellml::Issue::Level::WARNING:
        myTypeAsString = "a WARNING";
        break;
    case libcellml::Issue::Level::MESSAGE:
        myTypeAsString = "a MESSAGE";
        break;
    }
    return myTypeAsString;
}
</literal_block>
                <paragraph>Full context: <download_reference filename="e699ba6f50ebc871a03897b3830d2719/utilities.cpp" refdoc="resources/code_snippets/snippet_get_issues" refdomain="" refexplicit="True" reftarget="/tutorials/utilities/utilities.cpp" reftype="download" refwarn="False"><literal classes="xref download">utilities.cpp</literal></download_reference></paragraph>
            </div>
            <div aria-labelledby="tab-0-0-1" classes="sphinx-tabs-panel" hidden="true" ids="panel-0-0-1" name="0-1" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/hsor001/Projects/cellml/sandbox/userguides/tutorials/utilities/utilities.py" xml:space="preserve">def print_issues(item):

    # Get the number of issues attached to the logger item.  Note that this will 
    # return issues of all levels.  To retrieve the total number of a specific level
    # of issues, use the errorCount(), warningCount(), hintCount(), or messageCount() functions. 
    number_of_issues = item.issueCount()

    if number_of_issues != 0:
        print("\nThe {t} has found {n} issues:".format(
            t=type(item).__name__,
            n=number_of_issues)
        )

        for e in range(0, number_of_issues):

            # Retrieve the issue at index i.  Note that this is agnostic as to the level of issue.
            # Specific issue levels can be retrieved using the functions item.error(e), item.warning(e) 
            # etc, where the index must be within appropriate limits.
            i = item.issue(e)

            # The level of an issue is retrieved using the level() function as an enum value. 
            level = i.level()
            print("  {l}[{e}]:".format(
                l=level_as_string[level],
                e=e))

            # Each issue has a descriptive text field, accessible through the description() function.
            print("    Description: {d}".format(
                d=i.description()))

            # Issues created by the Validator class contain a reference heading number, which indicates
            # the section reference within the normative specification relevant to the issue.
            specification = i.referenceHeading()
            if specification != "":
                print("    See section {s} in the CellML specification.".format(
                    s=specification))

            # An optional URL is given for some issues which directs the user to more detailed information.
            url = i.url()
            if url != "":
                print("    More information is available at {url}".format(
                    url=url))

            # Each issue is associated with an item.  In order to properly deal with the item stored, its type is 
            # recorded too in an enumeration.
            print("    Stored item type: {}".format(get_cellml_element_type_from_enum(i.cellmlElementType())))

    else:
        print("\nThe {t} has not found any issues!".format(
            t=type(item).__name__)
        )
</literal_block>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/hsor001/Projects/cellml/sandbox/userguides/tutorials/utilities/utilities.py" xml:space="preserve">def get_cellml_element_type_from_enum(my_cause):

    my_type_as_string = "dunno"

    if my_cause == CellmlElementType.COMPONENT:
        my_type_as_string = "COMPONENT"

    elif my_cause == CellmlElementType.COMPONENT_REF:
        my_type_as_string = "COMPONENT_REf"

    elif my_cause == CellmlElementType.CONNECTION:
        my_type_as_string = "CONNECTION"

    elif my_cause == CellmlElementType.ENCAPSULATION:
        my_type_as_string = "ENCAPSULATION"

    elif my_cause == CellmlElementType.IMPORT:
        my_type_as_string = "IMPORT"

    elif my_cause == CellmlElementType.MATH:
        my_type_as_string = "MATH"

    elif my_cause == CellmlElementType.MAP_VARIABLES:
        my_type_as_string = "MAP_VARIABLES"

    elif my_cause == CellmlElementType.MODEL:
        my_type_as_string = "MODEL"

    elif my_cause == CellmlElementType.RESET:
        my_type_as_string = "RESET"

    elif my_cause == CellmlElementType.RESET_VALUE:
        my_type_as_string = "RESET_VALUE"

    elif my_cause == CellmlElementType.TEST_VALUE:
        my_type_as_string = "TEST_VALUE"

    elif my_cause == CellmlElementType.UNDEFINED:
        my_type_as_string = "UNDEFINED"

    elif my_cause == CellmlElementType.UNIT:
        my_type_as_string = "UNIT"

    elif my_cause == CellmlElementType.UNITS:
        my_type_as_string = "UNITS"

    elif my_cause == CellmlElementType.VARIABLE:
        my_type_as_string = "VARIABLE"

    return my_type_as_string
</literal_block>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/hsor001/Projects/cellml/sandbox/userguides/tutorials/utilities/utilities.py" xml:space="preserve">def get_issue_level_from_enum(my_level):

    my_type_as_string = "dunno"

    if my_level == Issue.Level.ERROR:
        my_type_as_string = "ERROR"

    elif my_level == Issue.Level.WARNING:
        my_type_as_string = "WARNING"
        
    elif my_level == Issue.Level.HINT:
        my_type_as_string = "HINT"

    elif my_level == Issue.Level.MESSAGE:
        my_type_as_string = "MESSAGE"

    return my_type_as_string
</literal_block>
                <paragraph>Full context: <download_reference filename="bdd36165f344361d452a18f7d3e3f141/utilities.py" refdoc="resources/code_snippets/snippet_get_issues" refdomain="" refexplicit="True" reftarget="/tutorials/utilities/utilities.py" reftype="download" refwarn="False"><literal classes="xref download">utilities.py</literal></download_reference></paragraph>
            </div>
        </container>
    </container>
</document>
