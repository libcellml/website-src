<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/Users/hsor001/Projects/cellml/sandbox/userguides/tutorials/hh_tutorial5/index.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/" xmlns:todo="https://www.sphinx-doc.org/">
    <target refid="solvegeneratedcode"></target>
    <section ids="hodgkin-huxley-5-interact-with-generated-code solvegeneratedcode" names="hodgkin-huxley\ 5:\ interact\ with\ generated\ code solvegeneratedcode">
        <title>Hodgkin-Huxley 5: Interact with generated code</title>
        <container classes="shortlist">
            <paragraph>By the time you have worked through this tutorial you will be able to:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Investigate and understand the contents of files created by the Generator; and</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Integrate generated code into a simple solver to run a simulation.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>This tutorial assumes that you are comfortable with:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Interacting with a model and its entities using the API;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Using the <literal classes="code">Generator</literal> functionality to output files in C or Python; and</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The basic idea of numerical integration using Euler’s method.</paragraph>
                </list_item>
            </bullet_list>
        </container>
        <container classes="directorylist">
            <paragraph><strong>C++ resources</strong></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><download_reference filename="b48bbfbc8ba9fd012702dc5cdf0a1102/CMakeLists.txt" refdoc="tutorials/hh_tutorial5/index" refdomain="" refexplicit="True" reftarget="CMakeLists.txt" reftype="download" refwarn="False"><literal classes="xref download">CMakeLists.txt</literal></download_reference> The CMake file for building this tutorial;</paragraph>
                </list_item>
                <list_item>
                    <paragraph><download_reference filename="887699a23290595598710e669a90db29/solveGeneratedCode.cpp" refdoc="tutorials/hh_tutorial5/index" refdomain="" refexplicit="True" reftarget="solveGeneratedCode.cpp" reftype="download" refwarn="False"><literal classes="xref download">solveGeneratedCode.cpp</literal></download_reference> Either the skeleton code, or ..</paragraph>
                </list_item>
                <list_item>
                    <paragraph><download_reference refdoc="tutorials/hh_tutorial5/index" refdomain="" refexplicit="True" reftarget="solveGeneratedCode_completed.cpp" reftype="download" refwarn="False"><literal classes="xref download">solveGeneratedCode_completed.cpp</literal></download_reference> the completed tutorial code;</paragraph>
                </list_item>
                <list_item>
                    <paragraph><download_reference filename="fdf6f335e1d7e260121061429d55819f/HodgkinHuxleyModel.cpp" refdoc="tutorials/hh_tutorial5/index" refdomain="" refexplicit="True" reftarget="HodgkinHuxleyModel.cpp" reftype="download" refwarn="False"><literal classes="xref download">HodgkinHuxleyModel.cpp</literal></download_reference> Generated implementation code from Tutorial 4; and</paragraph>
                </list_item>
                <list_item>
                    <paragraph><download_reference filename="48bb1439f5f2f277c7b4db5e69bdf8e9/HodgkinHuxleyModel.h" refdoc="tutorials/hh_tutorial5/index" refdomain="" refexplicit="True" reftarget="HodgkinHuxleyModel.h" reftype="download" refwarn="False"><literal classes="xref download">HodgkinHuxleyModel.h</literal></download_reference> Generated interface code from Tutorial 4.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph><strong>Python resources</strong></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><download_reference filename="52127715dd1e089b58dfd023c749321c/solveGeneratedCode.py" refdoc="tutorials/hh_tutorial5/index" refdomain="" refexplicit="True" reftarget="solveGeneratedCode.py" reftype="download" refwarn="False"><literal classes="xref download">solveGeneratedCode.py</literal></download_reference> Either the skeleton code, or ..</paragraph>
                </list_item>
                <list_item>
                    <paragraph><download_reference refdoc="tutorials/hh_tutorial5/index" refdomain="" refexplicit="True" reftarget="solveGeneratedCode_completed.py" reftype="download" refwarn="False"><literal classes="xref download">solveGeneratedCode_completed.py</literal></download_reference> the completed tutorial code;</paragraph>
                </list_item>
                <list_item>
                    <paragraph><download_reference filename="cacc75e5c31e3f37cc271c7a3de402ca/HodgkinHuxleyModel.py" refdoc="tutorials/hh_tutorial5/index" refdomain="" refexplicit="True" reftarget="HodgkinHuxleyModel.py" reftype="download" refwarn="False"><literal classes="xref download">HodgkinHuxleyModel.py</literal></download_reference> Generated implementation code from Tutorial 4.</paragraph>
                </list_item>
            </bullet_list>
        </container>
        <section ids="step-1-link-to-the-generated-code" names="step\ 1:\ link\ to\ the\ generated\ code">
            <title>Step 1: Link to the generated code</title>
            <paragraph>The first step in interacting with the output from the code generation is including the generated files in the project.
                There are necessarily big differences between C++ and Python for this tutorial!</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <container>
                    <container>
                        <container>
                            <paragraph>C++ instructions</paragraph>
                        </container>
                    </container>
                    <container>
                        <container classes="dothis">
                            <paragraph><strong>1.a</strong> Enter the path to the generated header/interface <literal classes="code">*.h</literal> file in the #include block above.</paragraph>
                        </container>
                        <container classes="dothis">
                            <paragraph><strong>1.b</strong> Add the name and path of the implementation <literal classes="code">*.cpp</literal> file in the CMakeLists.txt file, (or whatever your local toolchain requires).</paragraph>
                        </container>
                        <container classes="dothis">
                            <paragraph><strong>1.c</strong> Open the implementation file <literal classes="code">*.cpp</literal> file and verify that the <literal classes="code">#include</literal> statement in line 3 has the filename of your interface <literal classes="code">*.h</literal> file.
                                Amend if needed and close the file.</paragraph>
                        </container>
                        <container classes="dothis">
                            <paragraph><strong>1.d</strong> Call cmake to create the Makefile.
                                Call make -j to build the executable.
                                Run the code so far to check that the libCellML versions match.</paragraph>
                        </container>
                        <container classes="toggle">
                            <container classes="header">
                                <paragraph>Show C++ snippet</paragraph>
                            </container>
                        </container>
                    </container>
                </container>
                <container>
                    <container>
                        <container>
                            <paragraph>Python instructions</paragraph>
                        </container>
                    </container>
                    <container>
                        <container classes="dothis">
                            <paragraph><strong>1.a</strong> Use the importlib functionality to open the generated code file.</paragraph>
                        </container>
                        <container classes="dothis">
                            <paragraph><strong>1.b</strong> Load into a module.</paragraph>
                        </container>
                        <container classes="toggle">
                            <container classes="header">
                                <paragraph>Show Python snippet</paragraph>
                            </container>
                        </container>
                    </container>
                </container>
            </container>
        </section>
        <section ids="step-2-access-the-variables-in-the-generated-files" names="step\ 2:\ access\ the\ variables\ in\ the\ generated\ files">
            <title>Step 2: Access the variables in the generated files</title>
            <paragraph>Probably the best way to understand the contents of the generated files is o open them and look!
                The implementation file <literal classes="code">*.cpp</literal> has two types of items:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>information structures (in all-caps); and</paragraph>
                </list_item>
                <list_item>
                    <paragraph>access functions.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>It’s important to remember that in the generated code we don’t have the notion of separate components: they are listed here with the variables only in order to give the correct context to the variable names.</paragraph>
            <paragraph>“Variables” are anything which does not require integration as part of the solution, and could have types <literal classes="code">COMPUTED_CONSTANT</literal> (needs to be calculated but doesn’t need integration), <literal classes="code">CONSTANT</literal> (no calculation needed), or <literal classes="code">ALGEBRAIC</literal> (<strong>TODO</strong>) as defined in the <literal classes="code">VariableType</literal> enum.
                They are stored in an array of <literal classes="code">VariableInfoWithType</literal> structs called <literal classes="code">VARIABLE_INFO</literal> which is <literal classes="code">VARIABLE_COUNT</literal> long.</paragraph>
            <container classes="shortlist">
                <paragraph>The <literal classes="code">VariableInfoWithType</literal> contains:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>name,</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>units,</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>component, and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>VariableType.</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.a</strong> Get the number of variables and iterate through the <literal classes="code">VARIABLE_INFO</literal> structure to retrieve and print each variable’s information to the terminal.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
            </container>
            <paragraph>“State variables” are those which need integration.
                They are stored in an array of <literal classes="code">VariableInfo</literal> structs called <literal classes="code">STATE_INFO</literal> which
                is <literal classes="code">STATE_COUNT</literal> long.</paragraph>
            <container classes="shortlist">
                <paragraph>The <literal classes="code">VariableInfo</literal> struct contains:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>name,</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>units, and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>component.</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.b</strong> Get the number of state variables and iterate through the <literal classes="code">STATE_INFO</literal> structure to retrieve and print each state variable’s information to the terminal.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.c</strong> Get the integration variable and print its information to the terminal.
                    This is stored in a <literal classes="code">VariableInfo</literal> struct called <literal classes="code">VOI_INFO</literal>.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
            </container>
        </section>
        <section ids="step-3-access-the-functions-in-the-generated-files" names="step\ 3:\ access\ the\ functions\ in\ the\ generated\ files">
            <title>Step 3: Access the functions in the generated files</title>
            <container classes="sphinx-tabs" type="tab-element">
                <container>
                    <container>
                        <container>
                            <paragraph>C++</paragraph>
                        </container>
                    </container>
                    <container>
                        <paragraph>The generated code contains seven functions:</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph><literal classes="code">createStatesArray()</literal> to allocate an array of length <literal classes="code">STATE_COUNT</literal>.
                                    This can be used to allocate the “rates” or gradient function array too as they’re the same length;</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">createVariablesArray()</literal> to allocate an array of length <literal classes="code">VARIABLE_COUNT</literal>;</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">deleteArray()</literal> to free memory used by the given array;</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">initialiseStatesAndConstants(states, variables)</literal> will do what it says on the tin, and populate the given pre-allocated arrays with the initial values for all of the model’s state variables and constants.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">computeComputedConstants(variables)</literal> will fill in values for any variables that do not change in value throughout the solution, but still need to be calculated;</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">computeRates(VOI, states, rates, variables)</literal> updates the rates array with the gradients of the state variables, given the values of the other variables and the variable of integration (VOI);</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">computeVariables(VOI, states, rates, variables)</literal> updates any non-integrated variables whose values do not affect the integration.
                                    Since this doesn’t affect the solution process it only needs to be called whenever the values need to be output; not necessarily each integration timestep.</paragraph>
                            </list_item>
                        </bullet_list>
                    </container>
                </container>
                <container>
                    <container>
                        <container>
                            <paragraph>Python</paragraph>
                        </container>
                    </container>
                    <container>
                        <paragraph>The generated code contains seven functions:</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph><literal classes="code">create_states_array()</literal> to allocate an array of length <literal classes="code">STATE_COUNT</literal>.
                                    This can be used to allocate the “rates” or gradient function array too as they’re the same length;</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">create_variables_array()</literal> to allocate an array of length <literal classes="code">VARIABLE_COUNT</literal>;</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">delete_array()</literal> to free memory used by the given array;</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">initialise_states_and_constants(states, variables)</literal> will do what it says on the tin, and populate the given pre-allocated arrays with the initial values for all of the model’s state variables and constants.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">compute_computed_constants(variables)</literal> will fill in values for any variables that do not change in value throughout the solution, but still need to be calculated;</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">compute_rates(VOI, states, rates, variables)</literal> updates the rates array with the gradients of the state variables, given the values of the other variables and the variable of integration (VOI);</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">compute_variables(VOI, states, rates, variables)</literal> updates any non-integrated variables whose values do not affect the integration.
                                    Since this doesn’t affect the solution process it only needs to be called whenever the values need to be output; not necessarily each integration timestep.</paragraph>
                            </list_item>
                        </bullet_list>
                    </container>
                </container>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.a</strong> Create three arrays representing:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>the variables (which here includes constants);</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>the states (the integrated variables); and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>the rates.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Create and initialise a variable of integration, time.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.b</strong> Use the functions provided to initialise the states array you created, then print them to the screen for checking.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.c</strong> Compute the constants, compute the variables, and print them to the screen for checking.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
            </container>
        </section>
        <section ids="step-4-iterate-through-the-solution" names="step\ 4:\ iterate\ through\ the\ solution">
            <title>Step 4: Iterate through the solution</title>
            <paragraph>This part will make use of a simple routine to step through the solution iterations using the Euler method to update the state variables.</paragraph>
            <container classes="dothis">
                <paragraph><strong>4.a</strong> Create variables which control how the solution will run, representing:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>step size; and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>the number of steps to take.</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
            </container>
            <container classes="dothis">
                <paragraph><strong>4.b</strong> Create a file for output and open it.
                    You can use the information to name columns with the variables, component, and units so you can keep track later.</paragraph>
            </container>
            <paragraph>The Euler update method is: <math>x[n+1] = x[n] + x'[n].dx</math></paragraph>
            <container classes="shortlist">
                <definition_list>
                    <definition_list_item>
                        <term>At each step you will need to:</term>
                        <definition>
                            <bullet_list bullet="-">
                                <list_item>
                                    <paragraph>Compute the rates;</paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph>Compute the state variables using the update method above;</paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph>Compute the variables; **</paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph>Print to a file.</paragraph>
                                </list_item>
                            </bullet_list>
                        </definition>
                    </definition_list_item>
                </definition_list>
                <paragraph>** We only need to compute these each timestep here because we’re also writing the values to the file at each timestep.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
            </container>
            <container classes="dothis">
                <paragraph><strong>4.c</strong> Iterate through the time domain, calculate and write the solution at each step.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
            </container>
        </section>
        <section ids="step-5-sanity-check" names="step\ 5:\ sanity\ check">
            <title>Step 5: Sanity check</title>
            <paragraph>The file that results from running the completed version of this tutorial can be downloaded from <download_reference filename="c3dd6396afe5daaf976b97c08651b82e/HodgkinHuxleyModelSolution.txt" refdoc="tutorials/hh_tutorial5/index" refdomain="" refexplicit="True" reftarget="HodgkinHuxleyModelSolution.txt" reftype="download" refwarn="False"><literal classes="xref download">HodgkinHuxleyModelSolution.txt</literal></download_reference>, and is a tab-delimited file that can be easily read into your favourite plotting program.</paragraph>
        </section>
    </section>
</document>
