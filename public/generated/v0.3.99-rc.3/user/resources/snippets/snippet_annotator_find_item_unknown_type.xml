<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.18.1 -->
<document source="/Users/libcellml/BuildbotWorker/Finalise_Release_Builder/user-guides/resources/snippets/snippet_annotator_find_item_unknown_type.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/" xmlns:todo="https://www.sphinx-doc.org/">
    <target refid="snippet-annotator-find-item-unknown-type"></target>
    <container classes="toggle" ids="snippet-annotator-find-item-unknown-type" names="snippet_annotator_find_item_unknown_type">
        <container classes="header-left">
            <paragraph>Retrieve an item of unknown type by id</paragraph>
        </container>
        <paragraph>In situations where you have an id string, but donâ€™t know the type of the object it identifies, the item can be retrieved using a general <literal classes="code" language="">Annotator::item(itemId)</literal> function.
            The general <literal classes="code" language="">item</literal> function will return an <literal classes="code" language="">AnyItem</literal> pair.
            The first part of the pair is an enum of the type of the object.
            The second part is an <literal classes="code" language="">std::any</literal> type object, which can be cast into the correct type.
            This is demonstrated below.</paragraph>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" classes="closeable" role="tablist">
                <button aria-controls="panel-0-Qysr" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-Qysr" name="Qysr" role="tab" tabindex="0">C++</button>
                <button aria-controls="panel-0-UHl0aG9u" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-UHl0aG9u" name="UHl0aG9u" role="tab" tabindex="-1">Python</button>
            </div>
            <div aria-labelledby="tab-0-Qysr" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-Qysr" name="Qysr" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="c++" linenos="False" xml:space="preserve">// Create an Annotator.
auto annotator = libcellml::Annotator::create();

// Build the annotator to work with the model.
annotator-&gt;buildModelIndex(model);

// Retrieve an item of unknown type from the annotator.
auto anyItem = annotator-&gt;item("findThisId");

// Depending on the item's type (which is stored in the first part of the AnyItem
// pair), cast the second part to the appropriate pointer type. Note that this means
// first declaring a range of variables of different types to which the cast
// pointer can be assigned.

libcellml::ComponentPtr itemComponent;
libcellml::VariablePtr itemVariable;
libcellml::ResetPtr itemReset;
libcellml::UnitsPtr itemUnits;
libcellml::ImportSourcePtr itemImportSource;
libcellml::VariablePair itemVariablePair;
libcellml::Unit itemUnit;

switch (anyItem.first) {
    case libcellml::Annotator::Type::COMPONENT:
    case libcellml::Annotator::Type::COMPONENT_REF:
        itemComponent = std::any_cast&lt;libcellml::ComponentPtr&gt;(anyItem.second);
        break;
    case libcellml::Annotator::Type::CONNECTION:
    case libcellml::Annotator::Type::MAP_VARIABLES:
        itemVariablePair = std::any_cast&lt;libcellml::VariablePair&gt;(anyItem.second);
        break;
    case libcellml::Annotator::Type::IMPORT:
        itemImportItem = std::any_cast&lt;libcellml::ImportSourcePtr&gt;(anyItem.second);
        break;
    case libcellml::Annotator::Type::ENCAPSULATION:
    case libcellml::Annotator::Type::MODEL:
        itemModel = std::any_cast&lt;libcellml::ModelPtr&gt;(anyItem.second);
        break;
    case libcellml::Annotator::Type::RESET:
    case libcellml::Annotator::Type::RESET_VALUE:
    case libcellml::Annotator::Type::TEST_VALUE:
        itemReset = std::any_cast&lt;libcellml::ResetPtr&gt;(anyItem.second);
        break;
    case libcellml::Annotator::Type::UNIT:
        itemUnit = std::any_cast&lt;libcellml::Unit&gt;(anyItem.second);
        break;
    case libcellml::Annotator::Type::UNITS:
        itemUnits = std::any_cast&lt;libcellml::UnitsPtr&gt;(anyItem.second);
        break;
    case libcellml::Annotator::Type::VARIABLE:
        itemVariable = std::any_cast&lt;libcellml::VariablePtr&gt;(anyItem.second);
        break;
    }
}

// Note also that attempting to cast into the wrong type will trigger a
// "bad any cast" exception.
try {
    assert(itemVariable.first == Annotator::Type::VARIABLE);
    auto thisWillNotWork = std::any_cast&lt;libcellml::UnitsPtr&gt;(itemVariable.second);
}
catch(const std::bad_any_cast&amp; e) {
    // Depending on your system, this will return a "bad any cast", "bad any_cast"
    // or "bad_any_cast" message.
    std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
}</literal_block>
            </div>
            <div aria-labelledby="tab-0-UHl0aG9u" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-UHl0aG9u" name="UHl0aG9u" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="py" linenos="False" xml:space="preserve"># TODO</literal_block>
            </div>
        </container>
    </container>
</document>
