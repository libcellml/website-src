<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="classlibcellml_1_1Model" kind="class" language="C++" prot="public">
    <compoundname>libcellml::Model</compoundname>
    <basecompoundref refid="classlibcellml_1_1ComponentEntity" prot="public" virt="non-virtual">libcellml::ComponentEntity</basecompoundref>
    <basecompoundref prot="public" virt="non-virtual">std::enable_shared_from_this&lt; Model &gt;</basecompoundref>
    <includes refid="model_8h" local="no">model.h</includes>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="classlibcellml_1_1Model_1afacb342379c91cbdce35325f42404620" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>libcellml::Model::~Model</definition>
        <argsstring>() override</argsstring>
        <name>~Model</name>
        <qualifiedname>libcellml::Model::~Model</qualifiedname>
        <briefdescription>
<para>Destructor,. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="43" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1ad0d6354a3b1329897a5900beae9acba3" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>libcellml::Model::Model</definition>
        <argsstring>(const Model &amp;rhs)=delete</argsstring>
        <name>Model</name>
        <qualifiedname>libcellml::Model::Model</qualifiedname>
        <param>
          <type>const <ref refid="classlibcellml_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
<para>Copy constructor,. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="44" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1a8130b562ed2687511f2eedfb00168039" prot="private" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>libcellml::Model::Model</definition>
        <argsstring>(Model &amp;&amp;rhs) noexcept=delete</argsstring>
        <name>Model</name>
        <qualifiedname>libcellml::Model::Model</qualifiedname>
        <param>
          <type><ref refid="classlibcellml_1_1Model" kindref="compound">Model</ref> &amp;&amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
<para>Move constructor,. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="45" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1ab81a266901c8890fa237bfab6baf8da7" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classlibcellml_1_1Model" kindref="compound">Model</ref> &amp;</type>
        <definition>Model &amp; libcellml::Model::operator=</definition>
        <argsstring>(Model rhs)=delete</argsstring>
        <name>operator=</name>
        <qualifiedname>libcellml::Model::operator=</qualifiedname>
        <param>
          <type><ref refid="classlibcellml_1_1Model" kindref="compound">Model</ref></type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
<para>Assignment operator,. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="46" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1a9903959fe09e5ac980de27bc349ca2ce" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>libcellml::Model::Model</definition>
        <argsstring>()</argsstring>
        <name>Model</name>
        <qualifiedname>libcellml::Model::Model</qualifiedname>
        <briefdescription>
<para>Constructor,. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="377" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1acb13f38228f2087d2894a6405653e3c4" prot="private" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>libcellml::Model::Model</definition>
        <argsstring>(const std::string &amp;name)</argsstring>
        <name>Model</name>
        <qualifiedname>libcellml::Model::Model</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Constructor with std::string parameter,. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="378" column="14"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1a4ceb895e818175f55049274768d9c755" prot="private" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool libcellml::Model::doAddComponent</definition>
        <argsstring>(const ComponentPtr &amp;component) override</argsstring>
        <name>doAddComponent</name>
        <qualifiedname>libcellml::Model::doAddComponent</qualifiedname>
        <reimplements refid="classlibcellml_1_1ComponentEntity_1a7b2b78965a148814ac7e17af8df11737">doAddComponent</reimplements>
        <param>
          <type>const <ref refid="namespacelibcellml_1a89d6be0709eeec30793d9587b16dce5b" kindref="member">ComponentPtr</ref> &amp;</type>
          <declname>component</declname>
        </param>
        <briefdescription>
<para>Virtual implementation method for addComponent,. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="380" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1ae8c294eaf48de567c51ca435f7d1ed12" prot="private" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool libcellml::Model::doEquals</definition>
        <argsstring>(const EntityPtr &amp;other) const override</argsstring>
        <name>doEquals</name>
        <qualifiedname>libcellml::Model::doEquals</qualifiedname>
        <reimplements refid="classlibcellml_1_1ComponentEntity_1af77ead1c1e8b11748fa9341239ed63d7">doEquals</reimplements>
        <param>
          <type>const <ref refid="namespacelibcellml_1abc54532bee96378fd9caabd0d50f615e" kindref="member">EntityPtr</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Virtual implementation method for equals,. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="382" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1aa46588744f9b78cb980a1bd41f62ac17" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ModelImpl *</type>
        <definition>ModelImpl * libcellml::Model::pFunc</definition>
        <argsstring>()</argsstring>
        <name>pFunc</name>
        <qualifiedname>libcellml::Model::pFunc</qualifiedname>
        <briefdescription>
<para>Forward declaration for pImpl idiom,. </para>
        </briefdescription>
        <detaileddescription>
<para>Getter for private implementation pointer,. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="386" column="15"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1a3df115a242c1cdd5e96cc37b03dc033a" prot="private" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const ModelImpl *</type>
        <definition>const ModelImpl * libcellml::Model::pFunc</definition>
        <argsstring>() const</argsstring>
        <name>pFunc</name>
        <qualifiedname>libcellml::Model::pFunc</qualifiedname>
        <briefdescription>
<para>Const getter for private implementation pointer,. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="387" column="21"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classlibcellml_1_1Model_1a99f9deb9dfa4b3fbae57dc83ff6f25c2" prot="public" static="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="namespacelibcellml_1a8964f62e8f622cfd511f6a3acd9ce628" kindref="member">ModelPtr</ref></type>
        <definition>static ModelPtr libcellml::Model::create</definition>
        <argsstring>() noexcept</argsstring>
        <name>create</name>
        <qualifiedname>libcellml::Model::create</qualifiedname>
        <briefdescription>
<para>Create a <computeroutput><ref refid="classlibcellml_1_1Model" kindref="compound">Model</ref></computeroutput> object. </para>
        </briefdescription>
        <detaileddescription>
<para>Factory method to create a <computeroutput><ref refid="classlibcellml_1_1Model" kindref="compound">Model</ref></computeroutput>. Create a blank model with::</para>
<para>ModelPtr model = <ref refid="classlibcellml_1_1Model_1a99f9deb9dfa4b3fbae57dc83ff6f25c2" kindref="member">libcellml::Model::create()</ref>;</para>
<para>or a named model with name &quot;Model&quot; with::</para>
<para>ModelPtr model = <ref refid="classlibcellml_1_1Model_1a99f9deb9dfa4b3fbae57dc83ff6f25c2" kindref="member">libcellml::Model::create</ref>(&quot;Model&quot;);</para>
<para><simplesect kind="return"><para>A smart pointer to a <computeroutput><ref refid="classlibcellml_1_1Model" kindref="compound">Model</ref></computeroutput> object. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="62" column="21"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1ac82c833a60900daec99671c16ae1af60" prot="public" static="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="namespacelibcellml_1a8964f62e8f622cfd511f6a3acd9ce628" kindref="member">ModelPtr</ref></type>
        <definition>static ModelPtr libcellml::Model::create</definition>
        <argsstring>(const std::string &amp;name) noexcept</argsstring>
        <name>create</name>
        <qualifiedname>libcellml::Model::create</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="67" column="21"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classlibcellml_1_1Model_1a91c0c4df78d08ccade6ce6fab998f363" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool libcellml::Model::addUnits</definition>
        <argsstring>(const UnitsPtr &amp;units)</argsstring>
        <name>addUnits</name>
        <qualifiedname>libcellml::Model::addUnits</qualifiedname>
        <param>
          <type>const <ref refid="namespacelibcellml_1a3259debe09f915678b203e98100ea10a" kindref="member">UnitsPtr</ref> &amp;</type>
          <declname>units</declname>
        </param>
        <briefdescription>
<para>Add a child units item to this model. </para>
        </briefdescription>
        <detaileddescription>
<para>Add units by reference to the model. If the units item was previously in a different model, it is moved to this one, and the previous model&apos;s units list is updated.</para>
<para>The function will return <computeroutput>false</computeroutput> and no action is taken if:<itemizedlist>
<listitem><para>The <computeroutput>units</computeroutput> is <computeroutput>nullptr</computeroutput>.</para>
</listitem></itemizedlist>
</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>units</parametername>
</parameternamelist>
<parameterdescription>
<para>The units to add.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>true</computeroutput> if the units item is added or <computeroutput>false</computeroutput> otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="83" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1a525cf9d149d07d4cf98ca3c5cc6ac63e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool libcellml::Model::removeUnits</definition>
        <argsstring>(size_t index)</argsstring>
        <name>removeUnits</name>
        <qualifiedname>libcellml::Model::removeUnits</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>index</declname>
        </param>
        <briefdescription>
<para>Remove the units at the given <computeroutput>index</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>Remove the units from this model at the given <computeroutput>index</computeroutput>. <computeroutput>index</computeroutput> must be in the range [0, #units).</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>The index of the units to remove.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the units were removed, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="95" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1a9bdd0b2ead32d3afacb8662591637866" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool libcellml::Model::removeUnits</definition>
        <argsstring>(const std::string &amp;name)</argsstring>
        <name>removeUnits</name>
        <qualifiedname>libcellml::Model::removeUnits</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para>
        </briefdescription>
        <detaileddescription>
<para>Remove the units with the given <computeroutput>name</computeroutput>.</para>
<para>Remove the first units found with the given <computeroutput>name</computeroutput>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the units to remove.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the units were removed, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="108" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1a3109a4b45d445ddf80a792ce5331c130" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool libcellml::Model::removeUnits</definition>
        <argsstring>(const UnitsPtr &amp;units)</argsstring>
        <name>removeUnits</name>
        <qualifiedname>libcellml::Model::removeUnits</qualifiedname>
        <param>
          <type>const <ref refid="namespacelibcellml_1a3259debe09f915678b203e98100ea10a" kindref="member">UnitsPtr</ref> &amp;</type>
          <declname>units</declname>
        </param>
        <briefdescription>
<para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para>
        </briefdescription>
        <detaileddescription>
<para>Remove the units with the given pointer.</para>
<para>Remove the units with the pointer <computeroutput>units</computeroutput>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>units</parametername>
</parameternamelist>
<parameterdescription>
<para>The pointer to the units to remove.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the units were removed, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="121" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1a259f6a31db54fa1940c4b220d8fc40d9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libcellml::Model::removeAllUnits</definition>
        <argsstring>()</argsstring>
        <name>removeAllUnits</name>
        <qualifiedname>libcellml::Model::removeAllUnits</qualifiedname>
        <briefdescription>
<para>Remove all units stored in this model. </para>
        </briefdescription>
        <detaileddescription>
<para>Clears all units that have been added to this model. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="128" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1acb6314e3b306b3100912c8f35440ef8d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool libcellml::Model::hasUnits</definition>
        <argsstring>(const std::string &amp;name) const</argsstring>
        <name>hasUnits</name>
        <qualifiedname>libcellml::Model::hasUnits</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Tests to see if the units is within this model. </para>
        </briefdescription>
        <detaileddescription>
<para>Tests to see if the units with the given <computeroutput>name</computeroutput> is contained within this model. Returns <computeroutput>true</computeroutput> if the units is in the model and <computeroutput>false</computeroutput> otherwise.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the units to test for existence in this model.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>true</computeroutput> if the named units is in the model and <computeroutput>false</computeroutput> otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="143" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1a54befdd09b177dd94b9f17ce851ceb56" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool libcellml::Model::hasUnits</definition>
        <argsstring>(const UnitsPtr &amp;units) const</argsstring>
        <name>hasUnits</name>
        <qualifiedname>libcellml::Model::hasUnits</qualifiedname>
        <param>
          <type>const <ref refid="namespacelibcellml_1a3259debe09f915678b203e98100ea10a" kindref="member">UnitsPtr</ref> &amp;</type>
          <declname>units</declname>
        </param>
        <briefdescription>
<para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para>
        </briefdescription>
        <detaileddescription>
<para>Tests to see if the units is within this model.</para>
<para>Tests to see if the given <computeroutput>units</computeroutput> is contained within this model. Returns <computeroutput>true</computeroutput> if the units is in the model and <computeroutput>false</computeroutput> otherwise.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>units</parametername>
</parameternamelist>
<parameterdescription>
<para>The units to test for existence in this model.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>true</computeroutput> if the units is in the model and <computeroutput>false</computeroutput> otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="157" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1aaa361f12facc6238fae768f0f7892181" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespacelibcellml_1a3259debe09f915678b203e98100ea10a" kindref="member">UnitsPtr</ref></type>
        <definition>UnitsPtr libcellml::Model::units</definition>
        <argsstring>(size_t index) const</argsstring>
        <name>units</name>
        <qualifiedname>libcellml::Model::units</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>index</declname>
        </param>
        <briefdescription>
<para>Get the units item at the given <computeroutput>index</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>Returns a reference to a units at the given <computeroutput>index</computeroutput>. If the <computeroutput>index</computeroutput> is not valid a <computeroutput>nullptr</computeroutput> is returned, the range of valid values for the index is [0, #units).</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>The index of the units to return.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A reference to the units at the given <computeroutput>index</computeroutput> on success, <computeroutput>nullptr</computeroutput> otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="170" column="14"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1aa8ae761b6e496176a29e42a43d971922" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespacelibcellml_1a3259debe09f915678b203e98100ea10a" kindref="member">UnitsPtr</ref></type>
        <definition>UnitsPtr libcellml::Model::units</definition>
        <argsstring>(const std::string &amp;name) const</argsstring>
        <name>units</name>
        <qualifiedname>libcellml::Model::units</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para>
        </briefdescription>
        <detaileddescription>
<para>Get a units with the given <computeroutput>name</computeroutput>.</para>
<para>Returns a reference to a units with the given <computeroutput>name</computeroutput>. If the <computeroutput>name</computeroutput> is not valid a <computeroutput>nullptr</computeroutput> is returned.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the units to return.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A reference to the units with the given <computeroutput>name</computeroutput> on success, <computeroutput>nullptr</computeroutput> otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="184" column="14"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1ac9d804868b33ab6e685fc9e4b41dc618" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespacelibcellml_1a3259debe09f915678b203e98100ea10a" kindref="member">UnitsPtr</ref></type>
        <definition>UnitsPtr libcellml::Model::takeUnits</definition>
        <argsstring>(size_t index)</argsstring>
        <name>takeUnits</name>
        <qualifiedname>libcellml::Model::takeUnits</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>index</declname>
        </param>
        <briefdescription>
<para>Take the units at the given <computeroutput>index</computeroutput> and return it. </para>
        </briefdescription>
        <detaileddescription>
<para>Removes the units at the given <computeroutput>index</computeroutput> position and returns it. <computeroutput>index</computeroutput> must be in the range [0, #units).</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>The index of the units to take.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A reference to the units at the given <computeroutput>index</computeroutput> if the index is valid, <computeroutput>nullptr</computeroutput> otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="196" column="14"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1a7609c3fba45ff860eff9fc989ae01f83" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespacelibcellml_1a3259debe09f915678b203e98100ea10a" kindref="member">UnitsPtr</ref></type>
        <definition>UnitsPtr libcellml::Model::takeUnits</definition>
        <argsstring>(const std::string &amp;name)</argsstring>
        <name>takeUnits</name>
        <qualifiedname>libcellml::Model::takeUnits</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para>
        </briefdescription>
        <detaileddescription>
<para>Take the units with the given <computeroutput>name</computeroutput> and return it.</para>
<para>Takes the first occurrence of the units with the given name <computeroutput>name</computeroutput> and returns it. If no units with name <computeroutput>name</computeroutput> is found then a <computeroutput>nullptr</computeroutput> is returned.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the units to take.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A reference to the units identified with the given <computeroutput>name</computeroutput> if found, <computeroutput>nullptr</computeroutput> otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="210" column="14"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1aa526cbea5a87fe41a4c602fd0c15e40c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool libcellml::Model::replaceUnits</definition>
        <argsstring>(size_t index, const UnitsPtr &amp;units)</argsstring>
        <name>replaceUnits</name>
        <qualifiedname>libcellml::Model::replaceUnits</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>index</declname>
        </param>
        <param>
          <type>const <ref refid="namespacelibcellml_1a3259debe09f915678b203e98100ea10a" kindref="member">UnitsPtr</ref> &amp;</type>
          <declname>units</declname>
        </param>
        <briefdescription>
<para>Replace a units at the given <computeroutput>index</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>Replaces the units at the given <computeroutput>index</computeroutput> with <computeroutput>units</computeroutput>. <computeroutput>index</computeroutput> must be in the range [0, #units).</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the units to replace. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>units</parametername>
</parameternamelist>
<parameterdescription>
<para>The units to use for replacement.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the units were replaced, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="223" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1ad94f8aadac6b93760bf1f9f8d2a7c81d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool libcellml::Model::replaceUnits</definition>
        <argsstring>(const std::string &amp;name, const UnitsPtr &amp;units)</argsstring>
        <name>replaceUnits</name>
        <qualifiedname>libcellml::Model::replaceUnits</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const <ref refid="namespacelibcellml_1a3259debe09f915678b203e98100ea10a" kindref="member">UnitsPtr</ref> &amp;</type>
          <declname>units</declname>
        </param>
        <briefdescription>
<para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para>
        </briefdescription>
        <detaileddescription>
<para>Replace a units with the given <computeroutput>name</computeroutput>.</para>
<para>Replaces the units with the given <computeroutput>name</computeroutput> with <computeroutput>units</computeroutput>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the units to replace. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>units</parametername>
</parameternamelist>
<parameterdescription>
<para>The units to use for replacement.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the units were replaced, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="237" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1ac2e76f7fff925c6f6aa387ec7e0c1549" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool libcellml::Model::replaceUnits</definition>
        <argsstring>(const UnitsPtr &amp;oldUnits, const UnitsPtr &amp;newUnits)</argsstring>
        <name>replaceUnits</name>
        <qualifiedname>libcellml::Model::replaceUnits</qualifiedname>
        <param>
          <type>const <ref refid="namespacelibcellml_1a3259debe09f915678b203e98100ea10a" kindref="member">UnitsPtr</ref> &amp;</type>
          <declname>oldUnits</declname>
        </param>
        <param>
          <type>const <ref refid="namespacelibcellml_1a3259debe09f915678b203e98100ea10a" kindref="member">UnitsPtr</ref> &amp;</type>
          <declname>newUnits</declname>
        </param>
        <briefdescription>
<para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para>
        </briefdescription>
        <detaileddescription>
<para>Replace a units with another units.</para>
<para>Replaces one units with another.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>oldUnits</parametername>
</parameternamelist>
<parameterdescription>
<para>The units to be replaced. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>newUnits</parametername>
</parameternamelist>
<parameterdescription>
<para>The units to use for replacement.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the units were replaced, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="251" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1aba003d544dbecaddbf07ddda8344a457" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t libcellml::Model::unitsCount</definition>
        <argsstring>() const</argsstring>
        <name>unitsCount</name>
        <qualifiedname>libcellml::Model::unitsCount</qualifiedname>
        <briefdescription>
<para>Get the number of units in the model. </para>
        </briefdescription>
        <detaileddescription>
<para>Returns the number of units the model contains.</para>
<para><simplesect kind="return"><para>The number of units. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="260" column="12"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1a40de01d2effd4894738b6f3a4f5adbcd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool libcellml::Model::linkUnits</definition>
        <argsstring>()</argsstring>
        <name>linkUnits</name>
        <qualifiedname>libcellml::Model::linkUnits</qualifiedname>
        <briefdescription>
<para>Link the units used in this model. </para>
        </briefdescription>
        <detaileddescription>
<para>Traverses the model looking for <computeroutput><ref refid="classlibcellml_1_1Units" kindref="compound">Units</ref></computeroutput> attached to <computeroutput>Variables</computeroutput> that are not standard units and which are not linked to <computeroutput><ref refid="classlibcellml_1_1Units" kindref="compound">Units</ref></computeroutput> added to the model. This method will link variable units specified by name to units in the model (if they are found). Any variable units that cannot be linked to units in the model are left in an unlinked state. This means it is possible to still have unlinked <computeroutput><ref refid="classlibcellml_1_1Units" kindref="compound">Units</ref></computeroutput> in the model after calling this method.</para>
<para>Unlinked variable units can occur when a <computeroutput><ref refid="classlibcellml_1_1Variable" kindref="compound">Variable</ref>&apos;s</computeroutput> units are set by name. If the <computeroutput><ref refid="classlibcellml_1_1Model" kindref="compound">Model</ref></computeroutput> to which the <computeroutput><ref refid="classlibcellml_1_1Variable" kindref="compound">Variable</ref></computeroutput> belongs has <computeroutput><ref refid="classlibcellml_1_1Units" kindref="compound">Units</ref></computeroutput> defined with the same name, then that <computeroutput><ref refid="classlibcellml_1_1Variable" kindref="compound">Variable</ref>&apos;s</computeroutput> <computeroutput><ref refid="classlibcellml_1_1Units" kindref="compound">Units</ref></computeroutput> will not be linked to the <computeroutput><ref refid="classlibcellml_1_1Model" kindref="compound">Model</ref>&apos;s</computeroutput> <computeroutput><ref refid="classlibcellml_1_1Units" kindref="compound">Units</ref></computeroutput>. This method will link the two units (the one from the variable and the one from the model).</para>
<para>If a <computeroutput><ref refid="classlibcellml_1_1Variable" kindref="compound">Variable</ref></computeroutput> has units that are not found in the model then the units will remain unlinked, and this will return <computeroutput>false</computeroutput>.</para>
<para><simplesect kind="return"><para><computeroutput>true</computeroutput> upon success; <computeroutput>false</computeroutput> if some units have not been linked. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="286" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1afeb644177e2e6a3ba506660319864470" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool libcellml::Model::hasUnlinkedUnits</definition>
        <argsstring>()</argsstring>
        <name>hasUnlinkedUnits</name>
        <qualifiedname>libcellml::Model::hasUnlinkedUnits</qualifiedname>
        <briefdescription>
<para>Test to determine if any variable units are not linked to model units. </para>
        </briefdescription>
        <detaileddescription>
<para>Traverses the model to determine if any <computeroutput><ref refid="classlibcellml_1_1Units" kindref="compound">Units</ref></computeroutput> attached to variables are not <computeroutput><ref refid="classlibcellml_1_1Units" kindref="compound">Units</ref></computeroutput> attached to the model.</para>
<para><simplesect kind="return"><para>True if any <computeroutput><ref refid="classlibcellml_1_1Units" kindref="compound">Units</ref></computeroutput> attached to variables are not linked to units in the model, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="297" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1ace2367c655c6fea24e6cafc04f3fa409" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool libcellml::Model::hasImports</definition>
        <argsstring>() const</argsstring>
        <name>hasImports</name>
        <qualifiedname>libcellml::Model::hasImports</qualifiedname>
        <briefdescription>
<para>Test to determine if there are any import entities. </para>
        </briefdescription>
        <detaileddescription>
<para>Checks the model to determine if there are any <computeroutput><ref refid="classlibcellml_1_1Units" kindref="compound">Units</ref></computeroutput> or <computeroutput>Components</computeroutput> which are imports. Returns <computeroutput>true</computeroutput> if the model has at least one <computeroutput><ref refid="classlibcellml_1_1Units" kindref="compound">Units</ref></computeroutput> or <computeroutput><ref refid="classlibcellml_1_1Component" kindref="compound">Component</ref></computeroutput> which is an imported <computeroutput><ref refid="classlibcellml_1_1Units" kindref="compound">Units</ref></computeroutput> or <computeroutput><ref refid="classlibcellml_1_1Component" kindref="compound">Component</ref></computeroutput>.</para>
<para><simplesect kind="return"><para>True if the <computeroutput><ref refid="classlibcellml_1_1Model" kindref="compound">Model</ref></computeroutput> has a <computeroutput><ref refid="classlibcellml_1_1Units" kindref="compound">Units</ref></computeroutput> or <computeroutput><ref refid="classlibcellml_1_1Component" kindref="compound">Component</ref></computeroutput> that is an import, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="310" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1a4ca499826b7253eca79c865f6b8bf8bb" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool libcellml::Model::hasUnresolvedImports</definition>
        <argsstring>() const</argsstring>
        <name>hasUnresolvedImports</name>
        <qualifiedname>libcellml::Model::hasUnresolvedImports</qualifiedname>
        <briefdescription>
<para>Test if this model has unresolved imports. </para>
        </briefdescription>
        <detaileddescription>
<para>Test all components and units of this model and determine if the imported entities are fully resolved.</para>
<para><simplesect kind="return"><para><computeroutput>true</computeroutput> if the <computeroutput><ref refid="classlibcellml_1_1Model" kindref="compound">Model</ref></computeroutput> has unresolved imports and <computeroutput>false</computeroutput> otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="319" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1a27fa60c2ea8043954f37a4cd7bcbcb39" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool libcellml::Model::isDefined</definition>
        <argsstring>() const</argsstring>
        <name>isDefined</name>
        <qualifiedname>libcellml::Model::isDefined</qualifiedname>
        <briefdescription>
<para>Test if this model is fully defined. </para>
        </briefdescription>
        <detaileddescription>
<para>Test all components and units of this model and determine if they are all fully defined.</para>
<para><simplesect kind="return"><para><computeroutput>true</computeroutput> if the <computeroutput><ref refid="classlibcellml_1_1Model" kindref="compound">Model</ref></computeroutput> is defined, <computeroutput>false</computeroutput> otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="328" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1a1844f4c3ab78c314bcfb0028c8522a59" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespacelibcellml_1a8964f62e8f622cfd511f6a3acd9ce628" kindref="member">ModelPtr</ref></type>
        <definition>ModelPtr libcellml::Model::clone</definition>
        <argsstring>() const</argsstring>
        <name>clone</name>
        <qualifiedname>libcellml::Model::clone</qualifiedname>
        <briefdescription>
<para>Create a clone of this model. </para>
        </briefdescription>
        <detaileddescription>
<para>Creates a full separate copy of this model. The component hierarchy and variable equivalence maps will also be copied from this model to the destination model.</para>
<para><simplesect kind="return"><para>a new <computeroutput>ModelPtr</computeroutput> to the cloned model. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="339" column="14"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1adff8d728f64996d5bb9d744e28efac1f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool libcellml::Model::fixVariableInterfaces</definition>
        <argsstring>()</argsstring>
        <name>fixVariableInterfaces</name>
        <qualifiedname>libcellml::Model::fixVariableInterfaces</qualifiedname>
        <briefdescription>
<para>Fix <computeroutput><ref refid="classlibcellml_1_1Variable" kindref="compound">Variable</ref></computeroutput> interfaces throughout the model. </para>
        </briefdescription>
        <detaileddescription>
<para>Traverses the model investigating variable equivalences to set the appropriate interface type. If all equivalent variables have the correct interface type set then the method returns <computeroutput>true</computeroutput>. If the interface type of one or more equivalent variables cannot be set correctly then <computeroutput>false</computeroutput> is returned.</para>
<para>If the interface type for a variable cannot be set correctly, it is left unchanged.</para>
<para><simplesect kind="return"><para><computeroutput>true</computeroutput> if all the variable interfaces in the <computeroutput><ref refid="classlibcellml_1_1Model" kindref="compound">Model</ref></computeroutput> are correct and <computeroutput>false</computeroutput> otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="354" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1acacc6c471e0cde82b8406055a095a33e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libcellml::Model::clean</definition>
        <argsstring>()</argsstring>
        <name>clean</name>
        <qualifiedname>libcellml::Model::clean</qualifiedname>
        <briefdescription>
<para>Remove any empty components and units from the model. </para>
        </briefdescription>
        <detaileddescription>
<para>Remove any empty components and units fom this model. In this context, &quot;empty&quot; means:<itemizedlist>
<listitem><para>components with no name, identifier, resets, variables, maths, or non-empty child components; and</para>
</listitem><listitem><para>units which have no name, identifier, or child units. For components, this is applied recursively from the leaves of the encapsulation hierarchy. </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="365" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classlibcellml_1_1Model_1a4955c5e49a5500e33914564363705034" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::string &gt;</type>
        <definition>std::vector&lt; std::string &gt; libcellml::Model::importRequirements</definition>
        <argsstring>() const</argsstring>
        <name>importRequirements</name>
        <qualifiedname>libcellml::Model::importRequirements</qualifiedname>
        <briefdescription>
<para>Return all URLs used by imports in the model. </para>
        </briefdescription>
        <detaileddescription>
<para>Return a <computeroutput>std::vector</computeroutput> of <computeroutput>std::strings</computeroutput> representing all URLs used by imports in this model.</para>
<para><simplesect kind="return"><para>a <computeroutput>std::vector</computeroutput> of <computeroutput>std::strings</computeroutput>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libcellml/model.h" line="374" column="17"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>The <ref refid="classlibcellml_1_1Model" kindref="compound">Model</ref> class. </para>
    </briefdescription>
    <detaileddescription>
<para>The <ref refid="classlibcellml_1_1Model" kindref="compound">Model</ref> class is for representing a CellML <ref refid="classlibcellml_1_1Model" kindref="compound">Model</ref>. </para>
    </detaileddescription>
    <inheritancegraph>
      <node id="2">
        <label>libcellml::ComponentEntity</label>
        <link refid="classlibcellml_1_1ComponentEntity"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
      <node id="5">
        <label>libcellml::Entity</label>
        <link refid="classlibcellml_1_1Entity"/>
      </node>
      <node id="1">
        <label>libcellml::Model</label>
        <link refid="classlibcellml_1_1Model"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
        <childnode refid="6" relation="public-inheritance">
        </childnode>
      </node>
      <node id="3">
        <label>libcellml::NamedEntity</label>
        <link refid="classlibcellml_1_1NamedEntity"/>
        <childnode refid="4" relation="public-inheritance">
        </childnode>
      </node>
      <node id="4">
        <label>libcellml::ParentedEntity</label>
        <link refid="classlibcellml_1_1ParentedEntity"/>
        <childnode refid="5" relation="public-inheritance">
        </childnode>
      </node>
      <node id="6">
        <label>std::enable_shared_from_this&lt; Model &gt;</label>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="2">
        <label>libcellml::ComponentEntity</label>
        <link refid="classlibcellml_1_1ComponentEntity"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
      <node id="5">
        <label>libcellml::Entity</label>
        <link refid="classlibcellml_1_1Entity"/>
      </node>
      <node id="1">
        <label>libcellml::Model</label>
        <link refid="classlibcellml_1_1Model"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
        <childnode refid="6" relation="public-inheritance">
        </childnode>
      </node>
      <node id="3">
        <label>libcellml::NamedEntity</label>
        <link refid="classlibcellml_1_1NamedEntity"/>
        <childnode refid="4" relation="public-inheritance">
        </childnode>
      </node>
      <node id="4">
        <label>libcellml::ParentedEntity</label>
        <link refid="classlibcellml_1_1ParentedEntity"/>
        <childnode refid="5" relation="public-inheritance">
        </childnode>
      </node>
      <node id="6">
        <label>std::enable_shared_from_this&lt; Model &gt;</label>
      </node>
    </collaborationgraph>
    <location file="libcellml/model.h" line="36" column="1" bodyfile="libcellml/model.h" bodystart="41" bodyend="388"/>
    <listofallmembers>
      <member refid="classlibcellml_1_1ComponentEntity_1a67d368331ed3f0de22fad8e8ab130aed" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>addComponent</name></member>
      <member refid="classlibcellml_1_1Model_1a91c0c4df78d08ccade6ce6fab998f363" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>addUnits</name></member>
      <member refid="classlibcellml_1_1Model_1acacc6c471e0cde82b8406055a095a33e" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>clean</name></member>
      <member refid="classlibcellml_1_1Model_1a1844f4c3ab78c314bcfb0028c8522a59" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>clone</name></member>
      <member refid="classlibcellml_1_1ComponentEntity_1afdfd2155613501299efc923a2f507103" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>component</name></member>
      <member refid="classlibcellml_1_1ComponentEntity_1a692e7f572ff63264e8ca4ffeefb5dc2b" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>component</name></member>
      <member refid="classlibcellml_1_1ComponentEntity_1ae8aa01faf601faf5b6bd3bf2feca8414" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>componentCount</name></member>
      <member refid="classlibcellml_1_1ComponentEntity_1aad863d65f1a3c0774b4e9bdad07e4156" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>containsComponent</name></member>
      <member refid="classlibcellml_1_1ComponentEntity_1a68436a36a65a1ab77e160810f3ae6248" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>containsComponent</name></member>
      <member refid="classlibcellml_1_1Model_1a99f9deb9dfa4b3fbae57dc83ff6f25c2" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>create</name></member>
      <member refid="classlibcellml_1_1Model_1ac82c833a60900daec99671c16ae1af60" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>create</name></member>
      <member refid="classlibcellml_1_1Model_1a4ceb895e818175f55049274768d9c755" prot="private" virt="virtual"><scope>libcellml::Model</scope><name>doAddComponent</name></member>
      <member refid="classlibcellml_1_1Model_1ae8c294eaf48de567c51ca435f7d1ed12" prot="private" virt="virtual"><scope>libcellml::Model</scope><name>doEquals</name></member>
      <member refid="classlibcellml_1_1ComponentEntity_1ade4b563a5aaa366c6b48d91beaad8d3c" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>encapsulationId</name></member>
      <member refid="classlibcellml_1_1Entity_1aaf1f5a51be3e2fcc22113b2c2428967c" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>Entity</name></member>
      <member refid="classlibcellml_1_1Entity_1a5ccd682791b20cc0431cd3abe265f734" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>Entity</name></member>
      <member refid="classlibcellml_1_1Entity_1ae20d00ec2f8b44c6874ca43a46fb84a1" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>equals</name></member>
      <member refid="classlibcellml_1_1Model_1adff8d728f64996d5bb9d744e28efac1f" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>fixVariableInterfaces</name></member>
      <member refid="classlibcellml_1_1ParentedEntity_1abe6ca3f56655c2d1ea97d18712f78c22" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>hasAncestor</name></member>
      <member refid="classlibcellml_1_1Model_1ace2367c655c6fea24e6cafc04f3fa409" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>hasImports</name></member>
      <member refid="classlibcellml_1_1ParentedEntity_1a24d037686b4ccd86539a35c84c267813" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>hasParent</name></member>
      <member refid="classlibcellml_1_1Model_1acb6314e3b306b3100912c8f35440ef8d" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>hasUnits</name></member>
      <member refid="classlibcellml_1_1Model_1a54befdd09b177dd94b9f17ce851ceb56" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>hasUnits</name></member>
      <member refid="classlibcellml_1_1Model_1afeb644177e2e6a3ba506660319864470" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>hasUnlinkedUnits</name></member>
      <member refid="classlibcellml_1_1Model_1a4ca499826b7253eca79c865f6b8bf8bb" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>hasUnresolvedImports</name></member>
      <member refid="classlibcellml_1_1Entity_1a05439119b7eeab2fc61f8aa5a86eb092" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>id</name></member>
      <member refid="classlibcellml_1_1Model_1a4955c5e49a5500e33914564363705034" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>importRequirements</name></member>
      <member refid="classlibcellml_1_1Model_1a27fa60c2ea8043954f37a4cd7bcbcb39" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>isDefined</name></member>
      <member refid="classlibcellml_1_1Model_1a40de01d2effd4894738b6f3a4f5adbcd" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>linkUnits</name></member>
      <member refid="classlibcellml_1_1Model_1ad0d6354a3b1329897a5900beae9acba3" prot="private" virt="non-virtual"><scope>libcellml::Model</scope><name>Model</name></member>
      <member refid="classlibcellml_1_1Model_1a8130b562ed2687511f2eedfb00168039" prot="private" virt="non-virtual"><scope>libcellml::Model</scope><name>Model</name></member>
      <member refid="classlibcellml_1_1Model_1a9903959fe09e5ac980de27bc349ca2ce" prot="private" virt="non-virtual"><scope>libcellml::Model</scope><name>Model</name></member>
      <member refid="classlibcellml_1_1Model_1acb13f38228f2087d2894a6405653e3c4" prot="private" virt="non-virtual"><scope>libcellml::Model</scope><name>Model</name></member>
      <member refid="classlibcellml_1_1NamedEntity_1ab643dec674588048b4532c3f2819726a" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>name</name></member>
      <member refid="classlibcellml_1_1Model_1ab81a266901c8890fa237bfab6baf8da7" prot="private" virt="non-virtual"><scope>libcellml::Model</scope><name>operator=</name></member>
      <member refid="classlibcellml_1_1ParentedEntity_1ac662ca494335a944f845b1a432822292" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>parent</name></member>
      <member refid="classlibcellml_1_1Model_1aa46588744f9b78cb980a1bd41f62ac17" prot="private" virt="non-virtual"><scope>libcellml::Model</scope><name>pFunc</name></member>
      <member refid="classlibcellml_1_1Model_1a3df115a242c1cdd5e96cc37b03dc033a" prot="private" virt="non-virtual"><scope>libcellml::Model</scope><name>pFunc</name></member>
      <member refid="classlibcellml_1_1ComponentEntity_1ae9a8e5de907fc82c2448b80c70ab7d6b" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>removeAllComponents</name></member>
      <member refid="classlibcellml_1_1Model_1a259f6a31db54fa1940c4b220d8fc40d9" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>removeAllUnits</name></member>
      <member refid="classlibcellml_1_1ComponentEntity_1a072c8ccf3fb82e4a0ab7084bb37e02e4" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>removeComponent</name></member>
      <member refid="classlibcellml_1_1ComponentEntity_1afbe4e6e72d68c88fa909c08a90d68bdf" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>removeComponent</name></member>
      <member refid="classlibcellml_1_1ComponentEntity_1af7484b56f626f4c614cad982aa79cb2e" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>removeComponent</name></member>
      <member refid="classlibcellml_1_1ComponentEntity_1a141a0833ec28e1ccb12dc8f43cccf4e9" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>removeEncapsulationId</name></member>
      <member refid="classlibcellml_1_1Entity_1a959de09716024274913a396cf76b9076" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>removeId</name></member>
      <member refid="classlibcellml_1_1NamedEntity_1a8ce5fd989ac293855bba21067ce21ee9" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>removeName</name></member>
      <member refid="classlibcellml_1_1Model_1a525cf9d149d07d4cf98ca3c5cc6ac63e" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>removeUnits</name></member>
      <member refid="classlibcellml_1_1Model_1a9bdd0b2ead32d3afacb8662591637866" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>removeUnits</name></member>
      <member refid="classlibcellml_1_1Model_1a3109a4b45d445ddf80a792ce5331c130" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>removeUnits</name></member>
      <member refid="classlibcellml_1_1ComponentEntity_1a5e649954c33fdc72fff5fabdd193cde1" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>replaceComponent</name></member>
      <member refid="classlibcellml_1_1ComponentEntity_1a1f1ea90ed988b84c2b6e23acc92292ca" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>replaceComponent</name></member>
      <member refid="classlibcellml_1_1ComponentEntity_1a71b9bdf177ee99042505e32e8846dcdc" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>replaceComponent</name></member>
      <member refid="classlibcellml_1_1Model_1aa526cbea5a87fe41a4c602fd0c15e40c" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>replaceUnits</name></member>
      <member refid="classlibcellml_1_1Model_1ad94f8aadac6b93760bf1f9f8d2a7c81d" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>replaceUnits</name></member>
      <member refid="classlibcellml_1_1Model_1ac2e76f7fff925c6f6aa387ec7e0c1549" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>replaceUnits</name></member>
      <member refid="classlibcellml_1_1ComponentEntity_1a6e00f015eb45d96bfad052e53c4db280" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>setEncapsulationId</name></member>
      <member refid="classlibcellml_1_1Entity_1a13bdf688cdf007be5abad5dc628fd4ad" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>setId</name></member>
      <member refid="classlibcellml_1_1NamedEntity_1a2528924ae9b2a69d8ff3b5b9b6f31d88" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>setName</name></member>
      <member refid="classlibcellml_1_1ComponentEntity_1a4d18a854588a9b21eb1c5b861fdb6516" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>takeComponent</name></member>
      <member refid="classlibcellml_1_1ComponentEntity_1a1ea65bf35de168786aff5c94c7236ddc" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>takeComponent</name></member>
      <member refid="classlibcellml_1_1Model_1ac9d804868b33ab6e685fc9e4b41dc618" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>takeUnits</name></member>
      <member refid="classlibcellml_1_1Model_1a7609c3fba45ff860eff9fc989ae01f83" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>takeUnits</name></member>
      <member refid="classlibcellml_1_1Model_1aaa361f12facc6238fae768f0f7892181" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>units</name></member>
      <member refid="classlibcellml_1_1Model_1aa8ae761b6e496176a29e42a43d971922" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>units</name></member>
      <member refid="classlibcellml_1_1Model_1aba003d544dbecaddbf07ddda8344a457" prot="public" virt="non-virtual"><scope>libcellml::Model</scope><name>unitsCount</name></member>
      <member refid="classlibcellml_1_1Entity_1a5f2e6419f17f23f551bcd1ada87986b3" prot="public" virt="pure-virtual"><scope>libcellml::Model</scope><name>~Entity</name></member>
      <member refid="classlibcellml_1_1Model_1afacb342379c91cbdce35325f42404620" prot="private" virt="non-virtual"><scope>libcellml::Model</scope><name>~Model</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
