<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.18.1 -->
<document source="/Users/libcellml/BuildbotWorker/Finalise_Release_Builder/howto-tested-docs/edit_model.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/" xmlns:todo="https://www.sphinx-doc.org/">
    <target refid="edit-model"></target>
    <section ids="edit-items-in-a-model edit-model" names="edit\ items\ in\ a\ model edit_model">
        <title>Edit items in a model</title>
        <paragraph>All CellML entities exist in an hierarchical structure as shown below.
            In some circumstances additional links are made between items (equivalent variables, for example), but on the whole it follows a basic tree structure.</paragraph>
        <paragraph>Within the structure each item has two parts:</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph>A set of <emphasis>attributes</emphasis> specific to itself.
                    Some of these attribute exist for many items (for example, the <literal classes="code" language="">name</literal> attribute), and others are specific to the item type (for example, the <literal classes="code" language="">initialValue</literal> attribute on a <literal classes="code" language="">Variable</literal> item).</paragraph>
            </list_item>
            <list_item>
                <paragraph>A set of <emphasis>collections</emphasis> which this - the parent item - curates.
                    For example, the collection of <literal classes="code" language="">Variable</literal> items owned by a parent <literal classes="code" language="">Component</literal>.</paragraph>
            </list_item>
        </bullet_list>
        <topic classes="contents local" ids="contents" names="contents">
            <bullet_list>
                <list_item>
                    <paragraph><reference ids="id1" refid="editing-attributes">Editing attributes</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id2" refid="editing-collections">Editing collections</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id3" refid="editing-variable-equivalences">Editing variable equivalences</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id4" refid="editing-an-encapsulation-hierarchy">Editing an encapsulation hierarchy</reference></paragraph>
                </list_item>
            </bullet_list>
        </topic>
        <section ids="editing-attributes" names="editing\ attributes">
            <title refid="id1">Editing attributes</title>
            <paragraph>For any item type, each attribute <literal classes="code" language="">xyz</literal> may be edited using the general <literal classes="code" language="">setXyz</literal> function, whose arguments vary depending on the attribute.
                Note that this is distinct from editing collections of items, which is discussed below.</paragraph>
            <paragraph>Some example snippets are shown below:</paragraph>
            <paragraph><strong>TODO</strong></paragraph>
            <target refid="snippet-edit-mathml"></target>
            <container classes="toggle" ids="snippet-edit-mathml" names="snippet_edit_mathml">
                <container classes="header-left">
                    <paragraph>Edit MathML in a component</paragraph>
                </container>
                <paragraph>MathML is stored as a single string within a component.
                    Retrieving it is simple enough using the <literal classes="code" language="">math()</literal> function, but any manipulation (change units used, changing variable names, adding additional relationships, etc) are a little more complicated.</paragraph>
                <comment xml:space="preserve"></comment>
                <block_quote>
                    <paragraph>TODO: Need more examples of useful mathml manipulation. Variable names? Need to remove whitespace first?</paragraph>
                </block_quote>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" classes="closeable" role="tablist">
                        <button aria-controls="panel-0-Qysr" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-Qysr" name="Qysr" role="tab" tabindex="0">C++</button>
                        <button aria-controls="panel-0-UHl0aG9u" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-UHl0aG9u" name="UHl0aG9u" role="tab" tabindex="-1">Python</button>
                    </div>
                    <div aria-labelledby="tab-0-Qysr" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-Qysr" name="Qysr" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="c++" linenos="False" xml:space="preserve">void switchUnitsInMaths(std::string &amp;maths, std::string in, std::string out)
{
    //  Note that this function will replace any and all occurrences of the "in"
    //  string within the "maths" string with the "out" string.  It's worth noting that
    //  in order to be sure that only full name matches for units are replaced, we exploit
    //  the fact that the units names in the MathML string will be in quotation marks, and include
    //  these quotation marks on either side of the in and out strings for safety.

    std::string::size_type n = 0;
    std::string in_with_quotes = "\"" + in + "\"";
    std::string out_with_quotes = "\"" + out + "\"";

    while ((n = maths.find(in_with_quotes, n)) != std::string::npos) {
        maths.replace(n, in_with_quotes.size(), out_with_quotes);
        n += out_with_quotes.size();
    }

    std::cout &lt;&lt; "Switched units '" &lt;&lt; in &lt;&lt; "' for units '" &lt;&lt; out &lt;&lt; "'" &lt;&lt; std::endl;
}</literal_block>
                    </div>
                    <div aria-labelledby="tab-0-UHl0aG9u" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-UHl0aG9u" name="UHl0aG9u" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="py" linenos="False" xml:space="preserve">def switch_units_in_maths(maths, units_in, units_out):
#   Note that this function will replace any and all occurrences of the "units_in"
#   string within the "maths" string with the "units_out" string.  It's worth noting that
#   in order to be sure that only full name matches for units are replaced, we exploit
#   the fact that the units names in the MathML string will be in quotation marks, and include
#   these quotation marks on either side of the in and out strings for safety.

in_with_quotes = "\"" + units_in + "\""
out_with_quotes = "\"" + units_out + "\""

new_maths = maths.replace(in_with_quotes, out_with_quotes)

return new_maths</literal_block>
                    </div>
                </container>
            </container>
        </section>
        <section ids="editing-collections" names="editing\ collections">
            <title refid="id2">Editing collections</title>
            <paragraph>General families of functions are available for editing collections, but take the form of <literal classes="code" language="">addXyz</literal> and <literal classes="code" language="">removeXyz</literal>, <literal classes="code" language="">takeXyz</literal> and <literal classes="code" language="">replaceXyz</literal>, as explained in <reference internal="False" refuri="/documentation/v0.5.0/aside/understanding_collections">Understanding collections</reference>.</paragraph>
            <paragraph>Some example snippets are shown below:</paragraph>
            <target refid="snippet-add-thing"></target>
            <container classes="toggle" ids="snippet-add-thing" names="snippet_add_thing">
                <container classes="header-left">
                    <paragraph>Add a thing to a collection</paragraph>
                </container>
                <paragraph>When you add an item to a collection, you also set its parent.
                    Effectively, adding an item which is already a member of one collection to another collection actually <emphasis>moves</emphasis> it from the first to the second.
                    This means that:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>the item’s parent will be the second collection parent;</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>the first collection will not contain the item any more; and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>the second collection will contain the item.</paragraph>
                    </list_item>
                </bullet_list>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" classes="closeable" role="tablist">
                        <button aria-controls="panel-1-1-0" aria-selected="true" classes="sphinx-tabs-tab" ids="tab-1-1-0" name="1-0" role="tab" tabindex="0">C++</button>
                        <button aria-controls="panel-1-1-1" aria-selected="false" classes="sphinx-tabs-tab" ids="tab-1-1-1" name="1-1" role="tab" tabindex="-1">Python</button>
                    </div>
                    <div aria-labelledby="tab-1-1-0" classes="sphinx-tabs-panel" ids="panel-1-1-0" name="1-0" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/libcellml/BuildbotWorker/Finalise_Release_Builder/howto-tested-docs/resources/code/add_things/addThings.cpp" xml:space="preserve">
#include &lt;iostream&gt;
#include &lt;libcellml&gt;

int main()
{
    // Create a variable and a component.
    auto myVariable = libcellml::Variable::create("myVariableName");
    auto myComponent = libcellml::Component::create("myComponentName");
    bool success = false;

    // Before adding, the variable has no parent, and the component has no
    // variables.
    // Add the variable myVariable to component myComponent.
    success = myComponent-&gt;addVariable(myVariable);

    // At this point, if the operation was successful, the variable
    // myVariable has a parent of myComponent, and exists in the collection
    // of variables.  If successful:
    //  - success = true
    //  - myComponent-&gt;variableCount() = 1
    //  - myVariable-&gt;parent() = myComponent
    //  - myComponent-&gt;variable(0) = myVariable.
    
    // Now see what happens if that same variable is added to another
    // Component item, myOtherComponent, which is initially empty.
    auto myOtherComponent = libcellml::Component::create("myOtherComponentName");
    success = myOtherComponent-&gt;addVariable(myVariable);

    // If successful, the variable will have been moved to the new component, and
    // removed from the old one, thus:
    // - success = true
    // - myOtherComponent-&gt;variableCount() = 1
    // - myOtherComponent-&gt;variable(0) = myVariable
    // - myVariable-&gt;parent() = myOtherComponent
    // - myComponent-&gt;variableCount() == 0.
    std::cout &lt;&lt; "hello world!"&lt;&lt;std::endl;
}
</literal_block>
                    </div>
                    <div aria-labelledby="tab-1-1-1" classes="sphinx-tabs-panel" hidden="true" ids="panel-1-1-1" name="1-1" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/libcellml/BuildbotWorker/Finalise_Release_Builder/howto-tested-docs/resources/code/add_things/addThings.py" xml:space="preserve">from libcellml import Component, Variable

if __name__ == '__main__':

    # Create a variable and a component.
    my_variable = Variable()
    my_variable.setName("myVariable")
    my_component = Component()
    my_component.setName("myComponent")
    success = False

    # Before adding, the variable has no parent, and the component has no
    # variables.
    assert(my_component.variableCount() == 0)
    assert(my_variable.parent() == None)

    # Add the variable my_variable to component my_variable.
    success = my_component.addVariable(my_variable)

    # At this point, if the operation was successful, the variable
    # my_variable has a parent of my_component, and exists in the collection
    # of variables.  The component's variable count has been updated too.
    assert(success == true)
    assert(my_component.variableCount() == 1)
    assert(my_variable.parent() == my_component)
    assert(my_component.variable(0) == my_variable)

    # Now see what happens if that same variable is added to another
    # component, my_other_component, which is initially empty.
    my_other_component = Component()
    my_other_component.setName('myOtherComponent')
    assert(my_other_component.variableCount() == 0)

    success = my_other_component.addVariable(my_variable)

    # If successful, the variable will have been moved to the new component, and
    # removed from the old one.
    assert(success == true)
    assert(my_other_component.variableCount() == 1)
    assert(my_other_component.variable(0) == my_variable)
    assert(my_variable.parent() == my_other_component)
    assert(my_component.variableCount() == 0)
</literal_block>
                    </div>
                </container>
            </container>
            <target refid="snippet-remove-thing"></target>
            <container classes="toggle" ids="snippet-remove-thing" names="snippet_remove_thing">
                <container classes="header-left">
                    <paragraph>Remove a thing from a collection</paragraph>
                </container>
                <paragraph>This example demonstrates the addition and removal of items from a collection.
                    Note that while removal of items from a collection can be done by pointer symbol, by name, and by index, adding them is only possible via pointer.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" classes="closeable" role="tablist">
                        <button aria-controls="panel-2-Qysr" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-Qysr" name="Qysr" role="tab" tabindex="0">C++</button>
                        <button aria-controls="panel-2-UHl0aG9u" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-UHl0aG9u" name="UHl0aG9u" role="tab" tabindex="-1">Python</button>
                    </div>
                    <div aria-labelledby="tab-2-Qysr" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-Qysr" name="Qysr" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="c++" linenos="False" xml:space="preserve">// Setup. Create four variables and a component.
auto variable1 = libcellml::Variable::create("variable1");
auto variable2 = libcellml::Variable::create("variable2");
auto variable3 = libcellml::Variable::create("variable3");
auto variable4 = libcellml::Variable::create("variable4");
auto component = libcellml::Component::create("component");

// Add variable1 into the component.  Note that the argument is
// the symbol, not the name. Expect success to be true.
auto success = component-&gt;addVariable(variable1);
assert(success);

// Repeat for the others.
success = component-&gt;addVariable(variable2);
success = component-&gt;addVariable(variable3);
success = component-&gt;addVariable(variable4);

// Remove variable2 from the component by pointer.
success = component-&gt;removeVariable(variable2);
assert(success);

// Remove variable3 from the component by name.
success = component-&gt;removeVariable("variable3");
assert(success == true);

// Remove variable4 from the component by index.
success = component-&gt;removeVariable(1);
assert(success == true);

// Operations that will not succeed include:
//  - Adding a variable more than once to the same component.
success = component-&gt;addVariable(variable1);
assert(success == false);

//  - Removing a variable that doesn't exist in that component.
success = component-&gt;removeVariable(variable2);
assert(success == false);

//  - Removing a variable by name that doesn't exist.
success = component-&gt;removeVariable("iDontExist");
assert(success == false);

//  - Removing a variable by out-of-range index.
success = component-&gt;removeVariable(9999);
assert(success == false);

//  - Adding a null pointer.
success = component-&gt;addVariable(nullptr);
assert(success == false);

//  - Removing a null pointer.
success = component-&gt;removeVariable(nullptr);
assert(success == false);</literal_block>
                    </div>
                    <div aria-labelledby="tab-2-UHl0aG9u" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-UHl0aG9u" name="UHl0aG9u" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="py" linenos="False" xml:space="preserve"># TODO</literal_block>
                    </div>
                </container>
            </container>
            <target refid="snippet-take-thing"></target>
            <container classes="toggle" ids="snippet-take-thing" names="snippet_take_thing">
                <container classes="header-left">
                    <paragraph>Take a thing from a collection</paragraph>
                </container>
            </container>
            <target refid="snippet-replace-thing"></target>
            <container classes="toggle" ids="snippet-replace-thing" names="snippet_replace_thing">
                <container classes="header-left">
                    <paragraph>Replace a thing within a collection</paragraph>
                </container>
            </container>
        </section>
        <section ids="editing-variable-equivalences" names="editing\ variable\ equivalences">
            <title refid="id3">Editing variable equivalences</title>
            <paragraph>In the situation of equivalent variable collections there is no clear “ownership” of the equivalence as an attribute of any one variable, and neither is there a central parent item with curation ability over the set of variables.
                A different approach is required.</paragraph>
            <paragraph>Adding and removing variable equivalence is accomplished using the <literal classes="code" language="">addEquivalence</literal> and <literal classes="code" language="">removeEquivalence</literal> functions as shown below.
                These functions take arguments of the variable pointers to connect or dissociate, and return a boolean value indicating whether the operation was successful.
                The success of the <literal classes="code" language="">addEquivalence</literal> function depends on:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>the variable pointers being non-null;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>the two variables having parent components;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>there being no previously existing connection between the two variables already.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Creating a <emphasis>valid</emphasis> connection also depends on the two variables having compatible units, appropriate interface types, and being in components which are accessible to one another (parent-child or sibling relationship).</paragraph>
            <paragraph>The success of the <literal classes="code" language="">removeEquivalence</literal> function depends on:</paragraph>
            <block_quote>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>the variable pointer arguments being non-null; and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>there being an existing connection between the two variables.</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
            <paragraph>Note that the <literal classes="code" language="">removeEquivalence</literal> function will only remove an equivalence which was previously set using the <literal classes="code" language="">addEquivalence</literal> function; it does not remove any indirect connections via third-party variables between the two.</paragraph>
            <paragraph>An additional <literal classes="code" language="">removeAllEquivalences</literal> function will completely remove the variable from any connected set.</paragraph>
            <paragraph>Please see the <reference internal="False" refuri="/documentation/v0.5.0/api/classlibcellml_1_1Variable">API Variable</reference> page for details of these functions.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" classes="closeable" role="tablist">
                    <button aria-controls="panel-3-Qysr" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-Qysr" name="Qysr" role="tab" tabindex="0">C++</button>
                    <button aria-controls="panel-3-UHl0aG9u" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-UHl0aG9u" name="UHl0aG9u" role="tab" tabindex="-1">Python</button>
                </div>
                <div aria-labelledby="tab-3-Qysr" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-Qysr" name="Qysr" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="c++" linenos="False" xml:space="preserve">// Assuming that variables A and B are in different components, and that those components are
// available for connection with one another (parent-child, or sibling relationship).

// Add variables A and B to the same equivalent variable set.
auto isAconnectedToB = libcellml::Variable::addEquivalence(A, B);

// Remove a pre-existing equivalence between variables C and D.
auto isCdisconnectedFromD = libcellml::Variable::removeEquivalence(C, D);</literal_block>
                </div>
                <div aria-labelledby="tab-3-UHl0aG9u" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-UHl0aG9u" name="UHl0aG9u" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="py" linenos="False" xml:space="preserve"># Assuming that variables A and B are in different components, and that those components are
# available for connection with one another (parent-child, or sibling relationship).

# Add variables A and B to the same equivalent variable set.
isAconnectedToB = Variable.addEquivalence(A, B)

# Remove a pre-existing equivalence between variables C and D.
isCdisconnectedFromD = Variable.removeEquivalence(C, D)</literal_block>
                </div>
            </container>
            <paragraph>There are some gotchas to be explained.
                A variable can belong to only one set of equivalent variables; by having more than one equivalent variable, the variable itself merges the two sets of variables into one.
                Consider this example.
                Variable <literal classes="code" language="">fruit</literal> is equivalent to variables <literal classes="code" language="">apple</literal>, <literal classes="code" language="">pear</literal>, and <literal classes="code" language="">peach</literal>.
                Another variable <literal classes="code" language="">vegetable</literal> is equivalent to variables <literal classes="code" language="">tomato</literal>, <literal classes="code" language="">celery</literal>, and <literal classes="code" language="">spinach</literal>.
                At this time, there are two sets of equivalent variables: all of the fruit are equivalent to one another, and all of the vegetables are equivalent to one another.
                Adding a variable <literal classes="code" language="">produce</literal> with an equivalence to <literal classes="code" language="">fruit</literal> and to <literal classes="code" language="">vegetable</literal> effectively merges the two sets, so that now the variable <literal classes="code" language="">peach</literal> is equivalent to <literal classes="code" language="">spinach</literal>.</paragraph>
        </section>
        <section ids="editing-an-encapsulation-hierarchy" names="editing\ an\ encapsulation\ hierarchy">
            <title refid="id4">Editing an encapsulation hierarchy</title>
            <paragraph>Components may be added to a model or another component to create an encapsulation hierarchy, but there are a few things to watch out for in this situation.
                Components must belong to only one parent, so when adding a component from one location in the encapsulation to another, it is removed from the original parent.</paragraph>
            <paragraph>This is shown in the code snippet below.</paragraph>
            <target refid="snippet-edit-encapsulation1"></target>
            <container classes="toggle" ids="snippet-edit-encapsulation1" names="snippet_edit_encapsulation1">
                <container classes="header-left">
                    <paragraph>Edit encapsulation structure of a model</paragraph>
                </container>
                <paragraph>This example shows how the component <literal classes="code" language="">tomatoes</literal> which was orininally a child of the <literal classes="code" language="">vegetables</literal> component, could be moved to become a child of the <literal classes="code" language="">fruit</literal> component instead.
                    When run, this snippet will give the output:</paragraph>
                <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">Model 'quickstart_editEncapsulation' has 2 components
  - Component 'fruit' has 0 child components
  - Component 'vegetables' has 1 child components
      - Component 'tomatoes' has 0 child components

Model 'quickstart_editEncapsulation' has 2 components
  - Component 'fruit' has 1 child components
      - Component 'tomatoes' has 0 child components
  - Component 'vegetables' has 0 child components</literal_block>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" classes="closeable" role="tablist">
                        <button aria-controls="panel-4-Qysr" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-Qysr" name="Qysr" role="tab" tabindex="0">C++</button>
                        <button aria-controls="panel-4-UHl0aG9u" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-UHl0aG9u" name="UHl0aG9u" role="tab" tabindex="-1">Python</button>
                    </div>
                    <div aria-labelledby="tab-4-Qysr" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-Qysr" name="Qysr" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="c++" linenos="False" xml:space="preserve">#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;libcellml&gt;
#include "../../utilities/utilities.h"

int main()
{
    // Parse example model and component from the file provided.
    std::string inFileName = "/resources/quickstart_editEncapsulation1.cellml";
    std::ifstream inFile(inFileName);
    std::stringstream inFileContents;
    inFileContents &lt;&lt; inFile.rdbuf();
    auto parser = libcellml::Parser::create();
    auto model = parser-&gt;parseModel(inFileContents.str());

    printEncapsulationStructureToTerminal(model);

    auto fruit = model-&gt;component("fruit");
    auto veges = model-&gt;component("vegetables");

    // The tomatoes component starts off as a child of the vegetables component.
    auto tomatoes = veges-&gt;component("tomatoes");

    // Move the tomatoes into its correct fruit component, and check the return boolean is true.
    auto success = fruit-&gt;addComponent(tomatoes);
    assert(success);

    printEncapsulationStructureToTerminal(model);
}</literal_block>
                    </div>
                    <div aria-labelledby="tab-4-UHl0aG9u" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-UHl0aG9u" name="UHl0aG9u" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="py" linenos="False" xml:space="preserve">from libcellml import Parser
from utilities import print_encapsulation_structure_to_terminal

if __name__ == "__main__":

    read_file = open("/resources/quickstart_editEncapsulation.cellml", "r")

    #  Create a parser and read the file.
    parser = Parser()
    model = parser.parseModel(read_file.read())

    # Print the current encapsulation structure to the terminal.
    print_encapsulation_structure_to_terminal(model)

    # Retrieve the components.  Note that the "tomatoes" component starts
    # out as a child of the "vegetables" component.
    vegetables = model.component("vegetables")
    fruit = model.component("fruit")
    tomatoes = model.component("tomatoes")

    # Move the "tomatoes" component into "fruit".
    success = fruit.addComponent(tomatoes)

    # Print the structure and check that the components have
    # been transferred as expected.
    print_encapsulation_structure_to_terminal(model)</literal_block>
                    </div>
                </container>
            </container>
        </section>
    </section>
</document>
