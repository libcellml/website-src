<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.16 -->
<document source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial5/index.rst">
    <target refid="tutorial5"></target>
    <section ids="tutorial-5-annotation-tools tutorial5" names="tutorial\ 5:\ annotation\ tools tutorial5">
        <title>Tutorial 5: Annotation tools</title>
        <container classes="shortlist">
            <paragraph>By the time you have worked through this tutorial you will be able to:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Parse a CellML file into a <literal classes="code">Model</literal> instance;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Determine the type of item which has a given id;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Use the <literal classes="code">Annotator</literal> class to retrieve an item using only its id string;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Repair duplicated id strings within the model scope; and</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Automatically generate and assign unique ids to any or all items.</paragraph>
                </list_item>
            </bullet_list>
        </container>
        <section ids="requirements" names="requirements">
            <title>Requirements</title>
            <paragraph>Either <download_reference filename="5ee4d9af033f0d7f8198f849bafc9eff/tutorial5.zip" refdoc="tutorials/tutorial5/index" refdomain="" refexplicit="True" reftarget="tutorial5.zip" reftype="download" refwarn="False"><literal classes="xref download">download the entire folder</literal></download_reference>, or:</paragraph>
            <container classes="shortlist">
                <paragraph><strong>C++</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><download_reference filename="057635575b2058339905f75ff72f7110/CMakeLists.txt" refdoc="tutorials/tutorial5/index" refdomain="" refexplicit="True" reftarget="CMakeLists.txt" reftype="download" refwarn="False"><literal classes="xref download">CMakeLists.txt</literal></download_reference> The CMake file for building this tutorial;</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><download_reference filename="3223135133ae1959376c2b856a5c8377/tutorial5.cpp" refdoc="tutorials/tutorial5/index" refdomain="" refexplicit="True" reftarget="tutorial5.cpp" reftype="download" refwarn="False"><literal classes="xref download">tutorial5.cpp</literal></download_reference> Either the skeleton code, or ..</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><download_reference filename="0c32b071ea388d0a033b75113afbfd29/tutorial5_complete.cpp" refdoc="tutorials/tutorial5/index" refdomain="" refexplicit="True" reftarget="tutorial5_complete.cpp" reftype="download" refwarn="False"><literal classes="xref download">tutorial5_complete.cpp</literal></download_reference> the completed tutorial code; and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><download_reference filename="d50ec56da0e2a161a76c0aed4333cfd5/utilities.h" refdoc="tutorials/tutorial5/index" refdomain="" refexplicit="True" reftarget="../utilities/utilities.h" reftype="download" refwarn="False"><literal classes="xref download">utilities.h</literal></download_reference> and <download_reference filename="684243b84006978324fadad7984e1ab2/utilities.cpp" refdoc="tutorials/tutorial5/index" refdomain="" refexplicit="True" reftarget="../utilities/utilities.cpp" reftype="download" refwarn="False"><literal classes="xref download">utilities.cpp</literal></download_reference> Utility functions for use in the tutorials.</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="shortlist">
                <paragraph><strong>Python</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><download_reference filename="8bbb158ade27efed48c2b55ccd020566/tutorial5.py" refdoc="tutorials/tutorial5/index" refdomain="" refexplicit="True" reftarget="tutorial5.py" reftype="download" refwarn="False"><literal classes="xref download">tutorial5.py</literal></download_reference> Either the skeleton code, or ..</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><download_reference filename="5853ba7aa7873565335d6d1551bca52e/tutorial5_complete.py" refdoc="tutorials/tutorial5/index" refdomain="" refexplicit="True" reftarget="tutorial5_complete.py" reftype="download" refwarn="False"><literal classes="xref download">tutorial5_complete.py</literal></download_reference> the completed tutorial code; and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><download_reference filename="c1858a9098693f84499aba8a82e4574f/utilities.py" refdoc="tutorials/tutorial5/index" refdomain="" refexplicit="True" reftarget="../utilities/utilities.py" reftype="download" refwarn="False"><literal classes="xref download">utilities.py</literal></download_reference>  Utility functions for use in the tutorials.</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="shortlist">
                <paragraph><strong>Resources</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><download_reference filename="0f17082df03d9b4455cc9157368aa18d/MysteryModel.cellml" refdoc="tutorials/tutorial5/index" refdomain="" refexplicit="True" reftarget="MysteryModel.cellml" reftype="download" refwarn="False"><literal classes="xref download">MysteryModel.cellml</literal></download_reference> file to read; and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><download_reference filename="f93aae7f16420e85ea709daab10833bb/AnotherMysteryModel.cellml" refdoc="tutorials/tutorial5/index" refdomain="" refexplicit="True" reftarget="AnotherMysteryModel.cellml" reftype="download" refwarn="False"><literal classes="xref download">AnotherMysteryModel.cellml</literal></download_reference> its import dependency.</paragraph>
                    </list_item>
                </bullet_list>
            </container>
        </section>
        <section ids="background" names="background">
            <title>Background</title>
            <paragraph>“Marco Polo” is a game played with many people in a swimming pool.
                One person calls “Marco” with their eyes closed.
                Others answer “Polo” and the first person must find them by following the sound.
                In this tutorial you are given id strings and a mystery CellML model file.
                We will work through how the <literal classes="code">Annotator</literal> class can be used to locate the desired objects.</paragraph>
        </section>
        <section ids="step-1-parse-the-mystery-model" names="step\ 1:\ parse\ the\ mystery\ model">
            <title>Step 1: Parse the mystery model</title>
            <container classes="dothis">
                <paragraph><strong>1.a</strong> Read the file “MysteryModel.cellml” into a string.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>1.b</strong> Create a <literal classes="code">Parser</literal> item.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>1.c</strong> Use the parser to deserialise the contents of the string you’ve read and return the model.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>1.d</strong> Check that the parser has not raised any issues.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial5/tutorial5_complete.cpp" xml:space="preserve">    //  1.a 
    //      Read the mystery file, MysteryModel.cellml.
    std::ifstream inFile("MysteryModel.cellml");
    std::stringstream inFileContents;
    inFileContents &lt;&lt; inFile.rdbuf();

    //  1.b 
    //      Create a Parser item.
    auto parser = libcellml::Parser::create();

    //  1.c 
    //      Use the parser to deserialise the contents of the string you've read
    //      and return the model.
    auto model = parser-&gt;parseModel(inFileContents.str());

    //  1.d 
    //      Check that the parser has not raised any issues.
    printIssues(parser);

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial5/tutorial5_complete.py" xml:space="preserve">    #  1.a 
    #      Read the mystery file, MysteryModel.cellml.
    read_file = open("MysteryModel.cellml")

    #  1.b 
    #      Create a Parser item.
    parser = Parser()

    #  1.c 
    #      Use the parser to deserialise the contents of the string you've read
    #      and return the model.
    model = parser.parseModel(read_file.read())

    #  1.d 
    #      Check that the parser has not raised any issues.
    print_issues(parser)

</literal_block>
            </container>
        </section>
        <section ids="step-2-retrieve-an-item-with-a-unique-id" names="step\ 2:\ retrieve\ an\ item\ with\ a\ unique\ id">
            <title>Step 2: Retrieve an item with a unique id</title>
            <container classes="useful">
                <paragraph><reference internal="False" refuri="https://libcellml.github.io/help/api/v0.2.0/classlibcellml_1_1Annotator">Annotator class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>create</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>setModel</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>item</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>issueCount</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>issue</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Tutorial functions</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>C++: getCellmlElementTypeFromEnum will return a string version of the CellmlElementType enumeration</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Python: get_cellml_element_type_from_enum</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.a</strong> Create an <literal classes="code">Annotator</literal> item and use its <literal classes="code">setModel</literal> function to pass in the parsed mystery model.</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>In C++: The <literal classes="code">item</literal> function returns a <literal classes="code">libcellml::AnyItem</literal>, a <literal classes="code">std::pair</literal> whose first attribute is a <literal classes="code">libcellml::CellmlElementType</literal> enumeration; and second attribute is a <literal classes="code">std::any</literal> cast of the item itself.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>In Python: The <literal classes="code">item</literal> function returns a tuple.
                            The first item is a <literal classes="code">CellmlElementType</literal> enumeration, the second is the item itself.</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial5/tutorial5_complete.cpp" xml:space="preserve">    //  2.a
    //      Create an Annotator item and use the setModel function to pass in the parsed
    //      mystery model.
    auto annotator = libcellml::Annotator::create();
    annotator-&gt;setModel(model);

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial5/tutorial5_complete.py" xml:space="preserve">    #  2.a
    #      Create an Annotator item and use the setModel function to pass in the parsed
    #      mystery model.
    annotator = Annotator()
    annotator.setModel(model)

</literal_block>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.b</strong> Retrieve the item with an id of “marco”.
                    Use the helper function to convert the enumeration of its type into a string, and print to the terminal.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">The item with ID 'marco' is a VARIABLE</literal_block>
            <container classes="dothis">
                <paragraph><strong>2.c</strong> Check that the annotator has not reported any issues.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.d</strong> (C++ only) Cast the second attribute of the macro item into a libcellml::VariablePtr item using <literal classes="code">std::any_cast</literal>.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial5/tutorial5_complete.cpp" xml:space="preserve">    //  2.b
    //      Retrieve the item with an id of "marco".  Use the helper function
    //      getCellmlElementTypeFromEnum to convert the enumeration of its type into a
    //      string for printing to the terminal.
    libcellml::AnyItem marcoItem = annotator-&gt;item("marco");
    std::cout &lt;&lt; "The item with ID 'marco' is a " &lt;&lt; getCellmlElementTypeFromEnum(marcoItem.first) &lt;&lt; std::endl;

    //  2.c
    //      Check that the annotator has not reported any issues.
    printIssues(annotator);

    //  2.d
    //      Now that we know the marco item's type using its first attribute (it should
    //      be a libcellml::CellmlElementType::VARIABLE) we can cast it into a usable item
    //      using std::any_cast.  Cast the second attribute of the macro item into a
    //      libcellml::VariablePtr item.
    auto marcoVariable = std::any_cast&lt;libcellml::VariablePtr&gt;(marcoItem.second);

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial5/tutorial5_complete.py" xml:space="preserve">    #  2.b
    #      Retrieve the item with an id of 'marco'.  Use the helper function
    #      get_cellml_element_type_from_enum to convert the enumeration of its type into a
    #      string for printing to the terminal.
    marco_item = annotator.item('marco')
    print('The item with ID "marco" is a {}'.format(get_cellml_element_type_from_enum(marco_item[0])))

    # The item with ID 'marco' is a VARIABLE

    #  2.c
    #      Check that the annotator has not reported any issues.
    print_issues(annotator)

    #  2.d
    #      Now that we know the marco item's type using its first attribute (it should
    #      be a CellmlElementType.VARIABLE) we can name its second attribute so we know
    #      what it is.
    marco_variable = marco_item[1]

</literal_block>
            </container>
        </section>
        <section ids="step-3-retrieve-items-whose-id-are-not-unique" names="step\ 3:\ retrieve\ items\ whose\ id\ are\ not\ unique">
            <title>Step 3: Retrieve items whose id are not unique</title>
            <container classes="useful">
                <paragraph><reference internal="False" refuri="https://libcellml.github.io/help/api/v0.2.0/classlibcellml_1_1Annotator">Annotator class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>items</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>isUnique</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>assignId</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.a</strong> Now try the same procedure to find the item with id of “polo”.
                    Retrieve the item and print its type to the terminal.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">The type of item with ID "polo" is UNDEFINED</literal_block>
            <container classes="dothis">
                <paragraph><strong>3.b</strong> The item type returned is <literal classes="code">UNDEFINED</literal> … so we need to check what the annotator has to say about it.
                    Retrieve the issues from the annotator and print them to the terminal.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial5/tutorial5_complete.cpp" xml:space="preserve">    //  3.a
    //      Now try the same procedure to find the item with id of "polo".
    //      Retrieve the item and print its type to the terminal.
    auto poloItem = annotator-&gt;item("polo");
    std::cout &lt;&lt; "The type of item with ID 'polo' is " &lt;&lt; getCellmlElementTypeFromEnum(poloItem.first) &lt;&lt; std::endl;

    //  3.b
    //      The item type returned is libcellml::CellmlElementType::UNDEFINED ... so we 
    //      need to check what the annotator has to say about it. 
    //      Retrieve the issues from the annotator and print to the terminal.
    printIssues(annotator);

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial5/tutorial5_complete.py" xml:space="preserve">    #  3.a
    #      Now try the same procedure to find the item with id of 'polo'.
    #      Retrieve the item and print its type to the terminal.
    polo_item = annotator.item('polo')
    print('The type of item with ID "polo" is {}'.format(get_cellml_element_type_from_enum(polo_item[0])))

    #  3.b
    #      The item type returned is CellmlElementType.UNDEFINED ... so we 
    #      need to check what the annotator has to say about it. 
    #      Retrieve the issues from the annotator and print to the terminal.
    print_issues(annotator)

</literal_block>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">Recorded 1 issues:
Issue [0] is a WARNING:
    description: The id 'polo' occurs 6 times in the model so a unique item cannot be located.
    stored item type: UNDEFINED</literal_block>
            <container classes="dothis">
                <paragraph><strong>3.c</strong> Since the id is not unique, we need to retrieve all items with that id for investigation.
                    Use the <literal classes="code">items</literal> function to retrieve the vector of items with id “polo”, and iterate through it printing the different types to the terminal.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial5/tutorial5_complete.cpp" xml:space="preserve">    //  3.c
    //      Use the items function to retrieve the vector of items with id "polo", 
    //      and iterate through it printing the different types to the terminal.
    auto poloItems = annotator-&gt;items("polo");
    std::cout &lt;&lt; "The items with an id of 'polo' have types of:" &lt;&lt; std::endl;
    size_t index = 0;
    for (auto &amp;item : poloItems) {
        std::cout &lt;&lt; "  - [" &lt;&lt; index &lt;&lt; "] " &lt;&lt; getCellmlElementTypeFromEnum(item.first) &lt;&lt; std::endl;
        ++index; 
    }

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial5/tutorial5_complete.py" xml:space="preserve">    #  3.c
    #      Use the items function to retrieve the vector of items with id 'polo', 
    #      and iterate through it printing the different types to the terminal.
    polo_items = annotator.items('polo')
    print('The items with an id of "polo" have types of:')
    index = 0
    for item in polo_items:
        print('  - [{}] {}'.format(index, get_cellml_element_type_from_enum(item[0])))
        index += 1

</literal_block>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">The items with an id of 'polo' have types of:
  - [0] UNITS
  - [1] UNITS
  - [2] UNIT
  - [3] VARIABLE
  - [4] RESET
  - [5] RESET_VALUE</literal_block>
            <paragraph>The item we want has type <literal classes="code">UNIT</literal>, and we’d like it to be unique so that we can annotate it properly.
                We need to change the other items to have other (also unique) ids.
                The <literal classes="code">Annotator</literal> class can create a unique id for an item using the <literal classes="code">assignId</literal> function.</paragraph>
            <container classes="dothis">
                <paragraph><strong>3.d</strong> Assign an automatic id to all of the items with id “polo”, except for the one whose type is <literal classes="code">UNIT</literal>.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.e</strong> Check that the id of “polo” is now unique in the model by calling the <literal classes="code">isUnique</literal> function.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial5/tutorial5_complete.cpp" xml:space="preserve">    //  3.d
    //      Assign an automatic id to all of the items with id "polo", except for the one whose
    //      type is UNIT.
    poloItem = poloItems.at(2);
    assert(poloItem.first == libcellml::CellmlElementType::UNIT);
    poloItems.erase(poloItems.begin() + 2);

    for (auto &amp;item : poloItems) {
        annotator-&gt;assignId(item);
    }

    //  3.e
    //      Check that the id of "polo" is now unique in the model by calling the 
    //      isUnique function.
    assert(annotator-&gt;isUnique("polo"));

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial5/tutorial5_complete.py" xml:space="preserve">    #  3.d
    #      Assign an automatic id to all of the items with id 'polo', except for the one whose
    #      type is UNIT.
    polo_unit = polo_items.pop(2)
    for item in polo_items:
        annotator.assignId(item)

    #  3.e
    #      Check that the id of 'polo' is now unique in the model by calling the 
    #      isUnique function.
    assert(annotator.isUnique('polo'))

</literal_block>
            </container>
            <paragraph>Now we know that there is only one item in the model with id “polo”, and we also know that it has type <literal classes="code">UNIT</literal>.
                In circumstances where you know the type of the item with the id you’re fetching ahead of time, you can retrieve it without the need to cast using the direct functions according to type: these are listed below.</paragraph>
            <container classes="useful">
                <paragraph><reference internal="False" refuri="https://libcellml.github.io/help/api/v0.2.0/classlibcellml_1_1Annotator">Annotator class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>component</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>componentRef</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>connection</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>encapsulation</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>import</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>mapVariables</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>model</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>reset</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>resetValue</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>testValue</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>unit</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>units</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>variable</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><reference internal="False" refuri="https://libcellml.github.io/help/api/v0.2.0/classlibcellml_1_1Unit">Unit class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>units</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>index</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.f</strong> Retrieve the <literal classes="code">Unit</literal> with id “polo” directly.
                    The <literal classes="code">Unit</literal> class has two attributes:</paragraph>
                <block_quote>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph><literal classes="code">units()</literal> returns the parent <literal classes="code">Units</literal> item; and</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><literal classes="code">index()</literal> returns the index of this unit within its parent.</paragraph>
                        </list_item>
                    </bullet_list>
                </block_quote>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial5/tutorial5_complete.cpp" xml:space="preserve">    //  3.f
    //      Retrieve the Unit with id polo without casting.
    auto poloUnit = annotator-&gt;unit("polo");

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial5/tutorial5_complete.py" xml:space="preserve">    #  3.f
    #      Retrieve the Unit with id polo without casting.
    polo_unit = annotator.unit('polo')

</literal_block>
            </container>
        </section>
        <section ids="step-4-discover-items-whose-ids-are-unknown" names="step\ 4:\ discover\ items\ whose\ ids\ are\ unknown">
            <title>Step 4: Discover items whose ids are unknown</title>
            <paragraph>Now that we’ve found Marco and fixed the duplicates of Polo, we’d like to know what other ids are being used in this model.</paragraph>
            <container classes="useful">
                <paragraph><reference internal="False" refuri="https://libcellml.github.io/help/api/v0.2.0/classlibcellml_1_1Annotator">Annotator class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>ids</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>duplicateIds</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>itemCount</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>4.a</strong> Use the <literal classes="code">ids</literal> function to return a vector of id strings used in the model, and print them to the terminal.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial5/tutorial5_complete.cpp" xml:space="preserve">    //  4.a
    //      Use the Annotator::ids function to return a vector of id strings used in the model, and 
    //      print them to the terminal.
    std::cout &lt;&lt; "The id strings used in the model are:" &lt;&lt; std::endl;
    auto ids = annotator-&gt;ids();
    for(auto &amp;id :ids) {
        std::cout &lt;&lt; "  - '"&lt;&lt; id &lt;&lt; "'" &lt;&lt; std::endl;
    }

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial5/tutorial5_complete.py" xml:space="preserve">    #  4.a
    #      Use the Annotator.ids function to return a vector of id strings used in the model, and 
    #      print them to the terminal.
    print('The id strings used in the model are:')
    ids = annotator.ids()
    for id in ids:
        print('  - "{}"'.format(id))

</literal_block>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">The id strings used in the model are:
    - "b4da55"
    - "b4da56"
    - "b4da57"
    - "b4da58"
    - "b4da59"
    - "i_am_a_component"
    - "marco"
    - "me_too"
    - "polo"
    - "someOtherDuplicatedId"
    - "someOtherId"
    - "whoAmIAndWhereDidIComeFrom"</literal_block>
            <paragraph>The hex strings printed are those which have been automatically generated by the <literal classes="code">assignId</literal> function; we can also see the “marco” and “polo” ids as expected.</paragraph>
            <container classes="dothis">
                <paragraph><strong>4.b</strong> Use the <literal classes="code">duplicateIds</literal> function to return a vector of those ids which have been duplicated in the model.
                    Use the <literal classes="code">itemCount</literal> function to return the number of times each occurs, and print to the terminal.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial5/tutorial5_complete.cpp" xml:space="preserve">    //  4.b
    //      Use the duplicateIds function to return a vector of those ids which have been duplicated in 
    //      the model, and print them to the terminal.
    std::cout &lt;&lt; "Duplicated id strings are:" &lt;&lt; std::endl;
    auto duplicatedIds = annotator-&gt;duplicateIds();
    for(auto &amp;id :duplicatedIds) {
        std::cout &lt;&lt; "  - '" &lt;&lt; id &lt;&lt; "' occurs " &lt;&lt; annotator-&gt;itemCount(id) &lt;&lt; "times." &lt;&lt; std::endl;
    }

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial5/tutorial5_complete.py" xml:space="preserve">    #  4.b
    #      Use the duplicateIds function to return a vector of those ids which have been duplicated in 
    #      the model, and print them to the terminal.
    print('Duplicated id strings are:')
    duplicated_ids = annotator.duplicateIds()
    for id in duplicated_ids:
        print('  - "{}" occurs {} times'.format(id, annotator.itemCount(id)))

</literal_block>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">Duplicated id strings are:
- "someOtherDuplicatedId" occurs 3 times</literal_block>
        </section>
        <section ids="step-5-trace-provenance-of-imported-items" names="step\ 5:\ trace\ provenance\ of\ imported\ items">
            <title>Step 5: Trace provenance of imported items</title>
            <paragraph>The final step is to make sure that imported items can have their annotations tracked back to their sources too.</paragraph>
            <container classes="useful">
                <paragraph><reference internal="False" refuri="https://libcellml.github.io/help/api/v0.2.0/classlibcellml_1_1Importer">Importer class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>create</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>resolveImports</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><reference internal="False" refuri="https://libcellml.github.io/help/api/v0.2.0/classlibcellml_1_1ImportedEntity">ImportedEntity class</reference> (applies to both the <literal classes="code">Units</literal> and the <literal classes="code">Component</literal> class)</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>isImport</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>importReference</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>importSource</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><reference internal="False" refuri="https://libcellml.github.io/help/api/v0.2.0/classlibcellml_1_1ImportSource">ImportSource class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>model</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>url</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>5.a</strong> Retrieve an item with id of “whoAmIAndWhereDidIComeFrom” and print its item type to the terminal.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">The type of item with ID "whoAmIAndWhereDidIComeFrom" is UNITS</literal_block>
            <container classes="dothis">
                <paragraph><strong>5.b</strong> Cast it into a CellML item of the appropriate type.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>5.c</strong> Use its <literal classes="code">isImport()</literal> function to verify that it is imported.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>5.d</strong> Create an <literal classes="code">Importer</literal> instance and use it to resolve this model’s imports.
                    Check that it has not raised any issues.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial5/tutorial5_complete.cpp" xml:space="preserve">    //  5.a
    //      Retrieve an item with id of "whoAmIAndWhereDidIComeFrom" and print its item type
    //      to the terminal.
    auto whoAmIAndWhereDidIComeFrom = annotator-&gt;item("whoAmIAndWhereDidIComeFrom");
    std::cout &lt;&lt; "The type of item with ID 'whoAmIAndWhereDidIComeFrom' is " &lt;&lt; getCellmlElementTypeFromEnum(whoAmIAndWhereDidIComeFrom.first) &lt;&lt; std::endl;
    
    //  5.b
    //      Cast it into a CellML item of the appropriate type.
    auto units = std::any_cast&lt;libcellml::UnitsPtr&gt;(whoAmIAndWhereDidIComeFrom.second);

    //  5.c
    //      Use the Component::isImport() function to verify that it is imported.
    assert(units-&gt;isImport());

    //  5.d
    //      Create an Importer instance and use it to resolve this model's imports.
    //      Check that it has not raised any issues.
    auto importer = libcellml::Importer::create();
    importer-&gt;resolveImports(model, "");
    printIssues(importer);

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial5/tutorial5_complete.py" xml:space="preserve">    #  5.a
    #      Retrieve an item with id of 'whoAmIAndWhereDidIComeFrom' and print its item type
    #      to the terminal.
    who_am_i = annotator.item('whoAmIAndWhereDidIComeFrom')
    print('The type of item with ID "whoAmIAndWhereDidIComeFrom" is {}'.format(get_cellml_element_type_from_enum(who_am_i[0])))
    
    #  5.b
    #      Cast it into a CellML item of the appropriate type.
    units = who_am_i[1]

    #  5.c
    #      Use the Component.isImport() function to verify that it is imported.
    assert(units.isImport())

    #  5.d
    #      Create an Importer instance and use it to resolve this model's imports.
    #      Check that it has not raised any issues.
    importer = Importer()
    importer.resolveImports(model, '')
    print_issues(importer)

</literal_block>
            </container>
            <container classes="dothis">
                <paragraph><strong>5.e</strong> Retrieve all the information needed to locate any annotations on the original item:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>the URL from which it was imported; and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>the id of the item in the original model.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Print these to the terminal.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial5/tutorial5_complete.cpp" xml:space="preserve">    //  5.e
    //      Retrieve all the information needed to locate any annotations on the 
    //      original item:
    //           - the URL from which it was imported; and
    //           - the id of the item in the original model.
    //      Print these to the terminal.
    auto url = units-&gt;importSource()-&gt;url();
    auto reference = units-&gt;importReference();
    auto importedId = units-&gt;importSource()-&gt;model()-&gt;units(reference)-&gt;id();

    std::cout &lt;&lt; "The units with id 'whoAmIAndWhereDidIComeFrom' came from:" &lt;&lt; std::endl;
    std::cout &lt;&lt; "  - url: " &lt;&lt; url &lt;&lt; std::endl;
    std::cout &lt;&lt; "  - id: " &lt;&lt; importedId &lt;&lt; std::endl;
    
</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial5/tutorial5_complete.py" xml:space="preserve">    #  5.e
    #      Retrieve all the information needed to locate any annotations on the 
    #      original item:
    #           - the URL from which it was imported and
    #           - the id of the item in the original model.
    #      Print these to the terminal.
    url = units.importSource().url()
    reference = units.importReference()
    imported_id = units.importSource().model().units(reference).id()

    print('The units with id "whoAmIAndWhereDidIComeFrom" came from:')
    print('  - url: {}'.format(url))
    print('  - id: {}'.format(imported_id))
    
</literal_block>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">The units with id "whoAmIAndWhereDidIComeFrom" came from:
- url: AnotherMysteryModel.cellml
- id: i_am_a_units_item</literal_block>
        </section>
        <section ids="step-6-bulk-operations" names="step\ 6:\ bulk\ operations">
            <title>Step 6: Bulk operations</title>
            <container classes="dothis">
                <paragraph><strong>6.a</strong> Loop through all of the model’s components and print their id to the terminal.
                    Use the <literal classes="code">assignIds</literal> function with an item type of <literal classes="code">libcellml::CellmlElementType::COMPONENT</literal> to give all of the items of that type a new unique id.
                    Print the ids again and notice that the blanks have been filled with automatically generated strings, but existing ids are unchanged.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial5/tutorial5_complete.cpp" xml:space="preserve">    //  6.a
    //      Loop through all of the model's components and print their id to the terminal.
    //      Use the assignIds string with an item type (libcellml::CellmlElementType::COMPONENT)
    //      to give all of the items of that type a new unique id.  Print the ids again and
    //      notice that the blanks have been filled with automatically generated strings, 
    //      but existing ids are unchanged. 
    std::cout &lt;&lt; "Before automatic assigning the components have ids:" &lt;&lt; std::endl;
    for(size_t i = 0; i &lt; model-&gt;componentCount(); ++i) {
        std::cout &lt;&lt; "  - '" &lt;&lt; model-&gt;component(i)-&gt;id() &lt;&lt; "'" &lt;&lt; std::endl;
    }

    annotator-&gt;assignIds(libcellml::CellmlElementType::COMPONENT);

    std::cout &lt;&lt; "After automatic assigning components have ids:" &lt;&lt; std::endl;
    for(size_t i = 0; i &lt; model-&gt;componentCount(); ++i) {
        std::cout &lt;&lt; "  - '" &lt;&lt; model-&gt;component(i)-&gt;id() &lt;&lt; "'" &lt;&lt;std::endl;
    }

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial5/tutorial5_complete.py" xml:space="preserve">    #  6.a
    #      Loop through all of the model's components and print their id to the terminal.
    #      Use the assignIds string with an item type (CellmlElementType.COMPONENT)
    #      to give all of the items of that type a new unique id.  Print the ids again and
    #      notice that the blanks have been filled with automatically generated strings, 
    #      but existing ids are unchanged. 
    print('Before automatic assignment the components have ids:')
    for index in range(0, model.componentCount()):
        print('  - "{}"'.format(model.component(index).id()))

    annotator.assignIds(CellmlElementType.COMPONENT)

    print('After automatic assignment the components have ids:')
    for index in range(0, model.componentCount()):
        print('  - "{}"'.format(model.component(index).id()))

</literal_block>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">Before automatic assignment the components have ids:
    - "i_am_a_component"
    - ""
    - ""
    - ""
    - "me_too"
    - ""

After automatic assignment the components have ids:
    - "i_am_a_component"
    - "b4da5a"
    - "b4da5b"
    - "b4da5c"
    - "me_too"
    - "b4da5d"</literal_block>
            <paragraph>Finally, we decide that it’s too cold for swimming, and want to nuke all the ids and go home.</paragraph>
            <container classes="useful">
                <paragraph><reference internal="False" refuri="https://libcellml.github.io/help/api/v0.2.0/classlibcellml_1_1Annotator">Annotator class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>clearAllIds</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>assignAllIds</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>6.b</strong> Use the <literal classes="code">clearAllIds</literal> function to completely remove all id strings from the model.
                    Check that they have gone by repeating step 4.a to print any ids to the terminal.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">There are 0 ids in the model.</literal_block>
            <paragraph>Go looking for Marco, but he’s gone home already.</paragraph>
            <container classes="dothis">
                <paragraph><strong>6.c</strong> Retrieve the item with id “marco” and print its type to the terminal.
                    Retrieve and print any issues in the annotator to the terminal.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">The type of item with ID "marco" is UNDEFINED

The Annotator has found 1 issues:
Warning[0]:
    Description: Could not find an item with an id of 'marco' in the model.</literal_block>
            <paragraph>Now you regret nuking our friends and make plans to return tomorrow and annotate everything.</paragraph>
            <container classes="dothis">
                <paragraph><strong>6.d</strong> Use the <literal classes="code">assignAllIds</literal> function to give an automatic id to everything which doesn’t already have one (which is everything now!).</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>6.e</strong> Try to retrieve duplicated ids from the annotator as in step 4.b, and check that it returns an empty list.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="container" linenos="False" xml:space="preserve">There are 0 duplicated ids in the model.</literal_block>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial5/tutorial5_complete.cpp" xml:space="preserve">    //  6.b
    //      Finally, we decide that it's too cold for swimming, and want to nuke all the ids
    //      and go home.
    //      Use the clearAllIds function to completely remove all id strings from the model.
    //      Check that they have gone by repeating step 4.a to print any ids to the terminal.
    annotator-&gt;clearAllIds();
    ids = annotator-&gt;ids();
    std::cout &lt;&lt; "There are " &lt;&lt; ids.size() &lt;&lt; " ids in the model." &lt;&lt; std::endl;

    //  6.c
    //      Go looking for Marco, but he's gone home already.
    //      Try and retrieve an item with id "marco" and check that a null pointer is returned.
    //      Retrieve and print any issues to the terminal.
    marcoItem = annotator-&gt;item("marco");
    std::cout &lt;&lt; "The type of item with ID 'marco' is " &lt;&lt; getCellmlElementTypeFromEnum(marcoItem.first) &lt;&lt; std::endl;
    printIssues(annotator);

    //  6.d
    //      Regret nuking our friends and make plans to return tomorrow and
    //      annotate everything.  Use the assignAllIds function to give an automatic
    //      id to everything in the model.
    annotator-&gt;assignAllIds();

    //  6.e
    //      Try to retrieve duplicated ids from the annotator as in step 4.b, and
    //      check that it returns an empty list.
    duplicatedIds = annotator-&gt;duplicateIds();
    std::cout &lt;&lt; "There are " &lt;&lt; duplicatedIds.size() &lt;&lt; " duplicated ids left in the model." &lt;&lt; std::endl;

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial5/tutorial5_complete.py" xml:space="preserve">    #  6.b
    #      Finally, we decide that it's too cold for swimming, and want to nuke all the ids
    #      and go home.
    #      Use the clearAllIds function to completely remove all id strings from the model.
    #      Check that they have gone by repeating step 4.a to print any ids to the terminal.
    annotator.clearAllIds()
    ids = annotator.ids()
    print('There are {} ids in the model.'.format(len(ids)))

    #  6.c
    #      Go looking for Marco, but he's gone home already.
    #      Try and retrieve an item with id 'marco' and check that a null pointer is returned.
    #      Retrieve and print any issues to the terminal.
    marco_item = annotator.item('marco')
    print('The type of item with ID "marco" is {}'.format(get_cellml_element_type_from_enum(marco_item[0])))
    print_issues(annotator)

    #  6.d
    #      Regret nuking our friends and make plans to return tomorrow and
    #      annotate everything.  Use the assignAllIds function to give an automatic
    #      id to everything in the model.
    annotator.assignAllIds()

    #  6.e
    #      Try to retrieve duplicated ids from the annotator as in step 4.b, and
    #      check that it returns an empty list.
    duplicated_ids = annotator.duplicateIds()
    print('There are {} duplicated ids in the model.'.format(len(duplicated_ids)))

</literal_block>
            </container>
        </section>
    </section>
</document>
