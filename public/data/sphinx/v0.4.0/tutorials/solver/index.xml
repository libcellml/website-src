<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.16 -->
<document source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/solver/index.rst">
    <target refid="solver"></target>
    <section ids="simple-solver-for-generated-models solver" names="simple\ solver\ for\ generated\ models solver">
        <title>Simple solver for generated models</title>
        <paragraph>The theory behind how a numerical solver or integration program works is outlined in the <reference internal="True" refuri="../../theory/theory_ode_solutions#theory-ode-solutions"><inline classes="std std-ref">Theory of ODE solvers</inline></reference> page.
            This section describes how to use the simple solvers provided to run models generated with either the C or Python profiles.</paragraph>
        <topic classes="contents local" ids="contents" names="contents">
            <title>Contents</title>
            <bullet_list>
                <list_item>
                    <paragraph><reference ids="id1" refid="c-profile-solver">C profile solver</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id2" refid="python-profile-solver">Python profile solver</reference></paragraph>
                </list_item>
            </bullet_list>
        </topic>
        <section ids="c-profile-solver" names="c\ profile\ solver">
            <title refid="id1">C profile solver</title>
            <paragraph>In C++ you can use the code provided in the <literal classes="code">tutorials/solver</literal> directory to build your generated code into a runnable simulation.
                To use the package just follow the instructions below.
                You will need to download:</paragraph>
            <block_quote>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><download_reference filename="e56c2227984d967aefe9abffce006e12/CMakeLists.txt" refdoc="tutorials/solver/index" refdomain="" refexplicit="True" reftarget="CMakeLists.txt" reftype="download" refwarn="False"><literal classes="xref download">CMakeLists.txt</literal></download_reference> The CMake file which controls the building of the solver.
                            Note that this is a little different from usual, as outlined below.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><download_reference filename="df6f8b84a936cdb2e2b16e7a3c353e81/simpleSolver.cpp" refdoc="tutorials/solver/index" refdomain="" refexplicit="True" reftarget="simpleSolver.cpp" reftype="download" refwarn="False"><literal classes="xref download">simpleSolver.cpp</literal></download_reference> The source file.</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
            <container classes="dothis">
                <paragraph><strong>1.a</strong> Assuming you’ve already generated code using the C profile, open a terminal window and navigate into the <literal classes="code">tutorials/solver</literal> directory.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">cd your_base_path/tutorials/solver</literal_block>
            <paragraph>Because the code you’ve generated needs to be built at the same time as the solver code is built, each different model requires rebuilding the solver to include the generated code.</paragraph>
            <container classes="dothis">
                <paragraph><strong>1.b</strong> The next step is to build your generated code into the solver code.
                    From inside the <literal classes="code">tutorials/solver</literal> directory, use the CMake command line to point to your generated files.
                    <strong>NB</strong> It’s assumed that both of the header and source files have the same base filename (eg: baseFileName.c and baseFileName.h).
                    The general CMake command is below.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">cmake -DINPUT=/path/to/your/files/baseFileName .</literal_block>
            <container classes="gotcha">
                <paragraph>Note that the fullstop in the cmake command sets both the source and binary directories to the solver directory.
                    This is because even though your generated files are elsewhere, the solver code and CMakeLists.txt file are in <emphasis>this</emphasis> directory.</paragraph>
            </container>
            <paragraph>If all has gone well you should see the output similar to:</paragraph>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">-- The C compiler identification is AppleClang 10.0.1.10010046
-- The CXX compiler identification is AppleClang 10.0.1.10010046
-- Check for working C compiler: /Library/Developer/CommandLineTools/usr/bin/cc
-- Check for working C compiler: /Library/Developer/CommandLineTools/usr/bin/cc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done
-- Check for working CXX compiler: /Library/Developer/CommandLineTools/usr/bin/c++
-- Check for working CXX compiler: /Library/Developer/CommandLineTools/usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done

1) First use 'make -j' to build the file for running
2) Then solve by running: ./solve_baseFileName with the arguments:
  -n  step_total
  -dt step_size

-- Configuring done
-- Generating done
-- Build files have been written to: /path/to/your/stuff/tutorials/solver</literal_block>
            <container classes="dothis">
                <paragraph><strong>1.c</strong> Following the instructions in the output, next you need to build the
                    executable by entering:</paragraph>
                <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">make -j</literal_block>
            </container>
            <container classes="dothis">
                <paragraph><strong>1.d</strong> Finally you’re ready to solve your model.
                    The executable will have been given the prefix <literal classes="code">solve_</literal> and then your <literal classes="code">baseFileName</literal>, and can be run using the command line flags <literal classes="code">-n</literal> to indicate the number of steps to run, and <literal classes="code">-dt</literal> to indicate the step size.
                    For example:</paragraph>
                <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">./solve_baseFileName -n 20000 -dt 0.001</literal_block>
            </container>
            <paragraph>The parameters read from the file, along with your command line arguments are printed to the terminal for checking, and the results of the simulation written to a tab-delimited file with the extension <literal classes="code">_solution.txt</literal> after your base file name.</paragraph>
        </section>
        <section ids="python-profile-solver" names="python\ profile\ solver">
            <title refid="id2">Python profile solver</title>
            <paragraph>The solver script is a very simple implementation of the Euler stepping method in Python.
                The theory on which it’s based can be found on the <reference internal="True" refuri="../../theory/theory_ode_solutions#theory-ode-solutions"><inline classes="std std-ref">Theory of ODE solver</inline></reference> page.
                You will need to download:</paragraph>
            <block_quote>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><download_reference filename="9eb130da6ac864b0514eb41dc0620fff/simplesolver.py" refdoc="tutorials/solver/index" refdomain="" refexplicit="True" reftarget="simplesolver.py" reftype="download" refwarn="False"><literal classes="xref download">simplesolver.py</literal></download_reference> The solver script.</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
            <paragraph>Once you’ve used the <literal classes="code">Generator</literal> to write a CellML model into Python format, you need to run it to produce the solution.
                The script can be run from the command line as below:</paragraph>
            <container classes="dothis">
                <paragraph><strong>1.</strong>  Navigate into the “solver” directory</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">cd your_base_path/tutorials/solver</literal_block>
            <container classes="dothis">
                <paragraph><strong>2.</strong>  Run the solver.  To do this you’ll need to enter:</paragraph>
                <block_quote>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph><literal classes="code">-m</literal> the path to the generated file to run, relative to the solver directory;</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><literal classes="code">-dt</literal> the step size for the integration variable to take; and</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><literal classes="code">-n</literal> the total number of steps to take.</paragraph>
                        </list_item>
                    </bullet_list>
                </block_quote>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">python3 solveGeneratedModel.py -m path_to_your_file -n number_of_steps -dt step_size</literal_block>
            <paragraph>You should see output to the terminal which echoes the settings and initial conditions, as below.
                An example file for running is provided for you in the <literal classes="code">resources/tutorial3_PredatorPrey_generated.py</literal> file, which can be run for 2000 steps and a step size of 0.01.
                Running this will give you the terminal output:</paragraph>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">python3 solveGeneratedModel.py -m ../resources/tutorial3_PredatorPrey_generated.py -dt 0.01 -n 2000

====================================================================
   SIMPLE SOLVER: ../resources/tutorial3_PredatorPrey_generated
--------------------------------------------------------------------

   VARIABLE OF INTEGRATION (units, stepsize)
--------------------------------------------------------------------
      time (day, 0.01)
      2000 steps

   STATE VARIABLES (units, initial value)
--------------------------------------------------------------------
      y_s (number_of_sharks, 1.0)
      y_f (thousands_of_fish, 2.0)

   VARIABLES (units, initial value)
--------------------------------------------------------------------
      a (per_day, -0.8)
      b (per_shark_day, 0.3)
      d (per_fish_day, -0.6)
      c (per_day, -2.8)

   SOLUTION written to ../resources/tutorial3_PredatorPrey_generated_solution.txt
====================================================================</literal_block>
            <paragraph>The output is a tab delimited file with the ending <literal classes="code">_solution.txt</literal> after the input file name (note that it’s in the same directory as the running file too), which can be opened by the plotting program of your choice.</paragraph>
        </section>
    </section>
</document>
