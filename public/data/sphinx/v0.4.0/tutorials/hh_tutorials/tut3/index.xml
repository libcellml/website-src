<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.16 -->
<document source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/index.rst">
    <target refid="debugsodiumchannelmodel"></target>
    <section ids="hodgkin-huxley-3-debugging-a-model debugsodiumchannelmodel" names="hodgkin-huxley\ 3:\ debugging\ a\ model debugsodiumchannelmodel">
        <title>Hodgkin-Huxley 3: Debugging a model</title>
        <container classes="shortlist">
            <paragraph>By the time you have worked through this part of the tutorial you will be able to:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Parse an existing CellML file and deserialise it into a model instance;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Use the diagnostic <literal classes="code">Validator</literal> class to identify issues in the model’s definition;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Use the <literal classes="code">std::any_cast</literal> to retrieve items which need repair from <literal classes="code">Issue</literal> items;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Use the <literal classes="code">Importer</literal> class to resolve imports and identify issues; and</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Use the diagnostic <literal classes="code">Analyser</literal> class to identify issues in the model’s mathematical formulation.</paragraph>
                </list_item>
            </bullet_list>
        </container>
        <container classes="shortlist">
            <paragraph><strong>Code (C++)</strong></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><download_reference filename="24eb7d0a1e98b3a065d25198ddf8a4a8/CMakeLists.txt" refdoc="tutorials/hh_tutorials/tut3/index" refdomain="" refexplicit="True" reftarget="CMakeLists.txt" reftype="download" refwarn="False"><literal classes="xref download">CMakeLists.txt</literal></download_reference> The CMake file for building this tutorial;</paragraph>
                </list_item>
                <list_item>
                    <paragraph><download_reference filename="738a977516cb790dc9f106f6c99a5a51/debugSodiumChannelModel.cpp" refdoc="tutorials/hh_tutorials/tut3/index" refdomain="" refexplicit="True" reftarget="debugSodiumChannelModel.cpp" reftype="download" refwarn="False"><literal classes="xref download">debugSodiumChannelModel.cpp</literal></download_reference> Either the skeleton code, or ..</paragraph>
                </list_item>
                <list_item>
                    <paragraph><download_reference filename="1d8535c7b09cba8accf69e85d3a1325b/debugSodiumChannelModel_completed.cpp" refdoc="tutorials/hh_tutorials/tut3/index" refdomain="" refexplicit="True" reftarget="debugSodiumChannelModel_completed.cpp" reftype="download" refwarn="False"><literal classes="xref download">debugSodiumChannelModel_completed.cpp</literal></download_reference> the completed tutorial code; and</paragraph>
                </list_item>
                <list_item>
                    <paragraph><download_reference filename="06ff53536b706ded677269f762807d27/utilities.cpp" refdoc="tutorials/hh_tutorials/tut3/index" refdomain="" refexplicit="True" reftarget="../code/utilities.cpp" reftype="download" refwarn="False"><literal classes="xref download">utilities.cpp</literal></download_reference> and <download_reference filename="552053dccea02ef16af526455359b1c2/utilities.h" refdoc="tutorials/hh_tutorials/tut3/index" refdomain="" refexplicit="True" reftarget="../code/utilities.h" reftype="download" refwarn="False"><literal classes="xref download">utilities.h</literal></download_reference> Helper functions.</paragraph>
                </list_item>
            </bullet_list>
        </container>
        <container classes="shortlist">
            <paragraph><strong>Code (Python)</strong></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><download_reference filename="21b5241d4e386cd903035149835d4ca5/debugSodiumChannelModel.py" refdoc="tutorials/hh_tutorials/tut3/index" refdomain="" refexplicit="True" reftarget="debugSodiumChannelModel.py" reftype="download" refwarn="False"><literal classes="xref download">debugSodiumChannelModel.py</literal></download_reference> Either the skeleton code, or ..</paragraph>
                </list_item>
                <list_item>
                    <paragraph><download_reference filename="6567751c1466a3320fa19f3806787f51/debugSodiumChannelModel_completed.py" refdoc="tutorials/hh_tutorials/tut3/index" refdomain="" refexplicit="True" reftarget="debugSodiumChannelModel_completed.py" reftype="download" refwarn="False"><literal classes="xref download">debugSodiumChannelModel_completed.py</literal></download_reference> the completed tutorial code; and</paragraph>
                </list_item>
            </bullet_list>
        </container>
        <container classes="shortlist">
            <paragraph><strong>Resources</strong></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><download_reference filename="5225d6f6f7848cde5af1de4059bc6cd1/GateModel.cellml" refdoc="tutorials/hh_tutorials/tut3/index" refdomain="" refexplicit="True" reftarget="GateModel.cellml" reftype="download" refwarn="False"><literal classes="xref download">GateModel.cellml</literal></download_reference> the generic gate model created in Tutorial 1;</paragraph>
                </list_item>
                <list_item>
                    <paragraph><download_reference filename="609547d1bd2e462ab6ea0e2973ec2c96/SodiumChannelModel_broken.cellml" refdoc="tutorials/hh_tutorials/tut3/index" refdomain="" refexplicit="True" reftarget="SodiumChannelModel_broken.cellml" reftype="download" refwarn="False"><literal classes="xref download">SodiumChannelModel_broken.cellml</literal></download_reference> a sodium channel model that needs debugging;</paragraph>
                </list_item>
                <list_item>
                    <paragraph><download_reference filename="478d3eef3bbe87c291796ec3a12d87b2/CircularControllerReference.cellml" refdoc="tutorials/hh_tutorials/tut3/index" refdomain="" refexplicit="True" reftarget="CircularControllerReference.cellml" reftype="download" refwarn="False"><literal classes="xref download">CircularControllerReference.cellml</literal></download_reference> import file;</paragraph>
                </list_item>
                <list_item>
                    <paragraph><download_reference filename="bc8e1894fcab6a979b304273442c375e/CircularControllerReference2.cellml" refdoc="tutorials/hh_tutorials/tut3/index" refdomain="" refexplicit="True" reftarget="CircularControllerReference2.cellml" reftype="download" refwarn="False"><literal classes="xref download">CircularControllerReference2.cellml</literal></download_reference> import file; and</paragraph>
                </list_item>
                <list_item>
                    <paragraph><download_reference filename="ef0954006aa3ef024fb6f87e0894888f/SodiumChannelController.cellml" refdoc="tutorials/hh_tutorials/tut3/index" refdomain="" refexplicit="True" reftarget="SodiumChannelController.cellml" reftype="download" refwarn="False"><literal classes="xref download">SodiumChannelController.cellml</literal></download_reference> import file.</paragraph>
                </list_item>
            </bullet_list>
        </container>
        <topic classes="contents local" ids="contents" names="contents">
            <title>Contents</title>
            <bullet_list>
                <list_item>
                    <paragraph><reference ids="id1" refid="overview">Overview</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id2" refid="step-1-parse-the-existing-sodium-channel-model">Step 1: Parse the existing sodium channel model</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id3" refid="step-2-validate-the-parsed-model">Step 2: Validate the parsed model</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id4" refid="step-3-repair-the-parsed-model">Step 3: Repair the parsed model</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id5" refid="step-4-resolve-the-model-s-imports">Step 4: Resolve the model’s imports</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id6" refid="step-5-validate-the-imported-dependencies">Step 5: Validate the imported dependencies</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id7" refid="step-6-analyse-the-model-s">Step 6: Analyse the model(s)</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id8" refid="step-7-serialise-and-print-the-repaired-model">Step 7: Serialise and print the repaired model</reference></paragraph>
                </list_item>
            </bullet_list>
        </topic>
        <section ids="overview" names="overview">
            <title refid="id1">Overview</title>
            <paragraph>This tutorial looks at how a “broken” model can be investigated and debugged using the diagnostic tools in the three special classes: the <literal classes="code">Importer</literal>, the <literal classes="code">Analyser</literal>, and the <literal classes="code">Validator</literal>.</paragraph>
        </section>
        <section ids="step-1-parse-the-existing-sodium-channel-model" names="step\ 1:\ parse\ the\ existing\ sodium\ channel\ model">
            <title refid="id2">Step 1: Parse the existing sodium channel model</title>
            <paragraph>The <literal classes="code">Parser</literal> class is used to deserialise a CellML string into a <literal classes="code">Model</literal> instance.
                This means that you’re responsible for finding, opening and reading the <literal classes="code">*.cellml</literal> file into a single string.
                The parser will then read that string and return a model.</paragraph>
            <container classes="dothis">
                <paragraph><strong>1.a</strong> Read a CellML file into a string.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>1.b</strong> Create a <literal classes="code">Parser</literal> item.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>1.c</strong> Use the parser to deserialise the contents of the string you’ve read into a model.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>1.d</strong> Print the parsed model to the terminal for viewing.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.cpp" xml:space="preserve">    //  1.a 
    //      Read a CellML file into a std::string.
    std::ifstream inFile("sodiumChannelModel_broken.cellml");
    std::stringstream inFileContents;
    inFileContents &lt;&lt; inFile.rdbuf();

    //  1.b 
    //      Create a Parser item. 
    auto parser = libcellml::Parser::create();

    //  1.c 
    //      Use the parser to deserialise the contents of the string you've read and return the model.
    auto model = parser-&gt;parseModel(inFileContents.str());

    //  1.d 
    //      Print the parsed model to the terminal for viewing.
    printModel(model, false);

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.py" xml:space="preserve">    #  1.a 
    #      Read a CellML file into a string.
    read_file = open("sodiumChannelModel_broken.cellml")

    #  1.b 
    #      Create a Parser item. 
    parser = Parser()

    #  1.c 
    #      Use the parser to deserialise the contents of the string you've read and return the model.
    model = parser.parseModel(read_file.read())

    #  1.d 
    #      Print the parsed model to the terminal for viewing.
    print_model(model, False)

</literal_block>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">MODEL: 'SodiumChannelModel'
    UNITS: 5 custom units
        [0]: mV
        [1]: ms
        [2]: per_ms
        [3]: per_mV_ms
        [4]: microA_per_cm2
    COMPONENTS: 4 components
        [0]: controller &lt;--- imported from: 'controller' in 'CircularControllerReference.cellml'
            VARIABLES: 2 variables
                [0]: t
                    └──&gt; sodiumChannel:t [ms]
                [1]: V
                    └──&gt; sodiumChannel:V
        [1]: mGateEquations!
            VARIABLES: 5 variables
                [0]: alpha_m [per_ms]
                [1]: V [mV]
                [2]: beta_m [per_ms]
                [3]: m [dimensionless]
                [4]: t [ms]
        [2]: importedGateM &lt;--- imported from: 'gateEquations' in 'GateModel.cellml'
            VARIABLES: 4 variables
                [0]: alpha_X
                [1]: beta_X
                [2]: X
                [3]: t
        [3]: sodiumChannel
            VARIABLES: 3 variables
                [0]: t [ms]
                    └──&gt; controller:t, sodiumChannelEquations:t [ms]
                [1]: V
                    └──&gt; controller:V, sodiumChannelEquations:V [mV]
                [2]: i_Na [microA_per_cm2]
                    └──&gt; sodiumChannelEquations:i_Na [microA_per_cm2]
            COMPONENT sodiumChannel has 2 child components:
                [0]: sodiumChannelEquations
                    VARIABLES: 8 variables
                        [0]: Na_conductance [mS_per_cm2]
                        [1]: g_Na [mS_per_cm2]
                            └──&gt; sodiumChannelParameters:g_Na [mS_per_cm2]
                        [2]: h [dimensionless]
                            └──&gt; hGate:h [dimensionless]
                        [3]: m [dimensionless]
                            └──&gt; mGate:m [dimensionless]
                        [4]: i_Na [microA_per_cm2]
                            └──&gt; sodiumChannel:i_Na [microA_per_cm2]
                        [5]: V [mV]
                            └──&gt; sodiumChannel:V, hGate:V [mV], mGate:V [mV]
                        [6]: E_Na [mV]
                            └──&gt; sodiumChannelParameters:E_Na [mV]
                        [7]: t [ms]
                            └──&gt; sodiumChannel:t [ms], hGate:t [ms], mGate:t [ms]
                    COMPONENT sodiumChannelEquations has 2 child components:
                        [0]: mGate
                            VARIABLES: 3 variables
                                [0]: t [ms]
                                    └──&gt; sodiumChannelEquations:t [ms]
                                [1]: m [dimensionless]
                                    └──&gt; sodiumChannelEquations:m [dimensionless]
                                [2]: V [mV]
                                    └──&gt; sodiumChannelEquations:V [mV]
                            COMPONENT mGate has 1 child components:
                                [0]: mGateParameters
                                    VARIABLES: 2 variables
                                        [0]: m [dimensionless], initial = 0.05
                                        [1]: i_am_redundant [steradian]
                        [1]: hGate
                            VARIABLES: 3 variables
                                [0]: t [ms]
                                    └──&gt; sodiumChannelEquations:t [ms], hGateEquations:t [ms]
                                [1]: h [dimensionless]
                                    └──&gt; sodiumChannelEquations:h [dimensionless], hGateEquations:h [dimensionless]
                                [2]: V [mV]
                                    └──&gt; sodiumChannelEquations:V [mV], hGateEquations:V [mV]
                            COMPONENT hGate has 2 child components:
                                [0]: hGateParameters
                                    VARIABLES: 1 variables
                                        [0]: h [dimensionless], initial = 0.6
                                [1]: hGateEquations
                                    VARIABLES: 5 variables
                                        [0]: alpha_h [per_ms]
                                            └──&gt; importedGateH:alpha_X
                                        [1]: beta_h [per_ms]
                                            └──&gt; importedGateH:beta_X
                                        [2]: V [mV]
                                            └──&gt; hGate:V [mV]
                                        [3]: h [dimensionless]
                                            └──&gt; hGate:h [dimensionless], importedGateH:X
                                        [4]: t [ms]
                                            └──&gt; hGate:t [ms], importedGateH:t
                                    COMPONENT hGateEquations has 1 child components:
                                        [0]: importedGateH &lt;--- imported from: 'i_dont_exist' in 'GateModel.cellml'
                                            VARIABLES: 4 variables
                                                [0]: alpha_X
                                                    └──&gt; hGateEquations:alpha_h [per_ms]
                                                [1]: beta_X
                                                    └──&gt; hGateEquations:beta_h [per_ms]
                                                [2]: X
                                                    └──&gt; hGateEquations:h [dimensionless]
                                                [3]: t
                                                    └──&gt; hGateEquations:t [ms]
                [1]: sodiumChannelParameters
                    VARIABLES: 2 variables
                        [0]: g_Na [mS_per_cm2], initial = 120
                            └──&gt; sodiumChannelEquations:g_Na [mS_per_cm2]
                        [1]: E_Na [mV]
                            └──&gt; sodiumChannelEquations:E_Na [mV]</literal_block>
        </section>
        <section ids="step-2-validate-the-parsed-model" names="step\ 2:\ validate\ the\ parsed\ model">
            <title refid="id3">Step 2: Validate the parsed model</title>
            <paragraph>Create a <literal classes="code">Validator</literal> item and use it to validate the model you’ve just read.</paragraph>
            <container classes="dothis">
                <paragraph><strong>2.a</strong> Create a <literal classes="code">Validator</literal> item and validate the model.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.cpp" xml:space="preserve">    //  2.a 
    //      Create a Validator item and validate the model.
    auto validator = libcellml::Validator::create();
    validator-&gt;validateModel(model);

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.py" xml:space="preserve">    #  2.a 
    #      Create a Validator item and validate the model.
    validator = Validator()
    validator.validateModel(model)

</literal_block>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.b</strong> Retrieve any issues from the validator and print them to the terminal.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="container" linenos="False" xml:space="preserve">The validator found 10 issues.
Issue 0: CellML identifiers must not contain any characters other than [a-zA-Z0-9_].
reference: 1.3.1.1
see: https://cellml-specification.readthedocs.io/en/latest/reference/formal_and_informative/specA03.html?issue=1.3.1.1
stored item type: UNDEFINED

Issue 1: Component 'mGateEquations!' does not have a valid name attribute.
reference: 2.7.1
see: https://cellml-specification.readthedocs.io/en/latest/reference/formal_and_informative/specB07.html?issue=2.7.1
stored item type: COMPONENT

Issue 2: Variable 'Na_conductance' in component 'sodiumChannelEquations' has a units reference 'mS_per_cm2' which is neither standard nor defined in the parent model.
reference: 2.8.1.2
see: https://cellml-specification.readthedocs.io/en/latest/reference/formal_and_informative/specB08.html?issue=2.8.1.2
stored item type: VARIABLE

... etc ...</literal_block>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.cpp" xml:space="preserve">    //  2.b
    //      Retrieve any issues from the validator and print their descriptions and help URL to the terminal.
    //      If you're already familiar with these you can use the printIssues function instead.
    std::cout &lt;&lt; "The validator found " &lt;&lt; validator-&gt;issueCount() &lt;&lt; " issues." &lt;&lt; std::endl;
    for(size_t i = 0; i &lt; validator-&gt;issueCount(); ++i) {
        auto issue = validator-&gt;issue(i);
        std::cout &lt;&lt; "Issue " &lt;&lt; i &lt;&lt; ": " &lt;&lt; issue-&gt;description() &lt;&lt; std::endl;
        std::cout &lt;&lt; "  reference: "&lt;&lt; issue-&gt;referenceHeading() &lt;&lt; std::endl;
        std::cout &lt;&lt; "  see: " &lt;&lt; issue-&gt;url() &lt;&lt; std::endl;
        std::cout &lt;&lt; "  stored item type: " &lt;&lt; getCellmlElementTypeFromEnum(issue-&gt;cellmlElementType()) &lt;&lt; std::endl;
        std::cout &lt;&lt; std::endl;
    }
</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.py" xml:space="preserve">    #  2.b
    #      Retrieve any issues from the validator and print their descriptions and help URL to the terminal.
    #      If you're already familiar with these you can use the print_issues function instead.
    print('The validator found {} issues.'.format(validator.issueCount()))
    for i in range(0, validator.issueCount()):
        issue = validator.issue(i)
        print('Issue {}: {}'.format(i,issue.description()))
        print('  reference: {}'.format(issue.referenceHeading()))
        print('  see: {}'.format(issue.url()))
        print('  stored item type: {}'.format(get_cellml_element_type_from_enum(issue.cellmlElementType())))
        print()

</literal_block>
            </container>
        </section>
        <section ids="step-3-repair-the-parsed-model" names="step\ 3:\ repair\ the\ parsed\ model">
            <title refid="id4">Step 3: Repair the parsed model</title>
            <paragraph>The messages returned from the validator (and other classes) should (!) have enough information to enable you to know what the problem is.
                In the case of the validator class, the URL listed contains additional resources and examples related to the issue, as well as its section in the CellML normative specification.</paragraph>
            <paragraph>In some situations more than one <literal classes="code">Issue</literal> will be generated from a single cause: this is the case with issues 0 and 1 here:</paragraph>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">Issue 0: CellML identifiers must not contain any characters other than [a-zA-Z0-9_].
    reference: 1.3.1.1
    see: https://cellml-specification.readthedocs.io/en/latest/reference/formal_and_informative/specA03.html?issue=1.3.1.1
Issue 1: Component 'mGateEquations!' does not have a valid name attribute.
    reference: 2.7.1
    see: https://cellml-specification.readthedocs.io/en/latest/reference/formal_and_informative/specB07.html?issue=2.7.1</literal_block>
            <container classes="dothis">
                <paragraph><strong>3.a</strong> Fetch the component using its name, and set the name to something valid.
                    Note that when finding a <literal classes="code">Component</literal> item, setting an optional second argument to <literal classes="code">true</literal> will search the entire encapsulation hierarchy for a component with that name, and not only the direct children of the model.
                    You can follow the URL for information about what makes a valid name, and use the <literal classes="code">setName</literal> function to fix it.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.cpp" xml:space="preserve">    //  3.a
    //      Fetch the component using its name, and set the name to something valid.  Note that when finding
    //      a Component item, setting an optional second argument to `true` will search the entire encapsulation
    //      hierarchy for a component with that name, and not only the direct children of the model.
    //      You can follow the URL for information about what makes a valid name, and use the Component::setName
    //      function to fix it.
    model-&gt;component("mGateEquations!", true)-&gt;setName("mGateEquations");

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.py" xml:space="preserve">    #  3.a
    #      Fetch the component using its name, and set the name to something valid.  Note that when finding
    #      a Component item, setting an optional second argument to `True` will search the entire encapsulation
    #      hierarchy for a component with that name, and not only the direct children of the model.
    #      You can follow the URL for information about what makes a valid name, and use the Component.setName
    #      function to fix it.
    model.component('mGateEquations!', True).setName('mGateEquations')

</literal_block>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">Issue 2: Variable 'Na_conductance' in component 'sodiumChannelEquations' has a units reference 'mS_per_cm2' which is neither standard nor defined in the parent model.
    reference: 2.8.1.2
    see: https://cellml-specification.readthedocs.io/en/latest/reference/formal_and_informative/specB08.html?issue=2.8.1.2
Issue 3: Variable 'g_Na' in component 'sodiumChannelEquations' has a units reference 'mS_per_cm2' which is neither standard nor defined in the parent model.
    reference: 2.8.1.2
    see: https://cellml-specification.readthedocs.io/en/latest/reference/formal_and_informative/specB08.html?issue=2.8.1.2
Issue 4: Variable 'g_Na' in component 'sodiumChannelParameters' has a units reference 'mS_per_cm2' which is neither standard nor defined in the parent model.
    reference: 2.8.1.2
    see: https://cellml-specification.readthedocs.io/en/latest/reference/formal_and_informative/specB08.html?issue=2.8.1.2</literal_block>
            <container classes="dothis">
                <paragraph><strong>3.b</strong> The messages above indicate that we’re missing a Units item named “mS_per_cm2”.
                    Create an appropriate Units item (note that S stands for “siemens”), and add it to your model.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.cpp" xml:space="preserve">    //  3.b
    //      Create an appropriate Units item (note that S stands for "siemens"), and add it to your model.
    auto mS_per_cm2 = libcellml::Units::create("mS_per_cm2");
    mS_per_cm2-&gt;addUnit("siemens", "milli");
    mS_per_cm2-&gt;addUnit("metre", "centi", -2);
    model-&gt;addUnits(mS_per_cm2);

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.py" xml:space="preserve">    #  3.b
    #      Create an appropriate Units item (note that S stands for 'siemens'), and add it to your model.
    mS_per_cm2 = Units('mS_per_cm2')
    mS_per_cm2.addUnit('siemens', 'milli')
    mS_per_cm2.addUnit('metre', 'centi', -2)
    model.addUnits(mS_per_cm2)

</literal_block>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">Issue 5: CellML identifiers must contain one or more basic Latin alphabetic characters.
    reference: 1.3.1.1
    see: https://cellml-specification.readthedocs.io/en/latest/reference/formal_and_informative/specA03.html?issue=1.3.1.1
Issue 6: Variable 'V' in component 'sodiumChannel' does not have a valid units attribute. The attribute given is ''.
    reference: 2.8.1.2
    see: https://cellml-specification.readthedocs.io/en/latest/reference/formal_and_informative/specB08.html?issue=2.8.1.2
Issue 8: Variable 'V' in component 'sodiumChannel' has units of '' and an equivalent variable 'V' in component 'sodiumChannelEquations' with non-matching units of 'mV'. The mismatch is:
    reference:
    see:</literal_block>
            <paragraph>As with 3.a, here we have more than one issue generated from the same cause: in this case, we haven’t specified units for a variable.</paragraph>
            <paragraph>Each issue generated contains a pointer to the item to which it refers.
                We can retrieve the affected item directly from the issue in one of two ways:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>retrieving an <literal classes="code">AnyItem</literal> structure (whose “first” attribute is an enum of the <literal classes="code">CellmlElementType</literal>;
                        and “second” attribute is an std::any cast of the item itself); and casting it appropriately, or</paragraph>
                </list_item>
                <list_item>
                    <paragraph>since we know that the type of item in this error is a <literal classes="code">VARIABLE</literal>, we can call the convenience method <literal classes="code">Issue::variable()</literal> to return the variable which needs attention.
                        (Of course you could retrieve it using the name of its parent component and its name too - this is just another way!)</paragraph>
                </list_item>
            </bullet_list>
            <container classes="dothis">
                <paragraph><strong>3.c</strong> Check that the item to be returned from the issue is in fact an <literal classes="code">CellmlElementType::VARIABLE</literal> by calling its <literal classes="code">cellmlElementType()</literal> function.
                    Retrieve the variable missing units from the issue.
                    Set its units to be millivolts.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.cpp" xml:space="preserve">    //  3.c
    //      Check that the item to be returned from the issue is in fact an CellmlElementType::VARIABLE by calling the Issue::type()
    //      function.  Retrieve the variable missing units from the issue.  Set its units to be millivolts.
    auto issue4 = validator-&gt;issue(4);
    assert(issue4-&gt;cellmlElementType() == libcellml::CellmlElementType::VARIABLE);
    issue4-&gt;variable()-&gt;setUnits(model-&gt;units("mV"));

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.py" xml:space="preserve">    #  3.c
    #      Check that the item to be returned from the issue is in fact an CellmlElementType.VARIABLE by calling the Issue.type()
    #      function.  Retrieve the variable missing units from the issue.  Set its units to be millivolts.
    issue6 = validator.issue(6)
    print('Issue 6 is a {}'.format(get_cellml_element_type_from_enum(issue6.cellmlElementType())))
    issue6.variable().setUnits(model.units('mV'))

</literal_block>
            </container>
            <paragraph>The error below indicates that a child <literal classes="code">Unit</literal> references something which can’t be found.</paragraph>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">Issue 7: Units reference 'i_dont_exist' in units 'mV' is not a valid reference to a local units or a standard unit type.
    reference: 2.6.1
    see: https://cellml-specification.readthedocs.io/en/latest/reference/formal_and_informative/specB06.html?issue=2.6.1</literal_block>
            <paragraph>You have a few different options for how to fix this one.</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=")">
                <list_item>
                    <paragraph>The manual way.
                        The issue description tells us the name of the <literal classes="code">Units</literal> where the issue is, and the name of the units required by one of its children.
                        We can locate both items using these names, remove the problem child, and replace it with a correct one.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The pointer way.
                        As with the example in 3.c, we can retrieve a structure representing the <literal classes="code">Unit</literal> child directly from the issue.
                        Since (as above) we know it will be a <literal classes="code">Unit</literal> item, we can call the issue-&gt;unit() function to retrieve it.
                        The <literal classes="code">Unit</literal> item consists of a pointer to its parent <literal classes="code">Units</literal> item, and the index of the relevant child.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The roundabout option.
                        Since the error is saying that units named “i_dont_exist” are missing, we could simply provide them by creating a <literal classes="code">Units</literal> item and adding it to the model.</paragraph>
                </list_item>
            </enumerated_list>
            <container classes="useful">
                <paragraph><reference internal="False" refuri="https://libcellml.github.io/help/api/v0.2.0/classlibcellml_1_1Units">Units class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>unitAttributes</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>removeUnit</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>addUnit</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.d</strong> Choose your preferred method and use it to retrieve the problem unit attributes and print them all to the terminal.
                    Then fix the issue.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.cpp" xml:space="preserve">    //  3.d
    //      Choose your preferred method and use it to retrieve the problem unit attributes and print them all to
    //      to the terminal.  Then fix the issue.

    std::string prefix;
    std::string id;
    double exponent;
    double multiplier;
    auto mV = model-&gt;units("mV");
    mV-&gt;unitAttributes("i_dont_exist", prefix, exponent, multiplier, id);
    std::cout &lt;&lt; "The units 'mV' child has attributes: base units = 'i_dont_exist', prefix = '"&lt;&lt; prefix &lt;&lt; "', exponent = "&lt;&lt;exponent&lt;&lt;", and multiplier = "&lt;&lt;multiplier &lt;&lt;std::endl;

    // Method 1:
    // mV-&gt;removeUnit("i_dont_exist");
    // mV-&gt;addUnit("volt", "milli");

    // Method 2:
    auto issue5 = validator-&gt;issue(5);
    assert(issue5-&gt;cellmlElementType() == libcellml::CellmlElementType::UNIT);
    auto issue5item = issue5-&gt;unit();
    issue5item-&gt;units()-&gt;removeUnit(issue5item-&gt;index());
    issue5item-&gt;units()-&gt;addUnit("volt", "milli");

    // Method 3:
    // auto missingUnits = libcellml::Units::create("i_dont_exist");
    // missingUnits-&gt;addUnit("volt", "milli");
    // model-&gt;addUnits(missingUnits); 

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.py" xml:space="preserve">    #  3.d
    #      Choose your preferred method and use it to retrieve the problem unit attributes and print them all to
    #      to the terminal.  Then fix the issue.
    prefix = ''
    id = ''
    exponent = 0.0
    multiplier = 0.0
    mV = model.units('mV')
    # prefix, exponent, multiplier, id = mV.unitAttributes('i_dont_exist')
    print(mV.unitAttributes('i_dont_exist'))
    print('The units \'mV\' child has attributes: base units = \'i_dont_exist\', prefix = \'{p}\', exponent = \'{e}\', and multiplier = \'{m}\'.'.format(p=prefix, e=exponent, m=multiplier))

    # Method 1:
    # mV.removeUnit('i_dont_exist')
    # mV.addUnit('volt', 'milli')

    # Method 2:
    issue7 = validator.issue(7)
    print('Issue 7 is a {}'.format(get_cellml_element_type_from_enum(issue7.cellmlElementType())))
    issue7_units = issue7.unit().units()
    issue7_units.removeUnit(issue7.unit().index())
    issue7_units.addUnit('volt', 'milli')

    # Method 3:
    # missing_units = Units('i_dont_exist')
    # missing_units.addUnit('volt', 'milli')
    # model.addUnits(missing_units) 

</literal_block>
            </container>
            <paragraph>The final validator issue refers to the fact that we need to explicitly specify how other components can access each of the variables in this component.</paragraph>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">Issue 9: Variable 't' in component 'sodiumChannelEquations' has no interface type set. The interface type required is 'public_and_private'.
    reference: 3.10.8
    see: https://cellml-specification.readthedocs.io/en/latest/reference/formal_and_informative/specC10.html?issue=3.10.8</literal_block>
            <container classes="dothis">
                <paragraph><strong>3.e</strong> Retrieve the variable either using the issue pointer method, or using the name method, and set its interface to be the required type.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.cpp" xml:space="preserve">    //  3.e
    //      Retrieve the variable either using the issue pointer method, or using the name method, and set its 
    //      interface to be the required type.
    auto issue7 = validator-&gt;issue(7);
    assert(issue7-&gt;cellmlElementType() == libcellml::CellmlElementType::VARIABLE);
    issue7-&gt;variable()-&gt;setInterfaceType("public_and_private");

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.py" xml:space="preserve">    #  3.e
    #      Retrieve the variable either using the issue pointer method, or using the name method, and set its 
    #      interface to be the required type.
    issue9 = validator.issue(9)
    issue9.variable().setInterfaceType('public_and_private')

</literal_block>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.f</strong> Revalidate the model and confirm that the errors have gone.</paragraph>
            </container>
            <container classes="useful">
                <paragraph><reference internal="False" refuri="https://libcellml.github.io/help/api/v0.2.0/classlibcellml_1_1Model">Model class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>component(“componentName”, true) will search for the component’s name in the whole of the encapsulation hierarchy.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><reference internal="False" refuri="https://libcellml.github.io/help/api/v0.2.0/classlibcellml_1_1Component">Component class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>addComponent</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Tutorial functions</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>printEncapsulation will output just the names of the components, nested in their encapsulation hierarchy.</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.g</strong> Even though the model is free from validation errors, we still need to make sure it represents what we want it to.
                    Print the model to the terminal and check its structure.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.h</strong> Use the addComponent functions to rearrange the components as needed until you have the required structure.
                    Validate the model again.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.cpp" xml:space="preserve">    //  3.g
    //      Even though the model is free from validation errors, we still need to make sure it
    //      represents what we want it to.  Print the model to the terminal and check its structure.
    printModel(model);

    //  3.h 
    //      Use the addComponent functions to rearrange the components as needed until you have the
    //      required structure.  Validate the model again.             
    auto importedGateM = model-&gt;component("importedGateM", true);
    auto mGateEquations = model-&gt;component("mGateEquations", true);
    auto mGate = model-&gt;component("mGate", true);
    mGateEquations-&gt;addComponent(importedGateM);
    mGate-&gt;addComponent(mGateEquations);

    validator-&gt;validateModel(model);
    printIssues(validator);
    printEncapsulation(model);

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.py" xml:space="preserve">    #  3.g
    #      Even though the model is free from validation errors, we still need to make sure it
    #      represents what we want it to.  Print the model to the terminal and check its structure.
    print_model(model)

    #  3.h 
    #      Use the addComponent functions to rearrange the components as needed until you have the
    #      required structure.  Validate the model again.             
    imported_gate_m = model.component('importedGateM', True)
    m_gate_equations = model.component('mGateEquations', True)
    m_gate = model.component('mGate', True)
    m_gate_equations.addComponent(imported_gate_m)
    m_gate.addComponent(m_gate_equations)

    validator.validateModel(model)
    print_issues(validator)
    print_encapsulation(model)

</literal_block>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">Model 'SodiumChannelModel' has 2 components
- Component 'controller' has 0 child components
- Component 'sodiumChannel' has 2 child components
    - Component 'sodiumChannelEquations' has 2 child components
        - Component 'mGate' has 2 child components
            - Component 'mGateParameters' has 0 child components
            - Component 'mGateEquations' has 1 child components
                - Component 'importedGateM' has 0 child components
        - Component 'hGate' has 2 child components
            - Component 'hGateParameters' has 0 child components
            - Component 'hGateEquations' has 1 child components
                - Component 'importedGateH' has 0 child components
    - Component 'sodiumChannelParameters' has 0 child components</literal_block>
        </section>
        <section ids="step-4-resolve-the-model-s-imports" names="step\ 4:\ resolve\ the\ model's\ imports">
            <title refid="id5">Step 4: Resolve the model’s imports</title>
            <paragraph>It’s important to remember that the imports are merely instructions for how components or units items should be located: only their syntax is checked by the validator, not that the files exist or contain the required information.  To debug the imported aspects of the model, we need to use an <literal classes="code">Importer</literal> class.</paragraph>
            <paragraph>To resolve the imports, we need a path to a base location against which any relative file addresses can be resolved.
                For this tutorial, the files are in the same directory as the code, so simply using an empty string is sufficient.</paragraph>
            <container classes="nb">
                <paragraph>If they’re another directory, make sure to end your path with a slash, “/”.
                    If they’re in your working directory, enter an empty string.</paragraph>
            </container>
            <container classes="useful">
                <paragraph><reference internal="False" refuri="https://libcellml.github.io/help/api/v0.2.0/classlibcellml_1_1Importer">Importer class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>create</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>resolveImports</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>4.a</strong> Create an <literal classes="code">Importer</literal> instance and use it to resolve the model.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>4.b</strong> Similarly to the validator, the importer will log any issues it encounters.
                    Retrieve these and print to the terminal (you can do this manually or using the convenience function as before).</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.cpp" xml:space="preserve">    //  4.a 
    //      Create an Importer instance and use it to resolve the model.
    auto importer = libcellml::Importer::create();
    importer-&gt;resolveImports(model, "");

    //  4.b 
    //      Similarly to the validator, the importer will log any issues it encounters.
    //      Retrieve these and print to the terminal (you can do this manually or using the
    //      convenience function as before).
    printIssues(importer);

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.py" xml:space="preserve">    #  4.a 
    #      Create an Importer instance and use it to resolve the model.
    importer = Importer()
    importer.resolveImports(model, '')

    #  4.b 
    #      Similarly to the validator, the importer will log any issues it encounters.
    #      Retrieve these and print to the terminal (you can do this manually or using the
    #      convenience function as before).
    print_issues(importer)

</literal_block>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">Recorded 2 issues:

Issue [0] is an ERROR:
    description: Import of component 'importedGateH' from 'GateModel.cellml' requires component named 'i_dont_exist' which cannot be found.
    stored item type: COMPONENT</literal_block>
            <paragraph>Fix the issues reported by the importer.
                This needs to be an iterative process because as more files become available to the importer, the content of those files needs to be checked too.</paragraph>
            <container classes="useful">
                <paragraph><reference internal="False" refuri="https://libcellml.github.io/help/api/v0.2.0/classlibcellml_1_1Component">Component class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>setImportReference</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>4.c</strong>
                    We need to change the import reference for the component to be “gateEquations” instead of “i_dont_exist”.
                    You can either retrieve the component using its name or directly from the item stored with the issue.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.cpp" xml:space="preserve">    //  4.c 
    //      Fix the issues reported by the importer.  This needs to be an iterative process as
    //      more files become available to the importer.
    auto issue0 = importer-&gt;issue(0);
    issue0-&gt;component()-&gt;setImportReference("gateEquations");

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.py" xml:space="preserve">    #  4.c 
    #      Fix the issues reported by the importer.  This needs to be an iterative process as
    #      more files become available to the importer.
    issue0 = importer.issue(0)
    issue0.component().setImportReference('gateEquations')

</literal_block>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">Issue [1] is a WARNING:
    description: Cyclic dependencies were found when attempting to resolve components in model 'CircularReferences'. The dependency loop is:
        - component 'importedGateH' is imported from 'i_dont_exist' in 'GateModel.cellml';
        - component 'importedGateM' is imported from 'gateEquations' in 'GateModel.cellml';
        - component 'controller' is imported from 'controller' in 'CircularControllerReference.cellml';
        - component 'controller' is imported from 'controller2' in 'CircularControllerReference2.cellml';
        - component 'controller2' is imported from 'controller' in 'CircularControllerReference.cellml'; and
        - component 'controller' is imported from 'controller2' in 'CircularControllerReference2.cellml'.
    stored item type: UNDEFINED</literal_block>
            <paragraph>To fix this, we have two options:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>to open and repair the file which is actually broken, or</paragraph>
                </list_item>
                <list_item>
                    <paragraph>to switch the import source in this current model to one which doesn’t have circular imports.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>It’s included here to highlight the fact that the <literal classes="code">Importer</literal> class opens and instantiates all required dependencies, and that some of those dependencies may have problems of their own … even issues in files that haven’t (yet) been seen at all by you, the user.</paragraph>
            <container classes="dothis">
                <paragraph><strong>4.d</strong> In this example we can change the import of the controller component to have url of ‘SodiumChannelController.cellml’.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>4.e</strong> Resolve the imports again and check that there are no further issues.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.cpp" xml:space="preserve">    //  4.d
    //      In this example we can change the import of the controller component to have url of
    //      'SodiumChannelController.cellml'.
    model-&gt;component("controller", true)-&gt;importSource()-&gt;setUrl("SodiumChannelController.cellml");

    //  4.e 
    //      Clear the current issues from the importer using the removeAllIssues function.
    //      Resolve the imports again and check that there are no further issues.
    importer-&gt;removeAllIssues();
    importer-&gt;resolveImports(model, "");
    printIssues(importer);

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.py" xml:space="preserve">    #  4.d
    #      In this example we can change the import of the controller component to have url of
    #      'SodiumChannelController.cellml'.
    model.component('controller', True).importSource().setUrl('SodiumChannelController.cellml')

    #  4.e 
    #      Clear all issues from the importer using the removeAllIssues() function.
    #      Resolve the imports again and check that there are no further issues.
    importer.removeAllIssues()
    importer.resolveImports(model, '')
    print_issues(importer)

</literal_block>
            </container>
        </section>
        <section ids="step-5-validate-the-imported-dependencies" names="step\ 5:\ validate\ the\ imported\ dependencies">
            <title refid="id6">Step 5: Validate the imported dependencies</title>
            <paragraph>At this stage we’ve validated the local model, and we’ve used the <literal classes="code">Importer</literal> class to retrieve all of its import dependencies.
                These dependencies are stored in the importer’s library, and have not yet been validated or analysed.</paragraph>
            <container classes="useful">
                <paragraph><reference internal="False" refuri="https://libcellml.github.io/help/api/v0.2.0/classlibcellml_1_1Importer">Importer class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>libraryCount returns the number of stored models;</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>library returns the model at the given index or given key string;</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>key returns a key string at the given index;</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>5.a</strong> Use a simple loop to validate each of the models stored in the importer’s library.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.cpp" xml:space="preserve">    //  5.a 
    //      Use a simple loop to validate each of the models stored in the importer's library.
    for(size_t i = 0; i &lt; importer-&gt;libraryCount(); ++i) {
        std::cout &lt;&lt; "Imported model at key: " &lt;&lt; importer-&gt;key(i) &lt;&lt; std::endl;
        validator-&gt;validateModel(importer-&gt;library(i));
        printIssues(validator);
    }
</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.py" xml:space="preserve">    #  5.a 
    #      Use a simple loop to validate each of the models stored in the importer's library.
    for i in range(0, importer.libraryCount()):
        print('Imported model at key: {}'.format(importer.key(i)))
        validator.validateModel(importer.library(i))
        print_issues(validator)
    
</literal_block>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">Imported model at key: CircularControllerReference.cellml
Recorded 0 issues!

Imported model at key: CircularControllerReference2.cellml
Recorded 0 issues!

Imported model at key: GateModel.cellml
Recorded 0 issues!

Imported model at key: SodiumChannelController.cellml
Recorded 0 issues!</literal_block>
            <paragraph>Note that the two files creating the circular import in 4.a are still in the library.
                To limit ourselves to only those models which are still relevant as the import dependencies of our repaired model, we can iterate through our model’s <literal classes="code">ImportSource</literal> items instead.
                As soon as the model’s imports have been resolved, all these will point to instantiated models within the importer.</paragraph>
            <container classes="useful">
                <paragraph><reference internal="False" refuri="https://libcellml.github.io/help/api/v0.2.0/classlibcellml_1_1Model">Model class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>importSourceCount</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>importSource</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><reference internal="False" refuri="https://libcellml.github.io/help/api/v0.2.0/classlibcellml_1_1ImportSource">ImportSource class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>model</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>url</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>5.b</strong> Loop through the model’s import source items and print their URLs to the terminal.
                    You’ll notice that these have been used as the keys in the importer library.
                    Check that the importer library’s models are the same as that attached to the import source item.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.cpp" xml:space="preserve">    //  5.b
    //      Loop through the model's import source items and print their urls to the terminal.
    //      You'll notice that these have been used as the keys in the importer library.
    //      Check that the importer library's models are the same as that attached to the
    //      import source item.
    for(size_t i = 0; i &lt; model-&gt;importSourceCount(); ++i) {
        std::cout &lt;&lt; "Import source [" &lt;&lt; i &lt;&lt; "]:" &lt;&lt; std::endl;
        std::cout &lt;&lt; "     url = " &lt;&lt; model-&gt;importSource(i)-&gt;url() &lt;&lt; std::endl;
        std::cout &lt;&lt; "     model = " &lt;&lt; model-&gt;importSource(i)-&gt;model()-&gt;name() &lt;&lt; std::endl;
        std::cout &lt;&lt; "     library[url] = " &lt;&lt; importer-&gt;library(model-&gt;importSource(i)-&gt;url())-&gt;name() &lt;&lt; std::endl;
    }

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.py" xml:space="preserve">    #  5.b
    #      Loop through the model's import source items and print their urls to the terminal.
    #      You'll notice that these have been used as the keys in the importer library.
    #      Check that the importer library's models are the same as that attached to the
    #      import source item.
    for i in range(0, model.importSourceCount()):
        print('Import source [{}]:'.format(i))
        print('     url = {}'.format(model.importSource(i).url()))
        print('     model = {}'.format(model.importSource(i).model()))
        print('     library[url] = {}'.format(importer.library(model.importSource(i).url())))

</literal_block>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">Import source [0]:
    url = GateModel.cellml
    model = 0x7ff61265b3f0
    library[url] = 0x7ff61265b3f0
Import source [1]:
    url = SodiumChannelController.cellml
    model = 0x7ff6141003c0
    library[url] = 0x7ff6141003c0</literal_block>
        </section>
        <section ids="step-6-analyse-the-model-s" names="step\ 6:\ analyse\ the\ model(s)">
            <title refid="id7">Step 6: Analyse the model(s)</title>
            <paragraph>As with the validator, the <literal classes="code">Analyser</literal> class is a diagnostic class which will check whether the mathematical representation is ready for simulation.
                This involves making sure that variables are contained in equations, that integrated variables have initial conditions, and that there are no over- or under-constrained sets of equations.
                Since this model uses imports, the real mathematical model is hidden from the <literal classes="code">Analyser</literal> (just as it was from the <literal classes="code">Validator</literal>).
                The way around this is to use the <literal classes="code">Importer</literal> class to create a flat (ie: import-free) version of the same model.
                If the flat model meets the analyser’s checks, then the importing version will too.</paragraph>
            <container classes="useful">
                <paragraph><reference internal="False" refuri="https://libcellml.github.io/help/api/v0.2.0/classlibcellml_1_1Analyser">Analyser class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>analyseModel</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>flattenModel</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>6.a</strong> Create an <literal classes="code">Analyser</literal> instance and pass in the model for analysis.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>6.b</strong> Retrieve and print the issues from the analysis to the screen.
                    We expect to see messages related to un-computed variables, since anything which is imported is missing from this model.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">Recorded 19 issues:
Issue [0] is an ERROR:
    description: Variable 'V' in component 'controller' is not computed.
    stored item type: VARIABLE
Issue [1] is an ERROR:
    description: Variable 't' in component 'controller' is not computed.
    stored item type: VARIABLE
Issue [2] is an ERROR:
    description: Variable 'alpha_h' in component 'hGateEquations' is not computed.
    stored item type: VARIABLE

... etc ...</literal_block>
            <container classes="dothis">
                <paragraph><strong>6.c</strong> Create a flattened version of the model print it to the screen.
                    Notice that any comments indicating that a component was an import have been removed as these components have been instantiated in the flattened model.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>6.d</strong> Analyse the flattened model and print the issues to the screen.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.cpp" xml:space="preserve">    //  6.a 
    //      Create an Analyser instance and pass in the model for analysis.
    //      Useful functions: Analyser::analyseModel(Model)
    auto analyser = libcellml::Analyser::create();
    analyser-&gt;analyseModel(model);

    //  6.b 
    //      Retrieve and print the issues from the analysis to the screen.  We expect to see 
    //      messages related to un-computed variables, since anything which is imported is 
    //      missing from this model.
    printIssues(analyser);

    //  6.c 
    //      Create a flattened version of the model print it to the screen.
    //      Notice that any comments indicating that a component was an import have been
    //      removed as these components have been instantiated in the flattened model.
    //      Useful functions:
    //          - Importer::flattenModel(Model) will return a flattened copy.
    auto flatModel = importer-&gt;flattenModel(model);
    printModel(flatModel);

    //  6.d 
    //      Analyse the flattened model and print the issues to the screen.
    analyser-&gt;analyseModel(flatModel);
    printIssues(analyser);

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.py" xml:space="preserve">    #  6.a 
    #      Create an Analyser instance and pass in the model for analysis.
    #      Useful functions: Analyser.analyseModel(Model)
    analyser = Analyser()
    analyser.analyseModel(model)

    #  6.b 
    #      Retrieve and print the issues from the analysis to the screen.  We expect to see 
    #      messages related to un-computed variables, since anything which is imported is 
    #      missing from this model.
    print_issues(analyser)

    print()
    #  6.c 
    #      Create a flattened version of the model print it to the screen.
    #      Notice that any comments indicating that a component was an import have been
    #      removed as these components have been instantiated in the flattened model.
    #      Useful functions:
    #          - Importer.flattenModel(Model) will return a flattened copy.
    flat_model = importer.flattenModel(model)
    print_model(flat_model)

    #  6.d 
    #      Analyse the flattened model and print the issues to the screen.
    analyser.analyseModel(flat_model)
    print_issues(analyser)

</literal_block>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">Issue [0] is an ERROR:
    description: Variable 't' in component 'importedGateM' and variable 't' in component
             'importedGateH' cannot both be the variable of integration.
    stored item type: VARIABLE</literal_block>
            <paragraph>The issue returned from the analyser says that we’re trying to use two different variables as the base variable of integration, and the CellML code generation facility (which the analyser is tied to) does not support this yet.
                It’s still valid CellML though!
                In this example, the real problem is that these two variables are talking about the same thing, but haven’t been connected to one another yet.</paragraph>
            <container classes="useful">
                <paragraph><reference internal="False" refuri="https://libcellml.github.io/help/api/v0.2.0/classlibcellml_1_1Variable">Variable class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>addEquivalence</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>6.e</strong> Create any necessary variable equivalences so that these two variables are connected.
                    You can refer to your printout of the model’s structure to help if need be, and remember that only variables in a sibling or parent/child relationship can be connected.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>6.f</strong> Re-flatten and re-analyse the model and print the issues to the terminal.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.cpp" xml:space="preserve">    //  6.e 
    //      Create any necessary variable equivalences so that these two variables are connected. You
    //      can refer to your printout of the model's structure to help if need be, and remember that only
    //      variables in a sibling or parent/child relationship can be connected.
    //      Useful function: Variable::addEquivalence(v1, v2) will create an equivalence between the 
    //                       variables v1 and v2.

    libcellml::Variable::addEquivalence(model-&gt;component("importedGateM", true)-&gt;variable("t"), 
                                        model-&gt;component("mGateEquations", true)-&gt;variable("t"));
    libcellml::Variable::addEquivalence(model-&gt;component("mGate", true)-&gt;variable("t"), 
                                        model-&gt;component("mGateEquations", true)-&gt;variable("t"));

    //  6.f Reflatten and re-analyse the model and print the issues to the terminal.
    analyser-&gt;analyseModel(importer-&gt;flattenModel(model));
    printIssues(analyser);

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.py" xml:space="preserve">    #  6.e 
    #      Create any necessary variable equivalences so that these two variables are connected. You
    #      can refer to your printout of the model's structure to help if need be, and remember that only
    #      variables in a sibling or parent/child relationship can be connected.
    #      Useful function: Variable.addEquivalence(v1, v2) will create an equivalence between the 
    #                       variables v1 and v2.

    Variable.addEquivalence(model.component('importedGateM', True).variable('t'), 
                                        model.component('mGateEquations', True).variable('t'))
    Variable.addEquivalence(model.component('mGate', True).variable('t'), 
                                        model.component('mGateEquations', True).variable('t'))

    #  6.f Re-flatten and re-analyse the model and print the issues to the terminal.
    analyser.analyseModel(importer.flattenModel(model))
    print_issues(analyser)

</literal_block>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">Recorded 13 issues:
Issue [0] is an ERROR:
    description: Variable 'X' in component 'importedGateM' is used in an ODE, but it is not initialised.
    stored item type: VARIABLE
Issue [1] is an ERROR:
    description: Variable 'alpha_X' in component 'importedGateM' is not computed.
    stored item type: VARIABLE</literal_block>
            <paragraph>Now we see the importance of checking iteratively for issues in the analyser class.
                The nature of this class means that frequently it is unable to continue processing when an issue is encountered.
                It’s not unusual to fix one issue only to find twenty more!
                Two of the errors reported deal with non-initialised variables.
                Looking at the model printout we can see that this is because the integrated variable “X” (in both the imported gates) hasn’t been connected to its local variable “h” or “m” in the appropriate parameters component.</paragraph>
            <container classes="dothis">
                <paragraph><strong>6.g</strong> Create all required connections needed to connect these variables.
                    Re-flatten, re-analyse and print the issues to the terminal.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.cpp" xml:space="preserve">    //  6.g
    //      Create all required connections needed to connect these variables.
    //      Re-flatten, re-analyse and print the issues to the terminal.
    libcellml::Variable::addEquivalence(model-&gt;component("importedGateM", true)-&gt;variable("X"), 
                                        model-&gt;component("mGateEquations", true)-&gt;variable("m"));
    libcellml::Variable::addEquivalence(model-&gt;component("mGateParameters", true)-&gt;variable("m"), 
                                        model-&gt;component("mGateEquations", true)-&gt;variable("m"));
    libcellml::Variable::addEquivalence(model-&gt;component("importedGateH", true)-&gt;variable("X"), 
                                        model-&gt;component("hGateEquations", true)-&gt;variable("h"));
    libcellml::Variable::addEquivalence(model-&gt;component("hGateParameters", true)-&gt;variable("h"), 
                                        model-&gt;component("hGateEquations", true)-&gt;variable("h"));                                    
    analyser-&gt;analyseModel(importer-&gt;flattenModel(model));
    printIssues(analyser);

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.py" xml:space="preserve">    #  6.g
    #      Create all required connections needed to connect these variables.
    #      Re-flatten, re-analyse and print the issues to the terminal.
    Variable.addEquivalence(model.component('importedGateM', True).variable('X'), 
                                        model.component('mGateEquations', True).variable('m'))
    Variable.addEquivalence(model.component('mGateParameters', True).variable('m'), 
                                        model.component('mGateEquations', True).variable('m'))
    Variable.addEquivalence(model.component('importedGateH', True).variable('X'), 
                                        model.component('hGateEquations', True).variable('h'))
    Variable.addEquivalence(model.component('hGateParameters', True).variable('h'), 
                                        model.component('hGateEquations', True).variable('h'))                                    
    analyser.analyseModel(importer.flattenModel(model))
    print_issues(analyser)

</literal_block>
            </container>
            <paragraph>The nice thing about issues in this class is that frequently a few issues refer to the same single problem.
                The remainder of the issues reported deal with variables that are not computed.
                This could mean any one of:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=")">
                <list_item>
                    <paragraph>the variable is not included in any equations (it’s completely unused);</paragraph>
                </list_item>
                <list_item>
                    <paragraph>the variable is included in an equation, but the equation can’t be evaluated (contains some other un-computed variable(s));</paragraph>
                </list_item>
                <list_item>
                    <paragraph>the variable is a constant that should have a value assigned; or</paragraph>
                </list_item>
                <list_item>
                    <paragraph>the variable hasn’t been connected to the rest of its definition (usually it’s this one!).</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>Because the “is not computed” errors are cascading by nature, frequently fixing just one will resolve many others.</paragraph>
            <container classes="useful">
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>C++: printEquivalentVariableSet with the variable argument</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Python: print_equivalent_variable_set with the variable argument</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <paragraph>Hints for this tutorial:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>There is at least one of each kind of problem;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>There’s a convenience function provided (see below) which will print the equivalent variable set for a given variable.
                        You can use the item stored by each issue and this function to check for missing connections.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>the <literal classes="code">addEquivalence</literal> function returns a boolean indicating success or otherwise.
                        If you check this as you go it will alert you quickly if you’re trying to connect to a variable that’s not found.</paragraph>
                </list_item>
            </bullet_list>
            <container classes="dothis">
                <paragraph><strong>6.h</strong> From the printout of your model and the issues listed, determine what needs to happen in order to make the model viable, and do it.
                    Check that your final analysis contains no issues.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.cpp" xml:space="preserve">    //  6.h
    //      From the printout of your model and the issues listed, determine what needs to happen in 
    //      order to make the model viable, and do it.  Check that your final analysis contains no issues.

    // Connect the mGate to its surroundings.
    libcellml::Variable::addEquivalence(model-&gt;component("importedGateM", true)-&gt;variable("alpha_X"), 
                                        model-&gt;component("mGateEquations", true)-&gt;variable("alpha_m"));
    libcellml::Variable::addEquivalence(model-&gt;component("importedGateM", true)-&gt;variable("beta_X"), 
                                        model-&gt;component("mGateEquations", true)-&gt;variable("beta_m"));
    libcellml::Variable::addEquivalence(model-&gt;component("mGate", true)-&gt;variable("V"), 
                                        model-&gt;component("mGateEquations", true)-&gt;variable("V"));
    libcellml::Variable::addEquivalence(model-&gt;component("mGate", true)-&gt;variable("m"), 
                                        model-&gt;component("mGateEquations", true)-&gt;variable("m"));

    // E_Na in sodiumChannelParameters needs to be initialised to 40.
    model-&gt;component("sodiumChannelParameters", true)-&gt;variable("E_Na")-&gt;setInitialValue(40);

    // i_am_redundant in mGateParameters is not required.
    model-&gt;component("mGateParameters", true)-&gt;removeVariable("i_am_redundant");

    analyser-&gt;analyseModel(importer-&gt;flattenModel(model));
    printIssues(analyser);

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.py" xml:space="preserve">    #  6.h
    #      From the printout of your model and the issues listed, determine what needs to happen in 
    #      order to make the model viable, and do it.  Check that your final analysis contains no issues.

    # Connect the m_gate to its surroundings.
    Variable.addEquivalence(model.component('importedGateM', True).variable('alpha_X'), 
                                        model.component('mGateEquations', True).variable('alpha_m'))
    Variable.addEquivalence(model.component('importedGateM', True).variable('beta_X'), 
                                        model.component('mGateEquations', True).variable('beta_m'))
    Variable.addEquivalence(model.component('mGate', True).variable('V'), 
                                        model.component('mGateEquations', True).variable('V'))
    Variable.addEquivalence(model.component('mGate', True).variable('m'), 
                                        model.component('mGateEquations', True).variable('m'))

    # E_Na in sodiumChannelParameters needs to be initialised to 40.
    model.component('sodiumChannelParameters', True).variable('E_Na').setInitialValue(40)

    # i_am_redundant in m_gateParameters is not required.
    model.component('mGateParameters', True).removeVariable('i_am_redundant')

    analyser.analyseModel(importer.flattenModel(model))
    print_issues(analyser)

</literal_block>
            </container>
        </section>
        <section ids="step-7-serialise-and-print-the-repaired-model" names="step\ 7:\ serialise\ and\ print\ the\ repaired\ model">
            <title refid="id8">Step 7: Serialise and print the repaired model</title>
            <container classes="dothis">
                <paragraph><strong>7.a</strong> Create a <literal classes="code">Printer</literal> instance and use it to print the CellML-formatted version of the repaired model to a string.
                    Remember we’ll still be printing the original version of the model, not the flattened one!</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>7.b</strong> Write the string to a file named “SodiumChannelModel.cellml”; you will use this in <reference internal="True" refuri="../tut4/index#generatemembranemodel"><inline classes="std std-ref">Tutorial 4</inline></reference>.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.cpp" xml:space="preserve">    //  7.a 
    //      Create a Printer instance and use it to print the CellML-formatted version of
    //      the repaired model to a string.  Remember we'll still be printing the original
    //      version of the model, not the flattened one!
    auto printer = libcellml::Printer::create();
    auto modelString = printer-&gt;printModel(model);

    //  7.b 
    //      Write the string to a file named "SodiumChannelModel.cellml".
    std::ofstream outFile("SodiumChannelModel.cellml");
    outFile &lt;&lt; modelString;
    outFile.close();

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorials/tut3/debugSodiumChannelModel_completed.py" xml:space="preserve">    #  7.a 
    #      Create a Printer instance and use it to print the CellML-formatted version of
    #      the repaired model to a string.  Remember we'll still be printing the original
    #      version of the model, not the flattened one!
    printer = Printer()
    printed_model_string = printer.printModel(model)
    
    #  7.b 
    #      Write the string to a file named 'SodiumChannelModel.cellml'.
    write_file = open('SodiumChannelModel.cellml', 'w')
    write_file.write(printed_model_string)
    write_file.close()

</literal_block>
            </container>
        </section>
    </section>
</document>
