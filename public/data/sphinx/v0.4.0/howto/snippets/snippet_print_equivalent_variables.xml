<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.16 -->
<document source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/snippets/snippet_print_equivalent_variables.rst">
    <target refid="snippet-print-equivalent-variables"></target>
    <container classes="toggle" ids="snippet-print-equivalent-variables" names="snippet_print_equivalent_variables">
        <container classes="header-left">
            <paragraph>Trace equivalent variables</paragraph>
        </container>
        <paragraph>This example traces variable equivalences throughout the model using recursion.
            The CellML file read contains a model as shown below, where two pairs of equivalent variables (<literal classes="code">A</literal> to <literal classes="code">B</literal>, and <literal classes="code">B</literal> to <literal classes="code">C</literal>) connect three variables together.</paragraph>
        <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">model:
    ├─ component: componentA
    │   └─ variable: A [dimensionless] &lt;╴╴╴╮
    │                                      ╷
    │                                  equivalent
    ├─ component: componentB               ╵
    │   └─ variable: B [dimensionless] &lt;╴╴╴╯&lt;╴╴╴╮
    │                                           ╷
    │                                       equivalent
    └─ component: componentC                    ╵
        └─ variable: C [dimensionless] &lt;╴╴╴╴╴╴╴╴╯</literal_block>
        <container classes="toggle">
            <container classes="header">
                <paragraph>Show CellML syntax</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="xml" linenos="False" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
  &lt;model xmlns="http://www.cellml.org/cellml/2.0#"
    xmlns:cellml="http://www.cellml.org/cellml/2.0#" name="quickstart_traceEquivalence"&gt;
    &lt;component name="componentA"&gt;
      &lt;variable units="dimensionless" name="A" interface="public" /&gt;
    &lt;/component&gt;
    &lt;component name="componentB"&gt;
      &lt;variable units="dimensionless" name="B" interface="public" /&gt;
    &lt;/component&gt;
    &lt;component name="componentC"&gt;
      &lt;variable units="dimensionless" name="C" interface="public" /&gt;
    &lt;/component&gt;
    &lt;connection component_1="componentA" component_2="componentB"&gt;
      &lt;map_variables variable_1="A" variable_2="B"/&gt;
    &lt;/connection&gt;
    &lt;connection component_1="componentB" component_2="componentC"&gt;
      &lt;map_variables variable_1="B" variable_2="C"/&gt;
    &lt;/connection&gt;
  &lt;/model&gt;</literal_block>
        </container>
        <paragraph>The example should output the connections between the variables, including discerning that <literal classes="code">A</literal> is connected to <literal classes="code">C</literal>, even though no direct relationship is specified in the model.</paragraph>
        <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">Variable 'A' in component 'componentA' is connected to:
 - variable 'B' [dimensionless] in component 'componentB'
 - variable 'C' [dimensionless] in component 'componentC'</literal_block>
        <container classes="sphinx-tabs">
            <container classes="dummy">
                <container classes="item">
                    <container classes="dummy">
                        <paragraph>C++</paragraph>
                    </container>
                </container>
                <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                </container>
                <literal_block force="False" highlight_args="{}" language="c++" linenos="False" xml:space="preserve">// Function to initiate a list of variables in the connected set, to start the recursion, and to print
// the list to the terminal.
void printEquivalentVariableSet(const libcellml::VariablePtr &amp;variable)
{
    if (variable == nullptr) {
        std::cout &lt;&lt; "NULL variable submitted to printEquivalentVariableSet." &lt;&lt; std::endl;
        return;
    }
    std::vector&lt;libcellml::VariablePtr&gt; variableList;
    variableList.push_back(variable);
    listEquivalentVariables(variable, variableList);

    // The parent() function returns an EntityPtr, which must be cast to a Component before its name()
    // function can be called.
    libcellml::ComponentPtr component = std::dynamic_pointer_cast&lt;libcellml::Component&gt;(variable-&gt;parent());

    if (component != nullptr) {
        std::cout &lt;&lt; "Tracing: " &lt;&lt; component-&gt;name() &lt;&lt; " -&gt; "
                  &lt;&lt; variable-&gt;name();
        if (variable-&gt;units() != nullptr) {
            std::cout &lt;&lt; " [" &lt;&lt; variable-&gt;units()-&gt;name() &lt;&lt; "]";
        }
        if (variable-&gt;initialValue() != "") {
            std::cout &lt;&lt; ", initial = " &lt;&lt; variable-&gt;initialValue();
        }
        std::cout &lt;&lt; std::endl;
    }

    // The variableList contains the variable that was submitted for testing originally, so
    // if it's connected to other variables, it must have a length greater than 1.
    if (variableList.size() &gt; 1) {
        for (auto &amp;e : variableList) {
            component = std::dynamic_pointer_cast&lt;libcellml::Component&gt;(e-&gt;parent());
            if (component != nullptr) {
                std::cout &lt;&lt; "    - " &lt;&lt; component-&gt;name() &lt;&lt; " -&gt; " &lt;&lt; e-&gt;name();
                if (e-&gt;units() != nullptr) {
                    std::cout &lt;&lt; " [" &lt;&lt; e-&gt;units()-&gt;name() &lt;&lt; "]";
                }
                if (e-&gt;initialValue() != "") {
                    std::cout &lt;&lt; ", initial = " &lt;&lt; e-&gt;initialValue();
                }
                std::cout &lt;&lt; std::endl;
            } else {
                std::cout &lt;&lt; "Variable " &lt;&lt; e-&gt;name() &lt;&lt; " does not have a parent component." &lt;&lt; std::endl;
            }
        }
    } else {
        std::cout &lt;&lt; "    - Not connected to any equivalent variables." &lt;&lt; std::endl;
    }
}

// This function performs the recursive search through all connections until the set
// has been completely covered.
void listEquivalentVariables(const libcellml::VariablePtr &amp;variable,
                             std::vector&lt;libcellml::VariablePtr&gt; &amp;variableList) {
    if (variable == nullptr) {
        return;
    }

    for (size_t i = 0; i &lt; variable-&gt;equivalentVariableCount(); ++i) {
        libcellml::VariablePtr equivalentVariable = variable-&gt;equivalentVariable(i);
        if (std::find(variableList.begin(), variableList.end(), equivalentVariable) == variableList.end()) {
            variableList.push_back(equivalentVariable);
            listEquivalentVariables(equivalentVariable, variableList);
        }
    }
}</literal_block>
            </container>
            <container classes="dummy">
                <container classes="item">
                    <container classes="dummy">
                        <paragraph>Python</paragraph>
                    </container>
                </container>
                <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                </container>
                <literal_block force="False" highlight_args="{}" language="py" linenos="False" xml:space="preserve">from libcellml import Parser

# This function will initialise the information strings to test, start
# the search, and print the results.
def print_equivalent_variable_set(variable):

    if variable is None:
        print("None variable submitted to print_equivalent_variable_set.")
        return

    variable_list = list()
    variable_list.append([variable.name(),
                         variable.parent().name(),
                         variable.units().name(),
                         variable.initialValue()])
    list_equivalent_variables(variable, variable_list)

    if len(variable_list) &gt; 1:
        print("Variable '{v}' in component '{c}' is connected to:".format(
            v=variable.name(), c=variable.parent().name()))
        for e in variable_list[1:]:
            if e[3] != '':
                print(" - variable '{v}'(t=0)={i} [{u}] in component '{c}'".format(
                    v=e[0], i=e[3], u=e[2], c=e[1]))
            else:
                print(" - variable '{v}' [{u}] in component '{c}'".format(
                    v=e[0], u=e[2], c=e[1]))
    else:
        print("Variable '{v}' is not connected to other variables.".format(
            v=variable.name()))

# This function performs the recursive search through all connections until the set
# has been completely covered.
def list_equivalent_variables(variable, variable_list):
    if variable is None:
        return
    for i in range(0, variable.equivalentVariableCount()):
        equivalent_variable = variable.equivalentVariable(i)
        # Form a list of strings that describe the equivalent variable.
        test = [equivalent_variable.name(),
                equivalent_variable.parent().name(),
                equivalent_variable.units().name(),
                equivalent_variable.initialValue()]
        # If the equivalent variable has not already been checked, then start another recursion.
        if test not in variable_list:
            variable_list.append(test)
            list_equivalent_variables(equivalent_variable, variable_list)


if __name__ == "__main__":

    read_file = open("../resources/quickstart_traceEquivalence.cellml", "r")

    #  Create a parser and read the file.
    parser = Parser()
    model = parser.parseModel(read_file.read())

    # Retrieve a variable from the parsed model
    A = model.component("componentA").variable("A")

    # Initiate the tracing for equivalent variables of variable "A"
    print_equivalent_variable_set(A)</literal_block>
            </container>
        </container>
    </container>
</document>
