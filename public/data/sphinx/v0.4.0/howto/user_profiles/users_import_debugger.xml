<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.16 -->
<document source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/user_profiles/users_import_debugger.rst">
    <target refid="users-import-debugger"></target>
    <section ids="import-debugger users-import-debugger" names="import\ debugger users_import_debugger">
        <title>Import debugger</title>
        <paragraph>This example walks through the processes involved with debugging models using the <literal classes="code">Importer</literal> class in conjunction with the diagnostic classes, <literal classes="code">Validator</literal> and <literal classes="code">Analyser</literal>.
            For more general debugging use cases, please see the <reference internal="True" refuri="users_model_debugger#users-model-debugger"><inline classes="std std-ref">Model debugger</inline></reference> example instead.</paragraph>
        <paragraph><strong>Contents</strong></paragraph>
        <topic classes="contents local" ids="contents" names="contents">
            <bullet_list>
                <list_item>
                    <paragraph><reference ids="id1" refid="parse-an-existing-cellml-model">Parse an existing CellML model</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id2" refid="create-an-importer-and-resolve-the-model-s-imports">Create an Importer and resolve the model’s imports</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id3" refid="validate-and-analyse-the-model">Validate and analyse the model</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id4" refid="validate-the-import-dependencies">Validate the import dependencies</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id5" refid="fix-the-errors-in-the-imported-model">Fix the errors in the imported model</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id6" refid="analyse-the-import-dependencies">Analyse the import dependencies</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id7" refid="output-the-repaired-models-to-cellml-files">Output the repaired models to CellML files</reference></paragraph>
                </list_item>
            </bullet_list>
        </topic>
        <line_block>
            <line><strong>C++ resources</strong></line>
            <line_block>
                <line>├ <download_reference filename="4df241b294a8e6362ad7c78bcffa1b81/CMakeLists.txt" refdoc="howto/user_profiles/users_import_debugger" refdomain="" refexplicit="True" reftarget="../code/import_debugger/CMakeLists.txt" reftype="download" refwarn="False"><literal classes="xref download">CMakeLists.txt</literal></download_reference></line>
                <line>├ <download_reference filename="fbd619b75e45a40d8defb9ee31588e95/importDebugger.cpp" refdoc="howto/user_profiles/users_import_debugger" refdomain="" refexplicit="True" reftarget="../code/import_debugger/importDebugger.cpp" reftype="download" refwarn="False"><literal classes="xref download">example_importDebugger.cpp</literal></download_reference></line>
                <line>└ resources/</line>
                <line_block>
                    <line>├ <download_reference filename="3c6e108b5a1940ba9c1d447828085d90/importExample1.cellml" refdoc="howto/user_profiles/users_import_debugger" refdomain="" refexplicit="True" reftarget="../code/import_debugger/resources/importExample1.cellml" reftype="download" refwarn="False"><literal classes="xref download">importerExample1.cellml</literal></download_reference></line>
                    <line>├ <download_reference filename="875fece694fe45874926c8aff496a9a0/importExample2a.cellml" refdoc="howto/user_profiles/users_import_debugger" refdomain="" refexplicit="True" reftarget="../code/import_debugger/resources/importExample2a.cellml" reftype="download" refwarn="False"><literal classes="xref download">importerExample2a.cellml</literal></download_reference></line>
                    <line>├ <download_reference filename="1af6d01da250974033b5b75521919f79/importExample2b.cellml" refdoc="howto/user_profiles/users_import_debugger" refdomain="" refexplicit="True" reftarget="../code/import_debugger/resources/importExample2b.cellml" reftype="download" refwarn="False"><literal classes="xref download">importerExample2b.cellml</literal></download_reference></line>
                    <line>└ <download_reference filename="512156d8e943aafb21148847a26b0c8f/importExample3.cellml" refdoc="howto/user_profiles/users_import_debugger" refdomain="" refexplicit="True" reftarget="../code/import_debugger/resources/importExample3.cellml" reftype="download" refwarn="False"><literal classes="xref download">importerExample3.cellml</literal></download_reference></line>
                </line_block>
            </line_block>
        </line_block>
        <line_block>
            <line><strong>Python resources</strong></line>
            <line_block>
                <line>├ <download_reference filename="3bc26c649245addbbb6cf2cf2590c4a8/importDebugger.py" refdoc="howto/user_profiles/users_import_debugger" refdomain="" refexplicit="True" reftarget="../code/import_debugger/importDebugger.py" reftype="download" refwarn="False"><literal classes="xref download">example_importDebugger.py</literal></download_reference></line>
                <line>└ resources/</line>
                <line_block>
                    <line>├ <download_reference filename="3c6e108b5a1940ba9c1d447828085d90/importExample1.cellml" refdoc="howto/user_profiles/users_import_debugger" refdomain="" refexplicit="True" reftarget="../code/import_debugger/resources/importExample1.cellml" reftype="download" refwarn="False"><literal classes="xref download">importerExample1.cellml</literal></download_reference></line>
                    <line>├ <download_reference filename="875fece694fe45874926c8aff496a9a0/importExample2a.cellml" refdoc="howto/user_profiles/users_import_debugger" refdomain="" refexplicit="True" reftarget="../code/import_debugger/resources/importExample2a.cellml" reftype="download" refwarn="False"><literal classes="xref download">importerExample2a.cellml</literal></download_reference></line>
                    <line>├ <download_reference filename="1af6d01da250974033b5b75521919f79/importExample2b.cellml" refdoc="howto/user_profiles/users_import_debugger" refdomain="" refexplicit="True" reftarget="../code/import_debugger/resources/importExample2b.cellml" reftype="download" refwarn="False"><literal classes="xref download">importerExample2b.cellml</literal></download_reference></line>
                    <line>└ <download_reference filename="512156d8e943aafb21148847a26b0c8f/importExample3.cellml" refdoc="howto/user_profiles/users_import_debugger" refdomain="" refexplicit="True" reftarget="../code/import_debugger/resources/importExample3.cellml" reftype="download" refwarn="False"><literal classes="xref download">importerExample3.cellml</literal></download_reference></line>
                </line_block>
            </line_block>
        </line_block>
        <section ids="parse-an-existing-cellml-model" names="parse\ an\ existing\ cellml\ model">
            <title refid="id1">Parse an existing CellML model</title>
            <paragraph>The first step is to parse and instantiate a model from a CellML file.
                Here we use the <literal classes="code">Parser</literal> class to read the file, and deserialise the CellML into a <literal classes="code">Model</literal> object.</paragraph>
            <container classes="sphinx-tabs">
                <container classes="dummy">
                    <container classes="item">
                        <container classes="dummy">
                            <paragraph>C++</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-0-0 active">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/import_debugger/importDebugger.cpp" xml:space="preserve">    // Read the file contents into a string.
    std::string inFileName = "resources/importExample1.cellml";
    std::ifstream inFile(inFileName);
    std::stringstream inFileContents;
    inFileContents &lt;&lt; inFile.rdbuf();

    // Create a Parser and use it to deserialise the string into a model.
    auto parser = libcellml::Parser::create();
    auto originalModel = parser-&gt;parseModel(inFileContents.str());
    printIssues(parser);

    // end 1
    std::cout &lt;&lt; "--------------------------------------------------------" &lt;&lt; std::endl;
    std::cout &lt;&lt; "  STEP 2: Create an Importer instance                   " &lt;&lt; std::endl;
    std::cout &lt;&lt; "--------------------------------------------------------" &lt;&lt; std::endl;

</literal_block>
                    </container>
                </container>
                <container classes="dummy">
                    <container classes="item">
                        <container classes="dummy">
                            <paragraph>Python</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-0-1">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/import_debugger/importDebugger.py" xml:space="preserve">    # Parse an existing CellML model from a file.
    read_file = open('resources/importExample1.cellml', 'r')
    parser = Parser()
    original_model = parser.parseModel(read_file.read())

</literal_block>
                    </container>
                </container>
            </container>
        </section>
        <section ids="create-an-importer-and-resolve-the-model-s-imports" names="create\ an\ importer\ and\ resolve\ the\ model's\ imports">
            <title refid="id2">Create an Importer and resolve the model’s imports</title>
            <paragraph>The <literal classes="code">Importer</literal> class is a utility which can be used to handle models which import components or units from other models.
                Passing the model and a base directory location will enable the <literal classes="code">Importer</literal> to resolve any imports required by the model, and add those dependencies to the importer’s internal library.
                Since the <literal classes="code">Importer</literal> class contains a logger, we can check that the process has completed properly by printing any issues inside the importer to the terminal.</paragraph>
            <container classes="sphinx-tabs">
                <container classes="dummy">
                    <container classes="item">
                        <container classes="dummy">
                            <paragraph>C++</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-1-0 active">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/import_debugger/importDebugger.cpp" xml:space="preserve">    // Create the importer instance.
    auto importer = libcellml::Importer::create();

    // Resolve the imports.
    importer-&gt;resolveImports(originalModel, "resources/");

    // Check for issues.
    std::cout &lt;&lt; std::endl;
    std::cout &lt;&lt; "The importer found " &lt;&lt; importer-&gt;issueCount() &lt;&lt; " issues." &lt;&lt; std::endl;
    for(size_t i = 0; i &lt; importer-&gt;issueCount(); ++i) {
        auto issue = importer-&gt;issue(i);
        std::cout &lt;&lt; issue-&gt;description() &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; std::endl;

    // Fix the circular reference issue by setting the URL for sideB to be importExample3.cellml
    // instead of circularImport1.cellml.  The model can be accessed from the importer's library - 
    // you don't have to parse it yourself.
    auto modelToRepair = importer-&gt;library("resources/importExample2b.cellml");

    // Clear the imports from the model to repair.
    importer-&gt;clearImports(modelToRepair);

    // Fix the URL.
    modelToRepair-&gt;component("sideB")-&gt;importSource()-&gt;setUrl("importExample3.cellml");

    // Recheck the importer. You will need to clear previous issues first.
    importer-&gt;removeAllIssues();
    importer-&gt;resolveImports(originalModel,"resources/");

    // Check that the import circular dependence has been removed.
    std::cout &lt;&lt; std::endl;
    std::cout &lt;&lt; "The importer found " &lt;&lt; importer-&gt;issueCount() &lt;&lt; " issues." &lt;&lt; std::endl;
    for(size_t i = 0; i &lt; importer-&gt;issueCount(); ++i) {
        auto issue = importer-&gt;issue(i);
        std::cout &lt;&lt; issue-&gt;description() &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; std::endl;

    // end 2
    std::cout &lt;&lt; "--------------------------------------------------------" &lt;&lt; std::endl;
    std::cout &lt;&lt; "  STEP 3: Flatten the model and use diagnostic tools    " &lt;&lt; std::endl;
    std::cout &lt;&lt; "--------------------------------------------------------" &lt;&lt; std::endl;

</literal_block>
                    </container>
                </container>
                <container classes="dummy">
                    <container classes="item">
                        <container classes="dummy">
                            <paragraph>Python</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-1-1">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/import_debugger/importDebugger.py" xml:space="preserve">    # Create an Importer to resolve the imports in the model.
    importer = Importer()

    # Resolve the imports.
    importer.resolveImports(original_model, 'resources/')

    # Check for issues.
    print('The importer found {} issues.'.format(importer.issueCount()))
    for i in range(0,importer.issueCount()):
        print(importer.issue(i).description())
    print()

</literal_block>
                    </container>
                </container>
            </container>
            <paragraph>The code above prints to the terminal:</paragraph>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">The importer found 0 issues.</literal_block>
        </section>
        <section ids="validate-and-analyse-the-model" names="validate\ and\ analyse\ the\ model">
            <title refid="id3">Validate and analyse the model</title>
            <paragraph>The analysis tools - the <literal classes="code">Validator</literal> and <literal classes="code">Analyser</literal> - will read only the highest level of the model they are given; they do not look into any of the imported items, so they can’t check them.
                In order to retain the import structure but be able to use the diagnostic tools, we can create a flattened copy of the model for testing.
                This can be used to identify mistakes in the original version of the model.</paragraph>
            <container classes="sphinx-tabs">
                <container classes="dummy">
                    <container classes="item">
                        <container classes="dummy">
                            <paragraph>C++</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-2-0 active">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/import_debugger/importDebugger.cpp" xml:space="preserve">    // The analysis tools - the Validator and Analyser - will read only the submitted
    // model; they do not look into any of the imported items, so they can't check them.
    // In order to retain the import structure but be able to use the diagnostic tools, 
    // we can either:
    //  - create a flattened copy of the model for testing, which can be used to
    //    identify mistakes in the unflattened model too; or
    //  - make use of the Importer's library to iterate through all of the model's 
    //    imported dependencies, and check them individually.

    // Create a Validator and Analyser and submit the original, unflattened model.
    // We don't expect either of these to report any issues because all of the mistakes are
    // in imported models which are not read by these classes.
    auto validator = libcellml::Validator::create();
    validator-&gt;validateModel(originalModel);

    std::cout &lt;&lt; "Investigating the original model:" &lt;&lt; std::endl;
    std::cout &lt;&lt; " - the validator found " &lt;&lt; validator-&gt;issueCount() &lt;&lt; " issues." &lt;&lt; std::endl;
    for(size_t i = 0; i &lt; validator-&gt;issueCount(); ++i) {
        std::cout &lt;&lt; "    - " &lt;&lt; validator-&gt;issue(i)-&gt;description() &lt;&lt; std::endl;
    }

    auto analyser = libcellml::Analyser::create();
    analyser-&gt;analyseModel(originalModel);
    std::cout &lt;&lt; " - the analyser found " &lt;&lt; analyser-&gt;issueCount() &lt;&lt; " issues." &lt;&lt; std::endl;
    for(size_t i = 0; i &lt; analyser-&gt;issueCount(); ++i) {
        std::cout &lt;&lt; "    - " &lt;&lt; analyser-&gt;issue(i)-&gt;description() &lt;&lt; std::endl;
    }

    // Create a flattened version to demonstrate the diagnostics.
    auto flatModel = importer-&gt;flattenModel(originalModel);
 
    // Repeat the validation and analysis above on the flattened model, noting that the 
    // flat model contains errors that were hidden in the original one.
    validator-&gt;validateModel(flatModel);
    std::cout &lt;&lt; std::endl &lt;&lt; "Investigating the flattened model:" &lt;&lt; std::endl;
    std::cout &lt;&lt; "The validator found " &lt;&lt; validator-&gt;issueCount() &lt;&lt; " issues." &lt;&lt; std::endl;
    for(size_t i = 0; i &lt; validator-&gt;issueCount(); ++i) {
        std::cout &lt;&lt; "    - " &lt;&lt; validator-&gt;issue(i)-&gt;description() &lt;&lt; std::endl;
    }
    analyser-&gt;analyseModel(flatModel);
    std::cout &lt;&lt; "The analyser found "&lt;&lt; analyser-&gt;issueCount() &lt;&lt; " issues." &lt;&lt; std::endl;
    for(size_t i = 0; i &lt; analyser-&gt;issueCount(); ++i) {
        std::cout &lt;&lt; "    - " &lt;&lt; analyser-&gt;issue(i)-&gt;description() &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; std::endl;

    // end 3
    std::cout &lt;&lt; "--------------------------------------------------------" &lt;&lt; std::endl;
    std::cout &lt;&lt; "  STEP 4: Investigate individual imported models        " &lt;&lt; std::endl;
    std::cout &lt;&lt; "--------------------------------------------------------" &lt;&lt; std::endl;

</literal_block>
                    </container>
                </container>
                <container classes="dummy">
                    <container classes="item">
                        <container classes="dummy">
                            <paragraph>Python</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-2-1">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/import_debugger/importDebugger.py" xml:space="preserve">    # The analysis tools - the Validator and Analyser - will read only the submitted
    # model they do not look into any of the imported items, so they can't check them.
    # In order to retain the import structure but be able to use the diagnostic tools, 
    # we can create a flattened copy of the model for testing.  This can be used to
    # identify mistakes in the unflattened model too.  

    # Create a Validator and Analyser and submit the original, unflattened model.
    # We don't expect either of these to report any issues.
    validator = Validator()
    validator.validateModel(original_model)

    print('Investigating the original model:')
    print(' - the validator found {} issues'.format(validator.issueCount()))
    for i in range(0, validator.issueCount()):
        print('    - {}'.format(validator.issue(i).description()))
    
    analyser = Analyser()
    analyser.analyseModel(original_model)
    print(' - the analyser found {} issues'.format(analyser.issueCount()))
    for i in range(0, analyser.issueCount()):
        print('    - {}'.format(analyser.issue(i).description()))
    print()

    # Create a flattened version for diagnostics.
    flat_model = importer.flattenModel(original_model)

    # Repeat the validation and analysis above on the flattened model.
    validator.validateModel(flat_model)
    print('Investigating the flattened model:')
    print(' - the validator found {} issues'.format(validator.issueCount()))
    for i in range(0, validator.issueCount()):
        print('    - {}'.format(validator.issue(i).description()))
    
    analyser.analyseModel(flat_model)
    print(' - the analyser found {} issues'.format(analyser.issueCount()))
    for i in range(0, analyser.issueCount()):
        print('    - {}'.format(analyser.issue(i).description()))
    print()

</literal_block>
                    </container>
                </container>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">Investigating the original model:
The validator found 0 issues.
The analyser found 0 issues.

Investigating the flattened model:
The validator found 4 issues.
  - CellML identifiers must contain one or more basic Latin alphabetic characters.
  - Variable 'i_need_units' does not have a valid units attribute.
  - CellML identifiers must contain one or more basic Latin alphabetic characters.
  - Variable 'i_need_units' does not have a valid units attribute.
The analyser found 4 issues.
  - CellML identifiers must contain one or more basic Latin alphabetic characters.
  - Variable 'i_need_units' does not have a valid units attribute.
  - CellML identifiers must contain one or more basic Latin alphabetic characters.
  - Variable 'i_need_units' does not have a valid units attribute.</literal_block>
        </section>
        <section ids="validate-the-import-dependencies" names="validate\ the\ import\ dependencies">
            <title refid="id4">Validate the import dependencies</title>
            <paragraph>The issues reported by the <literal classes="code">Validator</literal> and <literal classes="code">Analyser</literal> items in the previous step have been hidden from the original model, as they exist somewhere in its hierarchy of imported items.
                We can make use of the library of import dependencies which is stored in the <literal classes="code">Importer</literal> class to locate the specific models in which the issues occurred, and repair them.</paragraph>
            <container classes="sphinx-tabs">
                <container classes="dummy">
                    <container classes="item">
                        <container classes="dummy">
                            <paragraph>C++</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-3-0 active">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/import_debugger/importDebugger.cpp" xml:space="preserve">    // The Validator and Analyser classes process only the contents of concrete items (ie: not the contents of 
    // imported items) of a model.
    // After successfully resolving a model's imports using an importer, the importer will store instances
    // of all of the dependencies of the resolved model.  These are accessible through the "library" function.
    // We can ascertain that all of import dependencies meet the diagnostic checks of the Validator and the 
    // Analyser individually by iterating through the importer's library.

    // Loop through the importer library and call the validator for each model.  
    for(size_t m = 0; m &lt; importer-&gt;libraryCount(); ++m) {

        // Retrieve the library model by index, m.
        validator-&gt;validateModel(importer-&gt;library(m));

        // Retrieve the key under which it's stored: this will be the URL at which the imported model was found.
        std::cout &lt;&lt; "The validator found "&lt;&lt;validator-&gt;issueCount() &lt;&lt; " issues in " &lt;&lt;importer-&gt;key(m) &lt;&lt; std::endl;
        for(size_t i = 0; i &lt; validator-&gt;issueCount(); ++i) {
            std::cout &lt;&lt; "    - " &lt;&lt; validator-&gt;issue(i)-&gt;description() &lt;&lt; std::endl;
        }
    }
    std::cout &lt;&lt; std::endl;

    // end 4
    std::cout &lt;&lt; "--------------------------------------------------------" &lt;&lt; std::endl;
    std::cout &lt;&lt; "  STEP 5: Fix the validation errors                     " &lt;&lt; std::endl;
    std::cout &lt;&lt; "--------------------------------------------------------" &lt;&lt; std::endl;

</literal_block>
                    </container>
                </container>
                <container classes="dummy">
                    <container classes="item">
                        <container classes="dummy">
                            <paragraph>Python</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-3-1">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/import_debugger/importDebugger.py" xml:space="preserve">    # The Validator and Analyser classes process only the contents of concrete items (ie: not the contents of 
    # imported items) of a model.
    # After successfully resolving a model's imports using an importer, the importer will store instances
    # of all of the dependencies of the resolved model.  These are accessible through the "library" function.
    # We can ascertain that all of import dependencies meet the diagnostic checks of the Validator and the 
    # Analyser individually by iterating through the importer's library.

    # Loop through the importer library and call the validator for each model.  
    for m in range(0, importer.libraryCount()):

        # Retrieve the library model by index, m.
        validator.validateModel(importer.library(m))

        # Retrieve the key under which it's stored: this will be the URL at which the imported model was found.
        print("The validator found {} issues in {}.".format(validator.issueCount(),importer.key(m)))
        for i in range(0, validator.issueCount()):
            print("    - {}".format(validator.issue(i).description()))

    print()

</literal_block>
                    </container>
                </container>
            </container>
            <paragraph>The code above will print the following to the terminal:</paragraph>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">The validator found 0 issues in resources/importExample2a.cellml
The validator found 0 issues in resources/importExample2b.cellml
The validator found 2 issues in resources/importExample3.cellml
    - CellML identifiers must contain one or more basic Latin alphabetic characters.
    - Variable 'iNeedUnits' does not have a valid units attribute.</literal_block>
        </section>
        <section ids="fix-the-errors-in-the-imported-model" names="fix\ the\ errors\ in\ the\ imported\ model">
            <title refid="id5">Fix the errors in the imported model</title>
            <paragraph>Now that we’ve found where the error is (a variable named “iNeedUnits” within a component which is imported from a file at URL “resources/importExample3.cellml”), it’s now time to fix it.
                This could be done by parsing that file directly and amending it as needed, but since we already have a copy of this model inside the <literal classes="code">Importer</literal> class, it’s better to use that one.
                When the importer resolves imports, any dependencies it needs are instantiated inside its library.
                These models can be accessed within the library by their key (the URL from which they were read) or by their index.
                Here we print the list of the importer’s library keys to demonstrate, and then retrieve the model containing the error so it can be fixed.</paragraph>
            <container classes="gotcha">
                <paragraph>Note that altering a model instance returned from the <literal classes="code">Importer</literal> changes the model instance which is used to resolve the original model’s dependencies.
                    The <literal classes="code">Importer</literal> checks its own library first before opening and parsing external files, so once we’ve fixed the error in the library’s model, re-flattening the original model uses the fixed version too.</paragraph>
            </container>
            <container classes="sphinx-tabs">
                <container classes="dummy">
                    <container classes="item">
                        <container classes="dummy">
                            <paragraph>C++</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-4-0 active">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/import_debugger/importDebugger.cpp" xml:space="preserve">    // Fix the validation errors in the imported files.
    // According to the printout above, we need to add units to the "iNeedUnits"
    // variable, to be found inside the "importExample3.cellml" file.
    // To fix this, we need to fix the model inside the "importExample3.cellml" file.
    // When the originalModel's imports were resolved, this model was added to the
    // library in the Importer.  We can retrieve the model from there for repair.

    // Retrieve from the library by key.  Note the inclusion of the directory used to
    // resolve imports for the original model is included in the key string.
    auto importExample3 = importer-&gt;library("resources/importExample3.cellml");

    // Add units to the variable that needs them to fix the validation error.
    importExample3-&gt;component("shared")-&gt;variable("i_need_units")-&gt;setUnits("dimensionless");

    // Check that the issues have been fixed.
    validator-&gt;validateModel(importExample3);

    std::cout &lt;&lt; "Investigating the repaired model: importExample3" &lt;&lt; std::endl;
    std::cout &lt;&lt; "The validator found "&lt;&lt;validator-&gt;issueCount() &lt;&lt; " issues." &lt;&lt; std::endl;
    for(size_t i = 0; i &lt; validator-&gt;issueCount(); ++i) {
        std::cout &lt;&lt; "    - " &lt;&lt; validator-&gt;issue(i)-&gt;description() &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; std::endl;

    // end 5
    std::cout &lt;&lt; "--------------------------------------------------------" &lt;&lt; std::endl;
    std::cout &lt;&lt; "  STEP 6: Fix the analysis errors                       " &lt;&lt; std::endl;
    std::cout &lt;&lt; "--------------------------------------------------------" &lt;&lt; std::endl;

</literal_block>
                    </container>
                </container>
                <container classes="dummy">
                    <container classes="item">
                        <container classes="dummy">
                            <paragraph>Python</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-4-1">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/import_debugger/importDebugger.py" xml:space="preserve">    # Fix the validation errors in the imported files.
    # According to the printout above, we need to add units to the "iNeedUnits"
    # variable, to be found inside the "importExample3.cellml" file.
    # To fix this, we need to fix the model inside the "importExample3.cellml" file.
    # When the original_model's imports were resolved, this model was added to the
    # library in the Importer.  We can retrieve the model from there for repair.

    # Retrieve from the library by key.  Note the inclusion of the directory used to
    # resolve imports for the original model is included in the key string.
    imported_model1 = importer.library('resources/importExample3.cellml')

    # Add units to the variable that needs them to fix the validation error.
    imported_model1.component('importThisOneToo').variable('iNeedUnits').setUnits('dimensionless')

    # Check that the issues have been fixed.
    validator.validateModel(imported_model1)
    print('\nInvestigating the repaired model:')
    print('The validator found {} issues.'.format(validator.issueCount()))

    for i in range(0, validator.issueCount()):
        print('    - {}'.format(validator.issue(i).description()))
    print()

</literal_block>
                    </container>
                </container>
            </container>
        </section>
        <section ids="analyse-the-import-dependencies" names="analyse\ the\ import\ dependencies">
            <title refid="id6">Analyse the import dependencies</title>
            <paragraph>This step repeats the two previous steps but uses the <literal classes="code">Analyser</literal> class instead of the <literal classes="code">Validator</literal> class to report on issues.
                We can then fix the issues found in the same way, by accessing the library’s version of the imported model and repairing the problem there.</paragraph>
            <container classes="sphinx-tabs">
                <container classes="dummy">
                    <container classes="item">
                        <container classes="dummy">
                            <paragraph>C++</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-5-0 active">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/import_debugger/importDebugger.cpp" xml:space="preserve">    // Repeat steps 4 and 5 using the Analyser instead of the Validator.

    // Loop through the importer library and call the analyser for each model.  
    for(size_t m = 0; m &lt; importer-&gt;libraryCount(); ++m) {

        // Retrieve the library model by index, m.
        analyser-&gt;analyseModel(importer-&gt;library(m));

        // Retrieve the key under which it's stored: this will be the URL at which the imported model was found.
        std::cout &lt;&lt; "The analyser found " &lt;&lt; analyser-&gt;issueCount() &lt;&lt; " issues in " &lt;&lt;importer-&gt;key(m) &lt;&lt; std::endl;
        for(size_t i = 0; i &lt; analyser-&gt;issueCount(); ++i) {
            std::cout &lt;&lt; "    - " &lt;&lt; analyser-&gt;issue(i)-&gt;description() &lt;&lt; std::endl;
        }
    }
    std::cout &lt;&lt; std::endl;

    // Fix the error by setting an initial value for the variable named 'some_other_variable' 
    // inside component 'shared' inside model imported from importExample3.cellml.
    importExample3-&gt;component("shared")-&gt;variable("some_other_variable")-&gt;setInitialValue(3);

    // Check that the issue has been fixed.
    analyser-&gt;analyseModel(importExample3);
    std::cout &lt;&lt; std::endl &lt;&lt; "Investigating the repaired model: importExample3" &lt;&lt; std::endl;
    std::cout &lt;&lt; "The analyser found " &lt;&lt; analyser-&gt;issueCount() &lt;&lt; " issues." &lt;&lt; std::endl;
    for(size_t i = 0; i &lt; analyser-&gt;issueCount(); ++i) {
        std::cout &lt;&lt; "    - " &lt;&lt; analyser-&gt;issue(i)-&gt;description() &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; std::endl;

    // Recreate the flattened model, and check it again.  This will use the updated model
    // in the importer library as its source.
    flatModel = importer-&gt;flattenModel(originalModel);

    validator-&gt;validateModel(flatModel);
    std::cout &lt;&lt; "Investigating the flattened model:" &lt;&lt; std::endl;
    std::cout &lt;&lt; "The validator found "&lt;&lt;validator-&gt;issueCount() &lt;&lt; " issues." &lt;&lt; std::endl;
    for(size_t i = 0; i &lt; validator-&gt;issueCount(); ++i) {
        std::cout &lt;&lt; "    - " &lt;&lt; validator-&gt;issue(i)-&gt;description() &lt;&lt; std::endl;
    }

    analyser-&gt;analyseModel(flatModel);
    std::cout &lt;&lt; "The analyser found "&lt;&lt;analyser-&gt;issueCount() &lt;&lt; " issues." &lt;&lt; std::endl;
    for(size_t i = 0; i &lt; analyser-&gt;issueCount(); ++i) {
        std::cout &lt;&lt; "    - " &lt;&lt; analyser-&gt;issue(i)-&gt;description() &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; std::endl;

    // end 6
    std::cout &lt;&lt; "--------------------------------------------------------" &lt;&lt; std::endl;
    std::cout &lt;&lt; "  STEP 7: Write the corrected models to files           " &lt;&lt; std::endl;
    std::cout &lt;&lt; "--------------------------------------------------------" &lt;&lt; std::endl;

</literal_block>
                    </container>
                </container>
                <container classes="dummy">
                    <container classes="item">
                        <container classes="dummy">
                            <paragraph>Python</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-5-1">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/import_debugger/importDebugger.py" xml:space="preserve">    # Repeat steps 4 and 5 using the Analyser instead of the Validator.

    # Loop through the importer library and call the analyser for each model.  
    for m in range(0, importer.libraryCount()):

        # Retrieve the library model by index, m.
        analyser.analyseModel(importer.library(m))

        # Retrieve the key under which it's stored: this will be the URL at which the imported model was found.
        print('The analyser found {} issues in {}.'.format(analyser.issueCount(),importer.key(m)))
        for i in range(0, analyser.issueCount()):
            print('    - {}'.format(analyser.issue(i).description()))
    
    print()

    # Fix the error by adding a MathML block to the component named "concreteComponent" 
    # in the "importExample2b.cellml" model.
    imported_model2 = importer.library("resources/importExample2b.cellml")
    mathml = \
        '&lt;math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:cellml="http://www.cellml.org/cellml/2.0#"&gt;\n'\
        '  &lt;apply&gt;\n'\
        '    &lt;eq/&gt;\n'\
        '    &lt;ci&gt;iAmNotCalculated&lt;/ci&gt;\n'\
        '    &lt;cn cellml:units="dimensionless"&gt;3&lt;/cn&gt;\n'\
        '  &lt;/apply&gt;\n'\
        '&lt;/math&gt;'
    imported_model2.component('concreteComponent').setMath(mathml)

    # Check that the issue has been fixed.
    analyser.analyseModel(imported_model2)
    print('\nInvestigating the repaired model:')
    print('The analyser found {} issues.'.format(analyser.issueCount()))
    for i in range(0,analyser.issueCount()):
        print('    - {}'.format(analyser.issue(i).description()))
    print()

    # Recreate the flattened model, and check it again.  This will use the updated model
    # in the importer library as its source.
    flat_model = importer.flattenModel(original_model)

    validator.validateModel(flat_model)
    print('\nInvestigating the flattened model:')
    print('The validator found {} issues.'.format(validator.issueCount()))
    for i in range(0, validator.issueCount()):
        print('    - '.format(validator.issue(i).description()))

    analyser.analyseModel(flat_model)
    print('The analyser found {} issues.'.format(analyser.issueCount()))
    for i in range(0, analyser.issueCount()):
        print('    - '.format(analyser.issue(i).description()))

</literal_block>
                    </container>
                </container>
            </container>
        </section>
        <section ids="output-the-repaired-models-to-cellml-files" names="output\ the\ repaired\ models\ to\ cellml\ files">
            <title refid="id7">Output the repaired models to CellML files</title>
            <paragraph>The final step in this process is to output the repaired models to CellML files.
                The ability to use imports to combine model items is useful, so we want to retain that in the fixed models.
                For this reason, we will write all of the files involved - whether altered or not - to a new directory.
                By doing this, we maintain the same relationship between the model files as was there in the beginning.</paragraph>
            <container classes="gotcha">
                <paragraph>For this example you will need to have created a directory structure ahead of time since the functions used here do not create those directories.
                    You will need to create two nested directories: <literal classes="code">repaired/resources</literal> within your working directory before continuing.</paragraph>
            </container>
            <container classes="sphinx-tabs">
                <container classes="dummy">
                    <container classes="item">
                        <container classes="dummy">
                            <paragraph>C++</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-6-0 active">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/import_debugger/importDebugger.cpp" xml:space="preserve">    // Print the collection of repaired import models to files.
    // To avoid over-writing existing files, we'll write the corrected files to a separate
    // directory called "repaired/".  Note that the relationship between the files needs
    // to be maintained, so even files that have not been changed need to be written
    // to the new location.

    // You can also use the utility function makeDirectory to create the "repaired" directory needed below.
    // makeDirectory("repaired");

    // Write the original model to a file. 
    auto printer = libcellml::Printer::create();
    std::ofstream outFile("importExample1.cellml");
    outFile &lt;&lt; printer-&gt;printModel(originalModel);
    outFile.close();

    // Write the dependency models in the importer library to files.  Note that the
    // library still contains the (now unneeded) circular reference files.  In order
    // to iterate through only those models which are actually used in the repaired version
    // you can use the importer-&gt;requirements(model) function.
    for(auto &amp;info : importer-&gt;requirements(originalModel)) {
        std::cout &lt;&lt; "Writing import dependency: "&lt;&lt; info.first &lt;&lt;std::endl;
        auto outFileName = info.first;
        outFile.open(outFileName);
        outFile &lt;&lt; printer-&gt;printModel(info.second);
        outFile.close();
    }

    std::cout &lt;&lt; "The corrected models have been written to the working directory." &lt;&lt; std::endl;

</literal_block>
                    </container>
                </container>
                <container classes="dummy">
                    <container classes="item">
                        <container classes="dummy">
                            <paragraph>Python</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-6-1">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/import_debugger/importDebugger.py" xml:space="preserve">    # Print the collection of repaired import models to files.
    # To avoid over-writing existing files, we'll write the corrected files to a separate
    # directory called "repaired/".  Note that the relationship between the files needs
    # to be maintained, so even files that have not been changed need to be written
    # to the new location.

    # Write the original model to a file.
    printer = Printer()
    model_string = printer.printModel(original_model)
    write_file = open("repaired/import_debugger/importExample1.cellml", "w")
    write_file.write(model_string)
    
    # Write the dependency models in the importer library to files.
    for m in range(0, importer.libraryCount()):
        write_file = open("repaired/"+importer.key(m), "w")
        model_string = printer.printModel(importer.library(m))
        write_file.write(model_string)
    
    print('The corrected models has been written to the \'repaired/resources/\' directory') 

</literal_block>
                    </container>
                </container>
            </container>
        </section>
    </section>
</document>
