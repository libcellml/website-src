<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.16 -->
<document source="/Users/kmoy001/libcellml/libcellml-tutorials/asides/index.rst">
    <target refid="asides"></target>
    <section ids="asides-a-collection-of-information-pages" names="asides:\ a\ collection\ of\ information\ pages">
        <title>Asides: A collection of information pages</title>
        <target refid="aside-units"></target>
        <section ids="understanding-units aside-units" names="understanding\ units aside_units">
            <title>Understanding units</title>
            <paragraph>Some basic units have been defined and built into libCellML, others you can define by combining the built-in ones using scaling factors and exponents, or you can define your own from scratch if need be.</paragraph>
            <paragraph>There are four different kinds of units used here: irreducible units, built-in units, derived or combination units, and custom irreducible units.</paragraph>
            <section ids="irreducible-units" names="irreducible\ units">
                <title>Irreducible units</title>
                <paragraph>The first are called <emphasis>irreducible</emphasis> because they represent the physical base quantities which cannot be further simplified:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>length (<literal classes="code">metre</literal>)</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>time (<literal classes="code">second</literal>)</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>amount of a substance (<literal classes="code">mole</literal>)</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>temperature (<literal classes="code">kelvin</literal>)</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>mass (<literal classes="code">kilogram</literal>)</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>electrical current (<literal classes="code">ampere</literal>)</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>luminous intensity (<literal classes="code">candela</literal>)</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>non-dimensional (<literal classes="code">dimensionless</literal>)</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>These <emphasis>irreducible</emphasis> units can be used to create all other physically-based units by combining them using different exponents, multipliers, and prefixes.</paragraph>
            </section>
            <section ids="built-in-units" names="built-in\ units">
                <title>Built-in units</title>
                <paragraph>Some of these combinations form our second type of units, the <emphasis>built-in units</emphasis>, these being common relationships which have been constructed from combinations of the irreducible units.
                    The combinations can involve:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>A scaling factor (the units <literal classes="code">millisecond</literal> is equivalent to
                            <literal classes="code">second</literal> and a factor of 0.001);</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>A combination of units (a <literal classes="code">coulomb</literal> is a <literal classes="code">second</literal> multiplied by
                            an <literal classes="code">ampere</literal>);</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Powers of units (a <literal classes="code">hertz</literal> has a base of <literal classes="code">second</literal> with an
                            exponent of -1); and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Any combination of the above.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>A list of pre-existing <emphasis>built-in</emphasis> convenience units is shown in the <reference internal="False" refuri="https://cellml-specification.readthedocs.io/en/latest//reference/formal_and_informative/specC02_units_reference.html#table-built-in-units">Built-in Units table</reference>, along with their relationships to the irreducible units.</paragraph>
            </section>
            <section ids="combination-or-derived-units" names="combination\ or\ derived\ units">
                <title>Combination or derived units</title>
                <paragraph>The third type of units are those <emphasis>combinations</emphasis> which users can define for themselves based on the built-in units, the irreducible units, any other units already created, or (see below) their own custom irreducible units.</paragraph>
                <paragraph>For example, let’s say that you want to simulate the time variable, <math>t</math>, in units of milliseconds.
                    This isn’t one of the built-in units, so you’ll need to define it, but it’s easy to see that it’s based on the built-in <literal classes="code">second</literal>, but needs a scaling factor.</paragraph>
                <paragraph>For convenience libCellML gives a variety of options for defining such scaling factors:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Either through the use of named prefixes which are listed on the <reference internal="False" refuri="https://cellml-specification.readthedocs.io/en/latest//reference/formal_and_informative/specC03_interpretation_of_units.html">Interpretation of Units page</reference>, eg: <literal classes="code">millisecond</literal> is <literal classes="code">second</literal> with <literal classes="code">prefix="milli"</literal>;</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>By defining an integer or integer string as a prefix which represents the <math>log_{10}</math> of the scaling factor, eg: <literal classes="code">millisecond</literal> is <literal classes="code">second</literal> with <literal classes="code">prefix=-3</literal> gives a scaling factor of <math>10^{-3}=0.001</math>.
                            NB: using an integer string like <literal classes="code">prefix="-3"</literal> gives the same result; and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>By defining the scaling factor directly, as a multiplier, eg: <literal classes="code">millisecond</literal> is <literal classes="code">second</literal> with <literal classes="code">multiplier=0.001</literal>.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>The overloaded argument option list is shown below for each language.
                    Please check the <reference internal="False" refuri="/documentation/api/latest/classlibcellml_1_1Units?fName=addUnit">API Units documentation</reference> for details.</paragraph>
                <container classes="sphinx-tabs">
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>C++</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">void addUnit(const std::string &amp;reference, const std::string &amp;prefix, double exponent = 1.0,
            double multiplier = 1.0, const std::string &amp;id = "");

void addUnit(const std::string &amp;reference, Prefix prefix, double exponent = 1.0,
            double multiplier = 1.0, const std::string &amp;id = "");

void addUnit(const std::string &amp;reference, int prefix, double exponent,
            double multiplier = 1.0, const std::string &amp;id = "");

void addUnit(const std::string &amp;reference, double exponent, const std::string &amp;id = "");

void addUnit(const std::string &amp;reference);</literal_block>
                    </container>
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>Python</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">addUnit(reference, prefix, exponent=1, multiplier=1)
addUnit(reference, exponent)
addUnit(reference)</literal_block>
                    </container>
                </container>
                <paragraph>Note that <literal classes="code">reference</literal> can be another unit name string or a <literal classes="code">StandardUnits</literal> enum, and <literal classes="code">prefix</literal> can be a string or an integer.</paragraph>
                <paragraph>To create a <literal classes="code">Units</literal> item you need will follow the same basic steps as other entities: declare it, name it, define it, and then add it in.
                    For example:</paragraph>
                <container classes="sphinx-tabs">
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>C++</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Declare, name, and define a "millisecond" unit pointer.
auto ms = libcellml::Units::create("millisecond");

// The manner of specification here is agnostic: all three definitions are identical.
ms-&gt;addUnit("second", "milli");  // reference unit and built-in prefix
// OR
ms-&gt;addUnit("second", 1.0, -3);  // reference unit, multiplier, exponent
// OR
ms-&gt;addUnit("second", 1.0, 0, 0.001);  // reference unit, multiplier, exponent</literal_block>
                    </container>
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>Python</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">from libcellml import Units

# Declare, name, and define a "millisecond" unit pointer.
ms = Units("millisecond")

# The manner of specification here is agnostic: all three definitions are identical.
ms.addUnit("second", "milli")          # reference unit and built-in prefix
# OR
ms.addUnit("second", -3, 0.001)        # reference unit, exponent, multiplier
# OR
ms.addUnit("second", 1, 1.0, 0.01)     # reference unit, prefix, exponent, multiplier</literal_block>
                    </container>
                </container>
                <paragraph>Units can be defined based on one another as well.
                    For example, after defining our <literal classes="code">millisecond</literal> units, we could then use this definition to define the <literal classes="code">per_millisecond</literal> units by simply including it with an exponent of -1:</paragraph>
                <container classes="sphinx-tabs">
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>C++</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Define a per_millisecond unit based on millisecond^-1:
per_ms-&gt;addUnit(ms, -1.0);</literal_block>
                    </container>
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>Python</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Defining a per_millisecond unit based on millisecond^-1.
per_ms.addUnit(ms, -1.0)  # reference unit, exponent</literal_block>
                    </container>
                </container>
            </section>
            <section ids="custom-irreducible-units" names="custom\ irreducible\ units">
                <title>Custom irreducible units</title>
                <paragraph>The final type of unit is a custom irreducible unit.
                    While this is not common in purely physical models (all of the seven physical attributes are already included), for times when you’re modelling something non-physical (such as our numbers of sharks or fishes), you’re able to define your own.
                    Here’s an example.</paragraph>
                <container classes="sphinx-tabs">
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>C++</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Create a custom irreducible unit named "banana".
auto uBanana = libcellml::Units::create("banana");

// Note that when a UnitsPtr is defined with a name only (that is, without any
// calls to the addUnit(...) function), it is effectively irreducible.

// Create a new compound unit based on the "banana" unit above.
auto uBunchOfBananas = libcellml::Units::create("bunch_of_bananas");
u2-&gt;addUnit("banana", 5.0);  // include bananas^5 in the bunch_of_bananas unit</literal_block>
                    </container>
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>Python</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">from libcellml import Units

# Create a custom irreducible unit named "banana".
uBanana = Units("banana")

# Note that when a Units is defined with a name only, it is effectively irreducible.

# Create a new compound unit based on the "banana" unit above.
uBunchOfBananas = Units("bunch_of_bananas")
uBunchOfBananas.addUnit("banana", 5.0)  # include bananas^5 in the bunch_of_bananas unit</literal_block>
                    </container>
                </container>
                <target refid="aside-constant-vs-variable"></target>
            </section>
        </section>
        <section ids="constants-vs-variables aside-constant-vs-variable" names="constants\ vs\ variables aside_constant_vs_variable">
            <title>Constants vs Variables</title>
            <paragraph>In your model, there is mathematics.
                And in your mathematics, there are variables.
                Some of these variables will, well, <emphasis>vary</emphasis> in value, but others might not.
                This note is to help you understand the different ways in which <literal classes="code">variable</literal> elements are assigned value, and what it means to your whole model’s interpretation.</paragraph>
            <paragraph>There are six ways to assign a value to a <literal classes="code">variable</literal> element:</paragraph>
            <section ids="assign-to-a-number-in-a-math-block" names="1.\ assign\ to\ a\ number\ in\ a\ math\ block">
                <title>1. Assign to a number in a math block</title>
                <paragraph>These are classed as “eternal truths”, and are statements which are held to be true throughout the entirety of the simulation.
                    If you use a <literal classes="code">math</literal> block statement to assign value to a <literal classes="code">variable</literal> element using a hard-coded numerical value, then that value can <strong>never</strong> be changed.
                    Any attempt to change it will make the model over-defined.
                    In the example below, <literal classes="code">A</literal> is a constant with value 1 for the entire simulation.</paragraph>
                <container classes="sphinx-tabs">
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>C++</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="c++" linenos="False" xml:space="preserve">// Setting A = 1 using a math block:
std::string myMathString = "&lt;math&gt;&lt;apply&gt;&lt;eq/&gt;&lt;ci&gt;A&lt;/ci&gt;&lt;cn cellml:units=\"dimensionless\"&gt;1&lt;/ci&gt;&lt;/apply&gt;&lt;/math&gt;";
myComponent-&gt;appendMath(myMathString);</literal_block>
                    </container>
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>Python</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Setting A = 1 using a math block:
my_math_string = '&lt;math&gt;&lt;apply&gt;&lt;eq/&gt;&lt;ci&gt;A&lt;/ci&gt;&lt;cn cellml:units="dimensionless"&gt;1&lt;/ci&gt;&lt;/apply&gt;&lt;/math&gt;'
my_component.appendMath(my_math_string)</literal_block>
                    </container>
                </container>
                <container classes="toggle">
                    <container classes="header">
                        <paragraph>Show CellML</paragraph>
                    </container>
                    <literal_block force="False" highlight_args="{}" language="xml" linenos="False" xml:space="preserve">&lt;math&gt;
  &lt;apply&gt;&lt;eq/&gt;
    &lt;ci&gt;A&lt;/ci&gt;
    &lt;cn cellml:units="dimensionless"&gt;1&lt;/cn&gt;
  &lt;/apply&gt;
&lt;/math&gt;</literal_block>
                </container>
            </section>
            <section ids="assign-to-another-variable-or-expression-in-a-math-block" names="2.\ assign\ to\ another\ variable\ or\ expression\ in\ a\ math\ block">
                <title>2. Assign to another variable or expression in a math block</title>
                <paragraph>As above, these are classed as “eternal truths”, but of course the actual value held by the variables may change as the expression is evaluated at different times.
                    The <literal classes="code">math</literal> statements are not <emphasis>assignments</emphasis> (as you’d expect in a programming language), but rather <emphasis>equations</emphasis> (as you’d expect in mathematics).
                    This means that writing <math>B = C</math> is equivalent to writing <math>C = B</math>, just as it is in normal mathematics, and can be read “The value of B is always the same as the value of C”.
                    Compare that to the assignment statement we’re familiar with in programming, <literal classes="code">B := C</literal> (“set the value of B to be the current value of C”) which is <emphasis>not</emphasis> the same as <literal classes="code">C := B</literal> (“set the value of C to be the current value of B”).
                    Of course <math>B = C</math> is perhaps the simplest equation possible, and yours will be a lot more complicated than this!</paragraph>
                <container classes="sphinx-tabs">
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>C++</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="c++" linenos="False" xml:space="preserve">// Setting B = C using a math block:
std::string myMathString = "&lt;math&gt;&lt;apply&gt;&lt;eq/&gt;&lt;ci&gt;B&lt;/ci&gt;&lt;ci&gt;C&lt;/ci&gt;&lt;/apply&gt;&lt;/math&gt;";
myComponent-&gt;appendMath(myMathString);</literal_block>
                    </container>
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>Python</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Setting B = C using a math block:
my_math_string = '&lt;math&gt;&lt;apply&gt;&lt;eq/&gt;&lt;ci&gt;B&lt;/ci&gt;&lt;ci&gt;C&lt;/ci&gt;&lt;/apply&gt;&lt;/math&gt;'
my_component.appendMath(my_math_string)</literal_block>
                    </container>
                </container>
            </section>
            <section ids="assign-as-an-initial-value-attribute" names="3.\ assign\ as\ an\ initial\ value\ attribute">
                <title>3. Assign as an initial value attribute</title>
                <paragraph>The term “initial value” might lead you to believe that the <literal classes="code">initial_value</literal> attributes are only used for variables of integration.
                    In reality, <emphasis>any</emphasis> variable which will have a non-constant value during the simulation <emphasis>may</emphasis> be set using this attribute.
                    This includes values which are changed by resets, or by solving a differential or algebraic equation.
                    The only situation where you don’t need to set a variable’s value like this is where the variable is defined by evaluation of a <literal classes="code">math</literal> block statement.
                    In that situation, having an initial value specified as well as a maths definition will make the model over-defined.</paragraph>
                <container classes="sphinx-tabs">
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>C++</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="c++" linenos="False" xml:space="preserve">// Setting the initial value of B:
myComponent-&gt;variable("B")-&gt;setInitialValue(1);

// Setting B = C using a math block:
std::string myMathString = "&lt;math&gt;&lt;apply&gt;&lt;eq/&gt;&lt;ci&gt;B&lt;/ci&gt;&lt;ci&gt;C&lt;/ci&gt;&lt;/apply&gt;&lt;/math&gt;";
myComponent-&gt;appendMath(myMathString);</literal_block>
                    </container>
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>Python</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Setting the initial value of B:
my_component-&gt;variable('B')-&gt;setInitialValue(1)

# Setting B = C using a math block:
my_math_string = '&lt;math&gt;&lt;apply&gt;&lt;eq/&gt;&lt;ci&gt;B&lt;/ci&gt;&lt;ci&gt;C&lt;/ci&gt;&lt;/apply&gt;&lt;/math&gt;'
my_component.appendMath(my_math_string)</literal_block>
                    </container>
                </container>
                <container classes="toggle">
                    <container classes="header">
                        <paragraph>Show CellML</paragraph>
                    </container>
                    <literal_block force="False" highlight_args="{}" language="xml" linenos="False" xml:space="preserve">&lt;!-- The variable B can change in value during the simulation. --&gt;
&lt;variable name="B" initial_value="1" units="dimensionless" /&gt;

&lt;!-- The variable C does not use initialisation, as it is
    constrained by the maths below to always have the same
    value as B, which has been initialised. --&gt;
&lt;variable name="C" units="dimensionless" /&gt;
&lt;math&gt;
  &lt;apply&gt;&lt;eq/&gt;
    &lt;ci&gt;B&lt;/ci&gt;
    &lt;ci&gt;C&lt;/ci&gt;
  &lt;/apply&gt;
&lt;/math&gt;

&lt;!-- The statement above is an equation, not an assignment,
    so is equivalent to: --&gt;
&lt;math&gt;
  &lt;apply&gt;&lt;eq/&gt;
    &lt;ci&gt;C&lt;/ci&gt;
    &lt;ci&gt;B&lt;/ci&gt;
  &lt;/apply&gt;
&lt;/math&gt;</literal_block>
                </container>
            </section>
            <section ids="assign-by-solving-a-differential-equation" names="4.\ assign\ by\ solving\ a\ differential\ equation">
                <title>4. Assign by solving a differential equation</title>
                <paragraph>This is similar to point 2 above, in that the variable’s definition is contained within a mathematical statement.
                    The difference is that when a <literal classes="code">variable</literal> element is a state variable (ie: the numerator of a differential equation), it <emphasis>must</emphasis> have a value which is specified (either locally or somewhere in its equivalent variable set) by an <literal classes="code">initial_value</literal> attribute.</paragraph>
                <container classes="sphinx-tabs">
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>C++</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="c++" linenos="False" xml:space="preserve">// Setting the initial value of E:
myComponent-&gt;variable("E")-&gt;setInitialValue(3);

// Solving for E using a differential equation:
std::string myDifferentialEquation = "&lt;math&gt;\n"
  "  &lt;apply&gt;&lt;eq/&gt;\n"
  "    &lt;diff&gt;\n"
  "      &lt;ci&gt;E&lt;/ci&gt;\n"
  "      &lt;bvar&gt;t&lt;/bvar&gt;\n"
  "    &lt;/diff&gt;\n"
  "    &lt;cn cellml:units=\"dimensionless\"&gt;1&lt;/cn&gt;\n"
  "  &lt;/apply&gt;\n"
  "&lt;/math&gt;";
myComponent-&gt;appendMath(myDifferentialEquation);</literal_block>
                    </container>
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>Python</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Setting the initial value of E:
my_component-&gt;variable('E')-&gt;setInitialValue(3)

# Solving for E using a differential equation:
my_differential_equation = '&lt;math&gt;\n'
  '  &lt;apply&gt;&lt;eq/&gt;\n'
  '    &lt;diff&gt;\n'
  '      &lt;ci&gt;E&lt;/ci&gt;\n'
  '      &lt;bvar&gt;t&lt;/bvar&gt;\n'
  '    &lt;/diff&gt;\n'
  '    &lt;cn cellml:units="dimensionless"&gt;1&lt;/cn&gt;\n'
  '  &lt;/apply&gt;\n'
  '&lt;/math&gt;'
my_component.appendMath(my_math_string)</literal_block>
                    </container>
                </container>
                <container classes="toggle">
                    <container classes="header">
                        <paragraph>Show CellML</paragraph>
                    </container>
                    <literal_block force="False" highlight_args="{}" language="xml" linenos="False" xml:space="preserve">&lt;!-- A state variable must have an initial value specified.
      Note that this could be applied to a connected variable in another component. --&gt;
&lt;variable name="E" units="dimensionless" initial_value="3" /&gt;
&lt;math&gt;
  &lt;apply&gt;&lt;eq/&gt;
    &lt;diff&gt;
      &lt;ci&gt;E&lt;/ci&gt;
      &lt;bvar&gt;t&lt;/bvar&gt;
    &lt;/diff&gt;
    &lt;cn cellml:units="dimensionless"&gt;1&lt;/cn&gt;
  &lt;/apply&gt;
&lt;/math&gt;</literal_block>
                </container>
            </section>
            <section ids="assign-by-applying-a-reset" names="5.\ assign\ by\ applying\ a\ reset">
                <title>5. Assign by applying a reset</title>
                <paragraph>Resets allow a variable to have prescribed discontinuity in value at some stage in the simulation process.
                    This means that the value of the variable must be allowed to change (that is, it must not appear in a statement like in point 1 above).
                    In contrast to the mathematical <emphasis>equations</emphasis> defined inside <literal classes="code">math</literal> elements, the MathML statements within a reset’s <literal classes="code">reset_value</literal> block is an <emphasis>assignment</emphasis>.
                    By their nature, the mathematics of resets are only temporarily true, and so anything written there is a one-off assignment when the reset item is active.
                    This means that even though the reset variable’s value can’t be defined as a constant (as in point 1), it could still be part of an equation (as in point 2).
                    It must not be a variable of integration (as in point 4) or a base variable (as in point 6).</paragraph>
            </section>
            <section ids="assign-as-a-variable-of-integration" names="6.\ assign\ as\ a\ variable\ of\ integration">
                <title>6. Assign as a variable of integration</title>
                <paragraph>These don’t need to be given a value inside CellML as their value will be set during the simulation.</paragraph>
            </section>
        </section>
    </section>
</document>
