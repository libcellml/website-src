<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.16 -->
<document source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/index.rst">
    <target refid="tutorial3"></target>
    <section ids="tutorial-3-create-a-model-and-generate-code-using-the-api tutorial3" names="tutorial\ 3:\ create\ a\ model\ and\ generate\ code\ using\ the\ api tutorial3">
        <title>Tutorial 3: Create a model and generate code using the API</title>
        <container classes="shortlist">
            <paragraph>By the time you have worked through Tutorial 3 you will be able to:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Create a new model and its child entities from scratch using the API;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Write your own MathML syntax to construct governing equations;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Define custom combinations of built-in units;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Define your own custom units independent from the built-in units; and</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Use the <literal classes="code">Generator</literal> functionality to transform the model into other languages.</paragraph>
                </list_item>
            </bullet_list>
        </container>
        <container classes="shortlist">
            <paragraph>This tutorial assumes that you are comfortable with:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Accessing and adjusting names of items inside a model hierarchy (see <reference internal="True" refuri="../tutorial2/index#tutorial2"><inline classes="std std-ref">Tutorial 2</inline></reference>);</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Creating a validator and using it to check a model for errors (see <reference internal="True" refuri="../tutorial2/index#tutorial2"><inline classes="std std-ref">Tutorial 2</inline></reference>);</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Accessing the errors produced by a validator and using them to correct the model (see <reference internal="True" refuri="../tutorial2/index#tutorial2"><inline classes="std std-ref">Tutorial 2</inline></reference>); and</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Serialising and printing a model to a CellML2 file (see <reference internal="True" refuri="../tutorial1/index#tutorial1"><inline classes="std std-ref">Tutorial 1</inline></reference>).</paragraph>
                </list_item>
            </bullet_list>
        </container>
        <section ids="requirements" names="requirements">
            <title>Requirements</title>
            <paragraph>Either <download_reference filename="d88debf49697a4d7ed21efc1ccbbed54/tutorial3.zip" refdoc="tutorials/tutorial3/index" refdomain="" refexplicit="True" reftarget="tutorial3.zip" reftype="download" refwarn="False"><literal classes="xref download">download the whole folder</literal></download_reference>, or:</paragraph>
            <container classes="shortlist">
                <paragraph><strong>C++</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><download_reference filename="8e552cfaaf187c985680b6b3c5e7ef46/CMakeLists.txt" refdoc="tutorials/tutorial3/index" refdomain="" refexplicit="False" reftarget="CMakeLists.txt" reftype="download" refwarn="False"><literal classes="xref download">CMakeLists.txt</literal></download_reference> The CMake file for building this tutorial;</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><download_reference filename="bb0b7240eb32c2dee08557a0e13a919e/tutorial3.cpp" refdoc="tutorials/tutorial3/index" refdomain="" refexplicit="False" reftarget="tutorial3.cpp" reftype="download" refwarn="False"><literal classes="xref download">tutorial3.cpp</literal></download_reference> The skeleton code; or</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><download_reference filename="5b20da741ccbfe1dd650e25fde54649d/tutorial3_complete.cpp" refdoc="tutorials/tutorial3/index" refdomain="" refexplicit="False" reftarget="tutorial3_complete.cpp" reftype="download" refwarn="False"><literal classes="xref download">tutorial3_complete.cpp</literal></download_reference> the completed tutorial code; and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><download_reference filename="a2d4a3ca1b36dbb0cf9e9c76357d80d8/utilities.h" refdoc="tutorials/tutorial3/index" refdomain="" refexplicit="True" reftarget="../utilities/utilities.h" reftype="download" refwarn="False"><literal classes="xref download">utilities.h</literal></download_reference> and <download_reference filename="912889e3f489eca7756b3017bf38e495/utilities.cpp" refdoc="tutorials/tutorial3/index" refdomain="" refexplicit="True" reftarget="../utilities/utilities.cpp" reftype="download" refwarn="False"><literal classes="xref download">utilities.cpp</literal></download_reference> Utility functions for use in the tutorials.</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="shortlist">
                <paragraph><strong>Python</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><download_reference filename="31d34d5b6c4e980be32c278cb054f40e/tutorial3.py" refdoc="tutorials/tutorial3/index" refdomain="" refexplicit="False" reftarget="tutorial3.py" reftype="download" refwarn="False"><literal classes="xref download">tutorial3.py</literal></download_reference> Either the skeleton code; or</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><download_reference filename="9d787b885b55c361cc7ab95fe2a26858/tutorial3_complete.py" refdoc="tutorials/tutorial3/index" refdomain="" refexplicit="False" reftarget="tutorial3_complete.py" reftype="download" refwarn="False"><literal classes="xref download">tutorial3_complete.py</literal></download_reference> the completed tutorial code; and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><download_reference filename="af18d02d5fc3d6f67791eb20133629e7/utilities.py" refdoc="tutorials/tutorial3/index" refdomain="" refexplicit="True" reftarget="../utilities/utilities.py" reftype="download" refwarn="False"><literal classes="xref download">utilities.py</literal></download_reference>  Utility functions for use in the tutorials.</paragraph>
                    </list_item>
                </bullet_list>
            </container>
        </section>
        <section ids="overview" names="overview">
            <title>Overview</title>
            <paragraph>During this tutorial you will create a simple model representing the population dynamics of two species - one a predator (sharks), and the other their prey (fish).
                The population of fish can only grow when they are not being constantly eaten by sharks, and the rate at which is grows will depend on how many fish are available for breeding.
                At the same time, the population of sharks will depend on how much food is available in the fish population.
                In maths this relationship can be written:</paragraph>
            <math_block docname="tutorials/tutorial3/index" label="True" nowrap="False" number="True" xml:space="preserve">\frac{dy_s}{dt} =f(sharks, fishes, time) = a y_s + b y_s y_f

\frac{dy_f}{dt} =f(sharks, fishes, time) = c y_f + d y_s y_f</math_block>
            <paragraph>where the constants <math>(a, b, c, d)=(-0.8, 0.3, 1.2, -0.6)</math> and we’ll use the initial conditions of <math>y_s(t=0)=1.0</math> and
                <math>y_f(t=0)=2.0</math>.</paragraph>
            <paragraph>In order to model these unusual populations you’ll need to create your own custom units, to enter and check these governing equations in MathML syntax, and to use the <literal classes="code">Generator</literal> functionality to create files able to be solved using a numerical integrator in C++ or Python.</paragraph>
        </section>
        <section ids="step-1-set-up-the-governing-equations" names="step\ 1:\ set\ up\ the\ governing\ equations">
            <title>Step 1: Set up the governing equations</title>
            <paragraph>Just as you did in <reference internal="True" refuri="../tutorial2/index#tutorial2"><inline classes="std std-ref">Tutorial 2</inline></reference>, we need to start by setting up a <literal classes="code">Model</literal> instance, and creating a <literal classes="code">Component</literal> inside it.</paragraph>
            <container classes="dothis">
                <paragraph><strong>1.a</strong> Create a new <literal classes="code">Model</literal> and give it a name.
                    This can be done in a single step using the overloaded constructor with a name string as its argument.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>1.b</strong> Create a new <literal classes="code">Component</literal> with a name, and add it to the model you created in 1.a.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.cpp" xml:space="preserve">    //  1.a
    //      Create a Model instance, set its name and id.
    auto model = libcellml::Model::create("tutorial_3_model");
    model-&gt;setId("tutorial_3_model_id");

    //  Check that it worked.
    std::cout &lt;&lt; "Model has name: '" &lt;&lt; model-&gt;name() &lt;&lt; "'" &lt;&lt; std::endl;
    std::cout &lt;&lt; "Model has id: '" &lt;&lt; model-&gt;id() &lt;&lt; "'" &lt;&lt; std::endl;

    //  1.b   
    //      Create a Component instance to use as an integrator, set its attributes and
    //      add it to the model.
    auto component = libcellml::Component::create("predator_prey_component");
    model-&gt;addComponent(component);

    //  Check that it worked.
    std::cout &lt;&lt; "Model has " &lt;&lt; model-&gt;componentCount()
              &lt;&lt; " components:" &lt;&lt; std::endl;
    for (size_t c = 0; c &lt; model-&gt;componentCount(); ++c) {
        std::cout &lt;&lt; "  Component [" &lt;&lt; c &lt;&lt; "] has name: '"
                  &lt;&lt; model-&gt;component(c)-&gt;name() &lt;&lt; "'" &lt;&lt; std::endl;
        std::cout &lt;&lt; "  Component [" &lt;&lt; c &lt;&lt; "] has id: '"
                  &lt;&lt; model-&gt;component(c)-&gt;id() &lt;&lt; "'" &lt;&lt; std::endl;
    }

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.py" xml:space="preserve">    #  1.a   
    #      Create a Model and name it.
    model = Model()
    model.setName("tutorial3_model")

    #  1.b   
    #      Create a component to use as an integrator, set its attributes and
    #      add it to the model.
    component = Component()
    component.setName("component")
    model.addComponent(component)

    #  Checking that it worked
    print_model(model)

</literal_block>
            </container>
            <paragraph>Now for the real bit.
                In order to actually model anything, we need to include the mathematical equations which represent the physical situation of interest.
                As you saw in <reference internal="True" refuri="../tutorial2/index#tutorial2"><inline classes="std std-ref">Tutorial 2</inline></reference>, the maths and the <literal classes="code">Variable</literal> items which it references live inside a parent <literal classes="code">Component</literal> item.</paragraph>
            <container classes="gotcha">
                <paragraph>At this point it should be noted that the <emphasis>order</emphasis> in which you add your components, or models, or variables (or anything) is not important to the final product, but it <emphasis>can</emphasis> affect how quickly you’re able to find and fix bugs along the way.
                    In these tutorials, we have suggested that you add the mathematics first and use a <literal classes="code">Validator</literal> to notify you of the
                    outstanding items, but you can really do this in any order you choose.</paragraph>
            </container>
            <paragraph>The system of equations which describe the populations are given by:</paragraph>
            <math_block docname="tutorials/tutorial3/index" label="True" nowrap="False" number="True" xml:space="preserve">c = a + 2.0

\frac{dy_s}{dt} =f(sharks, fish, time) = a y_s + b y_s y_f

\frac{dy_f}{dt} =f(sharks, fish, time) = c y_f + d y_s y_f</math_block>
            <paragraph>where <math>y_s</math> and <math>y_f</math> are the number of sharks and thousands of fish respectively, and the constants <math>(a, b, d)=(-0.8, 0.3, -0.6)</math> govern their behaviour.
                It’s clear that the value of constant <math>c</math> is easily calculable from the first equation, but we will leave it in this form
                to better illustrate the operation of the <literal classes="code">Analyser</literal> later on.</paragraph>
            <paragraph>In order to use this in our model we need to write it as a MathML2 string.
                The basic structure for these is described in the <reference internal="False" refuri="https://www.w3.org/TR/MathML2/chapter4.html#id.4.2.1.3">W3 resource pages regarding MathML2</reference>.</paragraph>
            <paragraph>It’s highly unlikely that you - the user - will actually be required to write MathML2 code directly, so this part of the tutorial is more about understanding what’s going on under the hood than practising fundamentally necessary skills.</paragraph>
            <container classes="gotcha">
                <paragraph><strong>Note</strong> that libCellML will <strong>only</strong> accept MathML2 markup, even though later versions (3 and 4) are now available.</paragraph>
            </container>
            <paragraph>Looking at the top equation first, the MathML2 representation of <math>c = a - 2.0</math> is:</paragraph>
            <literal_block force="False" highlight_args="{}" language="xml" linenos="False" xml:space="preserve">&lt;apply&gt;&lt;eq/&gt;
   &lt;ci&gt;c&lt;/ci&gt;
   &lt;apply&gt;&lt;plus/&gt;
       &lt;ci&gt;a&lt;/ci&gt;
       &lt;cn&gt;2.0&lt;/cn&gt;
   &lt;/apply&gt;
&lt;/apply&gt;</literal_block>
            <paragraph>Four things can be seen here:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>The <literal classes="code">&lt;apply&gt;</literal> opening and <literal classes="code">&lt;/apply&gt;</literal> closing tags which surround the <emphasis>operations</emphasis>;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The <emphasis>operations</emphasis> tags like <literal classes="code">&lt;eq/&gt;</literal> and <literal classes="code">&lt;plus/&gt;</literal> (or <literal classes="code">&lt;minus/&gt;</literal>, <literal classes="code">&lt;times/&gt;</literal>, <literal classes="code">&lt;divide/&gt;</literal>) which stand alone rather than in an open/close pair;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The <literal classes="code">&lt;ci&gt;</literal> opening and <literal classes="code">&lt;/ci&gt;</literal> closing tags which surround the variable names; and</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The <literal classes="code">&lt;cn&gt;</literal> opening and <literal classes="code">&lt;/cn&gt;</literal> closing tags which surround the constant <math>2.0</math> value.</paragraph>
                </list_item>
            </bullet_list>
            <container classes="dothis">
                <paragraph><strong>1.c</strong> Create a string containing the MathML which represents equation 1 above.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.cpp" xml:space="preserve">    //  1.c
    //      Create the MathML2 strings representing the governing equations.
    std::string equation1 =
        "  &lt;apply&gt;&lt;eq/&gt;\n"
        "    &lt;ci&gt;c&lt;/ci&gt;\n"
        "    &lt;apply&gt;&lt;plus/&gt;\n"
        "      &lt;ci&gt;a&lt;/ci&gt;\n"
        "      &lt;cn&gt;2.0&lt;/cn&gt;\n"
        "    &lt;/apply&gt;\n"
        "  &lt;/apply&gt;\n";

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.py" xml:space="preserve">    #  1.c
    #      Create the MathML2 string representing the governing equations.  
    equation1 = \
        "  &lt;apply&gt;&lt;eq/&gt;"\
        "    &lt;ci&gt;c&lt;/ci&gt;"\
        "    &lt;apply&gt;&lt;plus/&gt;"\
        "      &lt;ci&gt;a&lt;/ci&gt;"\
        "      &lt;cn&gt;2.0&lt;/cn&gt;"\
        "    &lt;/apply&gt;"\
        "  &lt;/apply&gt;"

</literal_block>
            </container>
            <paragraph>Differential terms, such as those on the left-hand side of equations 2 and 3 <math>\frac{dx}{dt}</math> in MathML become:</paragraph>
            <literal_block force="False" highlight_args="{}" language="xml" linenos="False" xml:space="preserve">&lt;apply&gt;&lt;diff/&gt;
    &lt;bvar&gt;
        &lt;ci&gt;t&lt;/ci&gt;
    &lt;/bvar&gt;
    &lt;ci&gt;x&lt;/ci&gt;
&lt;/apply&gt;</literal_block>
            <paragraph>Two further items to note:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>The base variable for the integration is identified by the <literal classes="code">&lt;bvar&gt; ... &lt;/bvar&gt;</literal> tags.
                        These variables are referred to as <emphasis>variables of integration</emphasis>, <emphasis>VOI</emphasis> or <emphasis>base variables</emphasis>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The <literal classes="code">&lt;diff/&gt;</literal> operation signifies differentiation with respect to the base variable.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The right-hand side becomes a collection of nested operations, all bracketed by <literal classes="code">&lt;apply&gt;...&lt;/apply&gt;</literal> tags for each operation:</paragraph>
            <literal_block force="False" highlight_args="{}" language="xml" linenos="False" xml:space="preserve">&lt;apply&gt;&lt;plus/&gt;
  &lt;apply&gt;&lt;times/&gt;
    &lt;ci&gt;a&lt;/ci&gt;
    &lt;ci&gt;y_s&lt;/ci&gt;
  &lt;/apply&gt;
  &lt;apply&gt;&lt;times/&gt;
    &lt;ci&gt;b&lt;/ci&gt;
    &lt;ci&gt;y_s&lt;/ci&gt;
    &lt;ci&gt;y_f&lt;/ci&gt;
  &lt;/apply&gt;
&lt;/apply&gt;</literal_block>
            <paragraph>When both sides are defined we need to equate them by <literal classes="code">&lt;apply&gt;</literal> -ing the <literal classes="code">&lt;eq/&gt;</literal> equals operator, and turn it into a string.</paragraph>
            <container classes="dothis">
                <paragraph><strong>1.d</strong> Create (or copy from the snippet below) the string representing equation 2 into your code.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.cpp" xml:space="preserve">    //  1.d
    std::string equation2 =
        "  &lt;apply&gt;&lt;eq/&gt;\n"
        "    &lt;apply&gt;&lt;diff/&gt;\n"
        "      &lt;bvar&gt;&lt;ci&gt;time&lt;/ci&gt;&lt;/bvar&gt;\n"
        "      &lt;ci&gt;y_s&lt;/ci&gt;\n"
        "    &lt;/apply&gt;\n"
        "    &lt;apply&gt;&lt;plus/&gt;\n"
        "      &lt;apply&gt;&lt;times/&gt;\n"
        "        &lt;ci&gt;a&lt;/ci&gt;\n"
        "        &lt;ci&gt;y_s&lt;/ci&gt;\n"
        "      &lt;/apply&gt;\n"
        "      &lt;apply&gt;&lt;times/&gt;\n"
        "        &lt;ci&gt;b&lt;/ci&gt;\n"
        "        &lt;ci&gt;y_s&lt;/ci&gt;\n"
        "        &lt;ci&gt;y_f&lt;/ci&gt;\n"
        "      &lt;/apply&gt;\n"
        "    &lt;/apply&gt;\n"
        "  &lt;/apply&gt;\n";

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.py" xml:space="preserve">    #  1.d
    equation2 = \
        "  &lt;apply&gt;&lt;eq/&gt;"\
        "    &lt;apply&gt;&lt;diff/&gt;"\
        "      &lt;bvar&gt;&lt;ci&gt;time&lt;/ci&gt;&lt;/bvar&gt;"\
        "      &lt;ci&gt;y_s&lt;/ci&gt;"\
        "    &lt;/apply&gt;"\
        "    &lt;apply&gt;&lt;plus/&gt;"\
        "      &lt;apply&gt;&lt;times/&gt;"\
        "        &lt;ci&gt;a&lt;/ci&gt;"\
        "        &lt;ci&gt;y_s&lt;/ci&gt;"\
        "      &lt;/apply&gt;"\
        "      &lt;apply&gt;&lt;times/&gt;"\
        "        &lt;ci&gt;b&lt;/ci&gt;"\
        "        &lt;ci&gt;y_s&lt;/ci&gt;"\
        "        &lt;ci&gt;y_f&lt;/ci&gt;"\
        "      &lt;/apply&gt;"\
        "    &lt;/apply&gt;"\
        "  &lt;/apply&gt;"

</literal_block>
            </container>
            <container classes="dothis">
                <paragraph><strong>1.e</strong> Create (or copy from the snippet below) a third string representing equation 3.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.cpp" xml:space="preserve">    //  1.e
    std::string equation3 =
        "  &lt;apply&gt;&lt;eq/&gt;\n"
        "    &lt;apply&gt;&lt;diff/&gt;\n"
        "      &lt;bvar&gt;&lt;ci&gt;time&lt;/ci&gt;&lt;/bvar&gt;\n"
        "      &lt;ci&gt;y_f&lt;/ci&gt;\n"
        "    &lt;/apply&gt;\n"
        "    &lt;apply&gt;&lt;plus/&gt;\n"
        "      &lt;apply&gt;&lt;times/&gt;\n"
        "        &lt;ci&gt;c&lt;/ci&gt;\n"
        "        &lt;ci&gt;y_f&lt;/ci&gt;\n"
        "      &lt;/apply&gt;\n"
        "      &lt;apply&gt;&lt;times/&gt;\n"
        "        &lt;ci&gt;d&lt;/ci&gt;\n"
        "        &lt;ci&gt;y_s&lt;/ci&gt;\n"
        "        &lt;ci&gt;y_f&lt;/ci&gt;\n"
        "      &lt;/apply&gt;\n"
        "    &lt;/apply&gt;\n"
        "  &lt;/apply&gt;\n";

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.py" xml:space="preserve">    #  1.e
    equation3 = \
        "  &lt;apply&gt;&lt;eq/&gt;"\
        "    &lt;apply&gt;&lt;diff/&gt;"\
        "      &lt;bvar&gt;&lt;ci&gt;time&lt;/ci&gt;&lt;/bvar&gt;"\
        "      &lt;ci&gt;y_f&lt;/ci&gt;"\
        "    &lt;/apply&gt;"\
        "    &lt;apply&gt;&lt;plus/&gt;"\
        "      &lt;apply&gt;&lt;times/&gt;"\
        "        &lt;ci&gt;c&lt;/ci&gt;"\
        "        &lt;ci&gt;y_f&lt;/ci&gt;"\
        "      &lt;/apply&gt;"\
        "      &lt;apply&gt;&lt;times/&gt;"\
        "        &lt;ci&gt;d&lt;/ci&gt;"\
        "        &lt;ci&gt;y_s&lt;/ci&gt;"\
        "        &lt;ci&gt;y_f&lt;/ci&gt;"\
        "      &lt;/apply&gt;"\
        "    &lt;/apply&gt;"\
        "  &lt;/apply&gt;"

</literal_block>
            </container>
            <paragraph>Next you need to define the namespace in which the maths will be applied by enclosing it in the <literal classes="code">&lt;math&gt; ... &lt;/math&gt;</literal> tags with the two namespaces:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>the MathML2 namespace <literal classes="code">xmlns</literal> at <reference refuri="http://www.w3.org/1998/Math/MathML">http://www.w3.org/1998/Math/MathML</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph>the CellML2 namespace <literal classes="code">xmlns:cellml</literal> at <reference refuri="http://www.cellml.org/cellml/2">http://www.cellml.org/cellml/2</reference>.0#</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>It’s simple to do this once in your code using a string to represent the opening attributes and namespaces; this string can be reused easily throughout your code as needed later.</paragraph>
            <container classes="dothis">
                <paragraph><strong>1.f</strong> Create the strings representing the opening and closing tags of the maths block.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.cpp" xml:space="preserve">    //  1.f
    //      Create the header and footer strings.
    std::string mathHeader = "&lt;math xmlns=\"http://www.w3.org/1998/Math/MathML\" xmlns:cellml=\"http://www.cellml.org/cellml/2.0#\"&gt;\n";
    std::string mathFooter = "&lt;/math&gt;";

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.py" xml:space="preserve">    #  1.f
    #    Add the header and footer strings.
    math_header = '&lt;math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:cellml="http://www.cellml.org/cellml/2.0#"&gt;'
    math_footer = '&lt;/math&gt;'

</literal_block>
            </container>
            <container classes="useful">
                <paragraph><reference internal="False" refuri="https://libcellml.github.io/help/api/v0.2.0/classlibcellml_1_1Component">Component class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>setMath</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>appendMath</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Utility functions (C++)</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>printIssues will write information on any issues from a given Logger to the terminal.
                            Logger classes include the <literal classes="code">Validator</literal>, <literal classes="code">Analyser</literal>, and <literal classes="code">Parser</literal>.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Utility functions (Python)</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>print_issues will write information on any issues from a given Logger to the terminal.
                            Logger classes include the <literal classes="code">Validator</literal>, <literal classes="code">Analyser</literal>, and <literal classes="code">Parser</literal>.</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <paragraph>Our last step in defining the mathematics is to link it into the component.
                The functions available to manipulate maths are:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>A <literal classes="code">setMath(yourMathsHere)</literal> function, which overwrites any existing MathML strings stored in the <literal classes="code">Component</literal> item; and</paragraph>
                </list_item>
                <list_item>
                    <paragraph>An <literal classes="code">appendMath(yourMathsHere)</literal> function, which performs a straightforward string concatenation with the current contents of the maths string in the <literal classes="code">Component</literal>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>There is no specific function to remove maths from a component, but this can be accomplished by using the <literal classes="code">setMath</literal> function with an empty string.</paragraph>
                </list_item>
            </bullet_list>
            <container classes="dothis">
                <paragraph><strong>1.g</strong> Use the functions above to include the MathML strings you’ve created into your component.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.cpp" xml:space="preserve">    //  1.g 
    //      Add the maths strings in to the component.
    component-&gt;setMath(mathHeader);
    component-&gt;appendMath(equation1);
    component-&gt;appendMath(equation2);
    component-&gt;appendMath(equation3);
    component-&gt;appendMath(mathFooter);

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.py" xml:space="preserve">    #  1.g
    #    Include the MathML strings in the component.
    component.setMath(math_header)
    component.appendMath(equation1)
    component.appendMath(equation2)
    component.appendMath(equation3)
    component.appendMath(math_footer)

</literal_block>
            </container>
            <container classes="gotcha">
                <paragraph>Note that the order in which strings are added might be important, as they are stored as a single concatenated string.
                    However, the order in which complete MathML equations occur in the overall MathML string is not important.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>1.h</strong> Create a <literal classes="code">Validator</literal> and use it to check for errors in the model at this point.
                    Use the utility function <literal classes="code">printIssues</literal> to output the messages to the terminal.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.cpp" xml:space="preserve">    //  1.h 
    //      Create a Validator instance and use it to check for issues so far.
    //      We expect there to be 18 errors found, related to missing variables
    //      in the component.  You can use the utility printIssues function 
    //      to print them to the terminal.
    auto validator = libcellml::Validator::create();
    validator-&gt;validateModel(model);
    printIssues(validator);

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.py" xml:space="preserve">    #  1.h   
    #    Create a validator and use it to check the model so far.
    validator = Validator()
    validator.validateModel(model)
    print_issues(validator)

</literal_block>
            </container>
            <paragraph>You should see an output similar to that shown below:</paragraph>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">Recorded 17 issues:

Issue 0 is an ERROR:
    description: MathML ci element has the child text 'c' which does not correspond with any variable names present in component 'predator_prey_component'.
    see section 2.12.3 in the CellML specification.
    more information at: https://cellml-specification.readthedocs.io/en/latest/reference/formal_and_informative/specB12.html?issue=2.12.3
    stored item type: MATH

Issue 1 is an ERROR:
    description: MathML ci element has the child text 'a' which does not correspond with any variable names present in component 'predator_prey_component'.
    see section 2.12.3 in the CellML specification.
    more information at: https://cellml-specification.readthedocs.io/en/latest/reference/formal_and_informative/specB12.html?issue=2.12.3
    stored item type: MATH

Issue 2 is an ERROR:
    description: Math cn element with the value '2.0' does not have a valid cellml:units attribute. CellML identifiers must contain one or more basic Latin alphabetic characters.
    see section 2.13.4 in the CellML specification.
    more information at: https://cellml-specification.readthedocs.io/en/latest/reference/formal_and_informative/specB13.html?issue=2.13.4
    stored item type: MATH

... etc ...</literal_block>
            <paragraph>Running the validator will alert you variables in the MathML that don’t (yet) exist in your component.
                This was explained in <reference internal="True" refuri="../tutorial2/index#tutorial2"><inline classes="std std-ref">Tutorial 2</inline></reference>, and we’ll add them below.</paragraph>
        </section>
        <section ids="step-2-create-the-variables" names="step\ 2:\ create\ the\ variables">
            <title>Step 2: Create the variables</title>
            <container classes="useful">
                <paragraph><reference internal="False" refuri="https://libcellml.github.io/help/api/v0.2.0/classlibcellml_1_1Variable">Variable class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>create</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>setName</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><reference internal="False" refuri="https://libcellml.github.io/help/api/v0.2.0/classlibcellml_1_1Component">Component class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>addVariable</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.a</strong> Create <literal classes="code">Variable</literal> items for each of the missing variables discovered above.
                    Remember that:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Each must have a name, either using the naming constructor or by manually calling the <literal classes="code">setName</literal> function; and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Each name must match what’s used inside your MathML string.</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.cpp" xml:space="preserve">    //  2.a 
    //      Create the variables listed by the validator: d, a, b, c, time, y_s, y_f.
    auto sharks = libcellml::Variable::create("y_s");
    auto fish = libcellml::Variable::create("y_f");
    auto time = libcellml::Variable::create("time");
    auto a = libcellml::Variable::create("a");
    auto b = libcellml::Variable::create("b");
    auto c = libcellml::Variable::create("c");
    auto d = libcellml::Variable::create("d");

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.py" xml:space="preserve">    #  2.a
    #      Create the variables listed by the validator: d, a, b, c, time, y_s, y_f.
    sharks = Variable("y_s")
    fish = Variable("y_f")
    time = Variable("time")
    a = Variable("a")
    b = Variable("b")
    c = Variable("c")
    d = Variable("d")

</literal_block>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.b</strong> Add each of your new variables to the component using the <literal classes="code">addVariable</literal> function.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.c</strong> Call the validator again to check for issues.
                    At this stage you can expect errors like those below relating to missing units for the variables.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.cpp" xml:space="preserve">    //  2.b 
    //      Add the variables into the component.
    component-&gt;addVariable(a);
    component-&gt;addVariable(b);
    component-&gt;addVariable(c);
    component-&gt;addVariable(d);
    component-&gt;addVariable(sharks);
    component-&gt;addVariable(fish);
    component-&gt;addVariable(time);

    //  2.c 
    //      Call the validator again to check.
    validator-&gt;validateModel(model);
    printIssues(validator);

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.py" xml:space="preserve">    #  2.b
    #      Add the variables into the component.
    component.addVariable(sharks)
    component.addVariable(fish)
    component.addVariable(time)
    component.addVariable(a)
    component.addVariable(b)
    component.addVariable(c)
    component.addVariable(d)

    #  2.c  
    #      Call the validator again to check the model.
    validator.validateModel(model)
    print_issues(validator)

</literal_block>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">Recorded 8 issues:

Issue 0 is an ERROR:
    description: Variable 'a' in component 'predator_prey_component' does not have any units specified.
    see section 2.8.1.2 in the CellML specification.
    more information at: https://cellml-specification.readthedocs.io/en/latest/reference/formal_and_informative/specB08.html?issue=2.8.1.2
    stored item type: VARIABLE

... etc ...</literal_block>
        </section>
        <section ids="step-3-built-in-and-customised-units" names="step\ 3:\ built-in\ and\ customised\ units">
            <title>Step 3: Built-in and customised units</title>
            <paragraph>Linking variables to the <emphasis>name</emphasis> of their units is straightforward, but in order to be able to use them we need to also define what the name actually <emphasis>means</emphasis> by creating the units themselves.
                Some common units have been defined and built into libCellML, others you can define by combining the built-in ones using scaling factors and exponents, or you can define your own from scratch if need be.</paragraph>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Read more about units</paragraph>
                </container>
                <container classes="infospec">
                    <target refid="aside-units"></target>
                    <container classes="heading3" ids="aside-units" names="aside_units">
                        <paragraph>Understanding units</paragraph>
                    </container>
                    <paragraph>Some basic units have been defined and built into libCellML, others you can define by combining the built-in ones using scaling factors and exponents, or you can define your own from scratch if need be.</paragraph>
                    <paragraph>There are four different kinds of units used here: irreducible units, built-in units, derived or combination units, and custom irreducible units.</paragraph>
                    <container classes="heading4">
                        <paragraph>Irreducible units</paragraph>
                    </container>
                    <paragraph>The first are called <emphasis>irreducible</emphasis> because they represent the physical base quantities which cannot be further simplified:</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>length (<literal classes="code">metre</literal>)</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>time (<literal classes="code">second</literal>)</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>amount of a substance (<literal classes="code">mole</literal>)</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>temperature (<literal classes="code">kelvin</literal>)</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>mass (<literal classes="code">kilogram</literal>)</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>electrical current (<literal classes="code">ampere</literal>)</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>luminous intensity (<literal classes="code">candela</literal>)</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>non-dimensional (<literal classes="code">dimensionless</literal>)</paragraph>
                        </list_item>
                    </bullet_list>
                    <paragraph>These <emphasis>irreducible</emphasis> units can be used to create all other physically-based units by combining them using different exponents, multipliers, and prefixes.</paragraph>
                    <container classes="heading4">
                        <paragraph>Built-in units</paragraph>
                    </container>
                    <paragraph>Some of these combinations form our second type of units, the <emphasis>built-in units</emphasis>, these being common relationships which have been constructed from combinations of the irreducible units.
                        The combinations can involve:</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>A scaling factor (the units <literal classes="code">millisecond</literal> is equivalent to
                                <literal classes="code">second</literal> and a factor of 0.001);</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>A combination of units (a <literal classes="code">coulomb</literal> is a <literal classes="code">second</literal> multiplied by
                                an <literal classes="code">ampere</literal>);</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>Powers of units (a <literal classes="code">Hertz</literal> has a base of <literal classes="code">second</literal> with an
                                exponent of -1); and</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>Any combination of the above.</paragraph>
                        </list_item>
                    </bullet_list>
                    <paragraph>A list of pre-existing <emphasis>built-in</emphasis> convenience units is shown in the <reference internal="False" refuri="https://cellml-specification.readthedocs.io/en/latest//reference/formal_and_informative/specC02_units_reference.html#table-built-in-units">Built-in Units table</reference>, along with their relationships to the irreducible units.</paragraph>
                    <container classes="heading4">
                        <paragraph>Combination or derived units</paragraph>
                    </container>
                    <paragraph>The third type of units are those <emphasis>combinations</emphasis> which users can define for themselves based on the built-in units, the irreducible units, any other units already created, or (see below) their own custom irreducible units.</paragraph>
                    <paragraph>For example, let’s say that you want to simulate the time variable, <math>t</math>, in units of milliseconds.
                        This isn’t one of the built-in units, so you’ll need to define it, but it’s easy to see that it’s based on the built-in <literal classes="code">second</literal>, but needs a scaling factor.</paragraph>
                    <paragraph>For convenience libCellML gives a variety of options for defining such scaling factors:</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>Either through the use of named prefixes which are listed on the <reference internal="False" refuri="https://cellml-specification.readthedocs.io/en/latest//reference/formal_and_informative/specC03_interpretation_of_units.html">Interpretation of Units page</reference>, eg: <literal classes="code">millisecond</literal> is <literal classes="code">second</literal> with <literal classes="code">prefix="milli"</literal>;</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>By defining an integer or integer string as a prefix which represents the <math>log_{10}</math> of the scaling factor, eg: <literal classes="code">millisecond</literal> is <literal classes="code">second</literal> with <literal classes="code">prefix=-3</literal> gives a scaling factor of <math>10^{-3}=0.001</math>.
                                NB: using an integer string like <literal classes="code">prefix="-3"</literal> gives the same result; and</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>By defining the scaling factor directly, as a multiplier, eg: <literal classes="code">millisecond</literal> is <literal classes="code">second</literal> with <literal classes="code">multiplier=0.001</literal>.</paragraph>
                        </list_item>
                    </bullet_list>
                    <paragraph>The overloaded argument option list is shown below for each language.
                        Please check the <reference internal="False" refuri="https://libcellml.github.io/help/api/v0.2.0/classlibcellml_1_1Units">API Units documentation</reference> for details.</paragraph>
                    <container classes="sphinx-tabs">
                        <container classes="dummy">
                            <container classes="item">
                                <container classes="dummy">
                                    <paragraph>C++</paragraph>
                                </container>
                            </container>
                            <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                            </container>
                            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">void addUnit(const std::string &amp;reference, const std::string &amp;prefix, double exponent = 1.0,
            double multiplier = 1.0, const std::string &amp;id = "");

void addUnit(const std::string &amp;reference, Prefix prefix, double exponent = 1.0,
            double multiplier = 1.0, const std::string &amp;id = "");

void addUnit(const std::string &amp;reference, int prefix, double exponent,
            double multiplier = 1.0, const std::string &amp;id = "");

void addUnit(const std::string &amp;reference, double exponent, const std::string &amp;id = "");

void addUnit(const std::string &amp;reference);</literal_block>
                        </container>
                        <container classes="dummy">
                            <container classes="item">
                                <container classes="dummy">
                                    <paragraph>Python</paragraph>
                                </container>
                            </container>
                            <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                            </container>
                            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">addUnit(reference, prefix, exponent=1, multiplier=1)
addUnit(reference, exponent)
addUnit(reference)</literal_block>
                        </container>
                    </container>
                    <paragraph>Note that <literal classes="code">reference</literal> can be another unit name string or a <literal classes="code">StandardUnits</literal> enum, and <literal classes="code">prefix</literal> can be a string or an integer.</paragraph>
                    <paragraph>To create a <literal classes="code">Units</literal> item you need will follow the same basic steps as other entities: declare it, name it, define it, and then add it in.
                        For example:</paragraph>
                    <container classes="sphinx-tabs">
                        <container classes="dummy">
                            <container classes="item">
                                <container classes="dummy">
                                    <paragraph>C++</paragraph>
                                </container>
                            </container>
                            <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                            </container>
                            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Declare, name, and define a "millisecond" unit pointer.
auto ms = libcellml::Units::create("millisecond");

// The manner of specification here is agnostic: all three definitions are identical.
ms-&gt;addUnit("second", "milli");  // reference unit and built-in prefix
// OR
ms-&gt;addUnit("second", 1.0, -3);  // reference unit, multiplier, exponent
// OR
ms-&gt;addUnit("second", 1.0, 0, 0.001);  // reference unit, multiplier, exponent</literal_block>
                        </container>
                        <container classes="dummy">
                            <container classes="item">
                                <container classes="dummy">
                                    <paragraph>Python</paragraph>
                                </container>
                            </container>
                            <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                            </container>
                            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">from libcellml import Units

# Declare, name, and define a "millisecond" unit pointer.
ms = Units("millisecond")

# The manner of specification here is agnostic: all three definitions are identical.
ms.addUnit("second", "milli")          # reference unit and built-in prefix
# OR
ms.addUnit("second", -3, 0.001)        # reference unit, exponent, multiplier
# OR
ms.addUnit("second", 1, 1.0, 0.01)     # reference unit, prefix, exponent, multiplier</literal_block>
                        </container>
                    </container>
                    <paragraph>Units can be defined based on one another as well.
                        For example, after defining our <literal classes="code">millisecond</literal> units, we could then use this definition to define the <literal classes="code">per_millisecond</literal> units by simply including it with an exponent of -1:</paragraph>
                    <container classes="sphinx-tabs">
                        <container classes="dummy">
                            <container classes="item">
                                <container classes="dummy">
                                    <paragraph>C++</paragraph>
                                </container>
                            </container>
                            <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                            </container>
                            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Define a per_millisecond unit based on millisecond^-1:
per_ms-&gt;addUnit(ms, -1.0);</literal_block>
                        </container>
                        <container classes="dummy">
                            <container classes="item">
                                <container classes="dummy">
                                    <paragraph>Python</paragraph>
                                </container>
                            </container>
                            <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                            </container>
                            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Defining a per_millisecond unit based on millisecond^-1.
per_ms.addUnit(ms, -1.0)  # reference unit, exponent</literal_block>
                        </container>
                    </container>
                    <container classes="heading4">
                        <paragraph>Custom irreducible units</paragraph>
                    </container>
                    <paragraph>The final type of unit is a custom irreducible unit.
                        While this is not common in purely physical models (all of the seven physical attributes are already included), for times when you’re modelling something non-physical (such as our numbers of sharks or fishes), you’re able to define your own.
                        Here’s an example.</paragraph>
                    <container classes="sphinx-tabs">
                        <container classes="dummy">
                            <container classes="item">
                                <container classes="dummy">
                                    <paragraph>C++</paragraph>
                                </container>
                            </container>
                            <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                            </container>
                            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Create a custom irreducible unit named "banana".
auto uBanana = libcellml::Units::create("banana");

// Note that when a UnitsPtr is defined with a name only (that is, without any
// calls to the addUnit(...) function), it is effectively irreducible.

// Create a new compound unit based on the "banana" unit above.
auto uBunchOfBananas = libcellml::Units::create("bunch_of_bananas");
u2-&gt;addUnit("banana", 5.0);  // include bananas^5 in the bunch_of_bananas unit</literal_block>
                        </container>
                        <container classes="dummy">
                            <container classes="item">
                                <container classes="dummy">
                                    <paragraph>Python</paragraph>
                                </container>
                            </container>
                            <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                            </container>
                            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">from libcellml import Units

# Create a custom irreducible unit named "banana".
uBanana = Units("banana")

# Note that when a Units is defined with a name only, it is effectively irreducible.

# Create a new compound unit based on the "banana" unit above.
uBunchOfBananas = Units("bunch_of_bananas")
uBunchOfBananas.addUnit("banana", 5.0)  # include bananas^5 in the bunch_of_bananas unit</literal_block>
                        </container>
                    </container>
                </container>
            </container>
            <container classes="useful">
                <paragraph><reference internal="False" refuri="https://libcellml.github.io/help/api/v0.2.0/classlibcellml_1_1Units">Units class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>create</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>setName</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>addUnit (note singular)</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><reference internal="False" refuri="https://libcellml.github.io/help/api/v0.2.0/classlibcellml_1_1Model">Model class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>addUnits (note plural)</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>linkUnits</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><reference internal="False" refuri="https://libcellml.github.io/help/api/v0.2.0/classlibcellml_1_1Variable">Variable class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>setUnits (note plural)</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <paragraph>To create a <literal classes="code">Units</literal> item you need will follow the same basic steps as other entities: declare it, name it, define it, and then add it in.
                For example:</paragraph>
            <container classes="sphinx-tabs">
                <container classes="dummy">
                    <container classes="item">
                        <container classes="dummy">
                            <paragraph>C++</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                    </container>
                    <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Declare, name, and define a "millisecond" unit pointer.
auto ms = libcellml::Units::create("millisecond");

// The manner of specification here is agnostic: all three definitions are identical.
ms-&gt;addUnit("second", "milli");  reference unit and built-in prefix
// OR
ms-&gt;addUnit("second", 1.0, -3);  reference unit, prefix, exponent
// OR
ms-&gt;addUnit("second", 1.0, 0, 0.001);  reference unit, prefix, exponent, multiplier</literal_block>
                </container>
                <container classes="dummy">
                    <container classes="item">
                        <container classes="dummy">
                            <paragraph>Python</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                    </container>
                    <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">from libcellml import Units

# Declare, name, and define a "millisecond" unit pointer.
ms = Units("millisecond")

# The manner of specification here is agnostic: all three definitions are identical.
ms.addUnit("second", "milli")          # reference unit and built-in prefix
# OR
ms.addUnit("second", 1.0, -3)          # reference unit, prefix, exponent
# OR
ms.addUnit("second", 1, 1.0, 0.01)     # reference unit, prefix, exponent, multiplier</literal_block>
                </container>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.a</strong> Use the example above to create, name and define the units of “month” which will represent your time variable.
                    This should be defined as a multiple of the built-in unit <literal classes="code">second</literal>.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.cpp" xml:space="preserve">    //  3.a 
    //      Create units representing a month, or 2592000 seconds.
    auto month = libcellml::Units::create("month");
    month-&gt;addUnit("second", 0, 1, 2592000);  // base unit, prefix, exponent, multiplier
    model-&gt;addUnits(month);

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.py" xml:space="preserve">    #  3.a  
    #      Define the relationship between our custom units and the built-in
    #      units. There is a list of built-in units and their definitions
    #      available in section 19.2 of the CellML2 specification.
    #      First we create the "month" units, which will be equivalent to
    #      60*60*24*30 = 2,592,000 seconds.
    month = Units("month")
    month.addUnit("second", 1, 2592000)  # Setting a month to be 2592000 seconds.
    model.addUnits(month)

    #  "second" is a built-in unit, used with a multiplier of 2592000.
    #  Note that this could have been written:
    #    month.addUnit("second", "mega", 1, 2.592)
    #    month.addUnit("second", 5, 25.92)

</literal_block>
            </container>
            <paragraph>Units can be defined based on one another as well.
                For example, after defining our <literal classes="code">millisecond</literal> units, we could then use this definition to define the <literal classes="code">per_millisecond</literal> units by simply including it with an exponent of -1:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">Define a per_millisecond unit based on millisecond^-1:
per_ms-&gt;addUnit(ms, -1.0);</literal_block>
            <container classes="dothis">
                <paragraph><strong>3.b</strong> Create a <literal classes="code">Units</literal> item called “per_month” based on the one you just created, as shown above.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.cpp" xml:space="preserve">    //  3.b 
    //      Create the per_month unit based on the month defined in 3.a.
    auto per_month = libcellml::Units::create("per_month");
    per_month-&gt;addUnit("month", -1);  // base unit, exponent
    model-&gt;addUnits(per_month);

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.py" xml:space="preserve">    #  3.b  
    #      Create units which represent "per_month", which
    #      is simply the inverse of the "month" unit above.
    per_month = Units()
    per_month.setName("per_month")
    per_month.addUnit("month", -1)
    model.addUnits(per_month)

</literal_block>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.c</strong> Create the irreducible units needed by the shark and fish populations.
                    Call these “number_of_sharks” and “thousands_of_fish” respectively.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.cpp" xml:space="preserve">    //  3.c 
    //      Create the sharks and fishes base units, "number_of_sharks" and "thousands_of_fish".
    auto number_of_sharks = libcellml::Units::create("number_of_sharks");
    auto thousands_of_fish = libcellml::Units::create("thousands_of_fish");
    model-&gt;addUnits(number_of_sharks);
    model-&gt;addUnits(thousands_of_fish);

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.py" xml:space="preserve">    #  3.c      
    #      Create the sharks and fishes base units.
    number_of_sharks = Units()
    number_of_sharks.setName("number_of_sharks")
    model.addUnits(number_of_sharks)
    thousands_of_fish = Units()
    thousands_of_fish.setName("thousands_of_fish")
    model.addUnits(thousands_of_fish)

</literal_block>
            </container>
            <paragraph>Finally we need to create the units for the constants <literal classes="code">b</literal> and <literal classes="code">d</literal>.
                These will be combinations of those which we’ve already created, as defined by the need for dimensional consistency in our governing equations.</paragraph>
            <container classes="dothis">
                <paragraph><strong>3.d</strong> Create two units representing “per shark month” (for the <literal classes="code">b</literal> variable) and “per fish month” (for the <literal classes="code">d</literal> variable).</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.cpp" xml:space="preserve">    //  3.d 
    //      Create the combined units for the constants, "per_shark_month" and "per_fish_month".
    auto b_units = libcellml::Units::create("per_shark_month");
    b_units-&gt;addUnit("per_month");
    b_units-&gt;addUnit("number_of_sharks", -1);
    model-&gt;addUnits(b_units);

    auto d_units = libcellml::Units::create("per_1000fish_month");
    d_units-&gt;addUnit("per_month");
    d_units-&gt;addUnit("thousands_of_fish", -1);
    model-&gt;addUnits(d_units);

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.py" xml:space="preserve">    #  3.d  
    #      Create the combined units for the constants.  Note that each item included
    #      with the addUnit command is multiplied to create the final Units definition.
    b_units = Units()
    b_units.setName("per_shark_month")
    b_units.addUnit("per_month")
    b_units.addUnit("number_of_sharks", -1)
    model.addUnits(b_units)

    d_units = Units()
    d_units.setName("per_fish_month")
    d_units.addUnit("per_month")
    d_units.addUnit("thousands_of_fish", -1)
    model.addUnits(d_units)

</literal_block>
            </container>
            <paragraph>The final two steps are to associate each variable with its appropriate units, and to include the units in the model.</paragraph>
            <container classes="gotcha">
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>When you add different sub-unit parts into a <literal classes="code">Units</literal> item, the function is <literal classes="code">addUnit</literal> (singular), and it takes as argument the <emphasis>name</emphasis> of the sub-unit as a string (eg: <literal classes="code">"second"</literal> used above).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>When you add the final created combination into the <literal classes="code">Model</literal> item, the function is <literal classes="code">addUnits</literal> (plural), and it takes as argument the <emphasis>reference</emphasis> of the combined units (eg: <literal classes="code">ms</literal>).</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.e</strong> Add the units to their variables using <literal classes="code">myVariable-&gt;setUnits(myUnits)</literal>.
                    Add the units to the model using <literal classes="code">myModel-&gt;addUnits(myUnits)</literal>.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.cpp" xml:space="preserve">    //  3.e 
    //      Add the units to their variables using the setUnits function.
    time-&gt;setUnits(month);
    a-&gt;setUnits(per_month);
    b-&gt;setUnits(b_units);
    c-&gt;setUnits(per_month);
    d-&gt;setUnits(d_units);
    sharks-&gt;setUnits(number_of_sharks);
    fish-&gt;setUnits(thousands_of_fish);

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.py" xml:space="preserve">    #  3.e  
    #      Set the units to their respective variables.
    time.setUnits(month)
    sharks.setUnits(number_of_sharks)
    fish.setUnits(thousands_of_fish)
    a.setUnits(per_month)
    b.setUnits(b_units)
    c.setUnits(per_month)
    d.setUnits(d_units)

</literal_block>
            </container>
            <container classes="gotcha">
                <paragraph><strong>Gotcha!</strong> When you specify the <literal classes="code">Units</literal> for a <literal classes="code">Variable</literal> using its name then you may need to call the model’s <literal classes="code">linkUnits</literal> function before validating the model.
                    If you see errors related to missing units which do in fact exist, this indicates that a call to the <literal classes="code">linkUnits</literal> function is needed.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.f</strong> Call the validator to check your model for errors.
                    You should see an output similar to that shown below.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.cpp" xml:space="preserve">    //  3.f 
    //      Call the validator to check the model.  We expect one error regarding the missing units in the MathML.
    validator-&gt;validateModel(model);
    printIssues(validator);

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.py" xml:space="preserve">    #  3.f  
    #      Call the validator again to check the model.
    #      Expect one error regarding a missing unit in the MathML.
    validator.validateModel(model)
    print_issues(validator)

</literal_block>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">Recorded 1 issues:

Issue 0 is an ERROR:
    description: Math cn element with the value '2.0' does not have a valid cellml:units attribute. CellML identifiers must contain one or more basic Latin alphabetic characters.
    see section 2.13.4 in the CellML specification.
    more information at: https://cellml-specification.readthedocs.io/en/latest/reference/formal_and_informative/specB13.html?issue=2.13.4
    stored item type: MATH</literal_block>
            <paragraph>In the first MathML equation we used a real number <literal classes="code">&lt;cn&gt;2.0&lt;/cn&gt;</literal> without specifying any units for it.
                Because the dimensionality of the equation needs to be valid, all real numbers must be associated with units, just the same way that variables are.
                These are defined within the tags of the MathML, and must also refer to the <literal classes="code">cellml</literal> namespace.  For example:</paragraph>
            <literal_block force="False" highlight_args="{}" language="xml" linenos="False" xml:space="preserve">&lt;cn cellml:units="bunch_of_bananas"&gt;1&lt;/cn&gt;</literal_block>
            <paragraph>… which gives us one bunch of bananas, without needing to create a corresponding <literal classes="code">Variable</literal> item.
                Of course, you may need to create the corresponding <literal classes="code">Units</literal> item and add it to the model, if it is not already present.</paragraph>
            <container classes="dothis">
                <paragraph><strong>3.g</strong>  Create a copy of the MathML statement from step 1.c and add the namespace and units definition as in the example above into the string.
                    Recall that using the <literal classes="code">setMath()</literal> function will overwrite the existing maths, and repeat the process you did in step 1.e to include the new MathML instead.
                    Remember that you will need to re-include the opening and closing <literal classes="code">&lt;math&gt;</literal> tags as well as the other equations.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.h</strong> Check that the model is now free of validation errors.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.cpp" xml:space="preserve">    //  3.g 
    //      Units for constants inside the MathML must be specified at the time.  This means we need to adjust
    //      equation1 to include the per_month units.  We have to wipe all the existing MathML and replace it.
    component-&gt;removeMath();
    component-&gt;setMath(mathHeader);
    equation1 =
        "  &lt;apply&gt;&lt;eq/&gt;\n"
        "    &lt;ci&gt;c&lt;/ci&gt;\n"
        "    &lt;apply&gt;&lt;plus/&gt;\n"
        "      &lt;ci&gt;a&lt;/ci&gt;\n"
        "      &lt;cn cellml:units=\"per_month\"&gt;2.0&lt;/cn&gt;\n"
        "    &lt;/apply&gt;\n"
        "  &lt;/apply&gt;\n";

    component-&gt;appendMath(equation1);
    component-&gt;appendMath(equation2);
    component-&gt;appendMath(equation3);
    component-&gt;appendMath(mathFooter);

    //  3.h 
    //      Revalidate your model and expect there to be no errors.
    validator-&gt;validateModel(model);
    printIssues(validator);
    assert(validator-&gt;errorCount() == 0);

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.py" xml:space="preserve">    #  3.g  
    #      Units for constants inside the MathML must be specified at the time.
    #      This means we need to adjust equation1 to include the per_month units.
    #      We have to wipe all the existing MathML and replace it.
    component.removeMath()
    component.setMath(math_header)
    equation1 = \
        "  &lt;apply&gt;&lt;eq/&gt;"\
        "    &lt;ci&gt;c&lt;/ci&gt;"\
        "    &lt;apply&gt;&lt;plus/&gt;"\
        "      &lt;ci&gt;a&lt;/ci&gt;"\
        "      &lt;cn cellml:units=\"per_month\"&gt;2.0&lt;/cn&gt;"\
        "    &lt;/apply&gt;"\
        "  &lt;/apply&gt;"
    component.appendMath(equation1)
    component.appendMath(equation2)
    component.appendMath(equation3)
    component.appendMath(math_footer)

    #  3.h  
    #      Validate once more, and expect there to be no errors this time.
    validator.validateModel(model)
    print_issues(validator)

</literal_block>
            </container>
        </section>
        <section ids="step-4-analyse-the-mathematical-model" names="step\ 4:\ analyse\ the\ mathematical\ model">
            <title>Step 4: Analyse the mathematical model</title>
            <paragraph>The <literal classes="code">Analyser</literal> class checks that the underlying mathematical model represented by the entire combination of variables, components, and mathematics, makes sense.
                The <literal classes="code">Validator</literal> checks your “spelling” and syntax, and the <literal classes="code">Analyser</literal> checks for the ability to find a solution.</paragraph>
            <container classes="useful">
                <paragraph><reference internal="False" refuri="https://libcellml.github.io/help/api/v0.2.0/classlibcellml_1_1Analyser">Analyser class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>create</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>analyseModel</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>model</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>4.a</strong> Create an <literal classes="code">Analyser</literal> instance and pass it the model using the <literal classes="code">analyseModel</literal> function.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>4.b</strong> Check for issues found in the analyser.
                    You should expect 6 errors, related to variables whose values are not computed or initialised.
                    Note that you can use the same utility function <literal classes="code">printIssues</literal> to output issues from the analyser as from the validator.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.cpp" xml:space="preserve">    //  4.a 
    //      Create an Analyser instance and pass it the model using the
    //      analyseModel function.  
    auto analyser = libcellml::Analyser::create();
    analyser-&gt;analyseModel(model);

    //  4.b 
    //      Check for errors found in the analyser. You should expect 6 errors,
    //      related to variables whose values are not computed or initialised.
    printIssues(analyser);

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.py" xml:space="preserve">    #  4.a 
    #     Create an Analyser instance and pass it the model using the
    #     analyseModel function.  
    analyser = Analyser()
    analyser.analyseModel(model)

    #  4.b 
    #     Check for errors found in the analyser. You should expect 6 errors,
    #     related to variables whose values are not computed or initialised.
    print_issues(analyser)

</literal_block>
            </container>
            <paragraph>The messages above refer to the fact that though our model has passed validation tests, it’s not yet sufficiently constrained to allow it to be solved, which is what the <literal classes="code">Generator</literal> checks for.
                We need to set initial conditions for the variables we’re solving for, the populations of sharks and fish, using the <literal classes="code">setInitialValue</literal> function.
                The values of the constants <literal classes="code">a, b, c, d</literal> are just that - constant - and their values are set using the same <literal classes="code">setInitialValue</literal> function.</paragraph>
            <container classes="dothis">
                <paragraph><strong>4.c</strong> Set the values of the constants <math>(a, b, d)=(-0.8, 0.3, -0.6)</math> and the initial conditions such that <math>y_f(t=0)=2.0</math> and <math>y_s(t=0)=1.0</math>.
                    Note that:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>The constant <math>c</math> will be calculated by our equation 1, so does not need to be specified; and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>The base variable (or “variable of integration”, or “voi”) <math>t</math> must <emphasis>not</emphasis> have an initial condition set.</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>4.d</strong> Reprocess the model and check that the analyser is now free of issues.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.cpp" xml:space="preserve">    //  4.c 
    //      Add initial conditions to all variables except the base variable, time
    //      and the constant c which will be computed. Reprocess the model.
    a-&gt;setInitialValue(-0.8);
    b-&gt;setInitialValue(0.3);
    d-&gt;setInitialValue(-0.6);
    sharks-&gt;setInitialValue(1.0);
    fish-&gt;setInitialValue(2.0);

    //  4.d 
    //      Reprocess the model and check that the generator is now free of errors.
    analyser-&gt;analyseModel(model);
    printIssues(analyser);

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.py" xml:space="preserve">    #  4.c 
    #     Add initial conditions to all variables except the base variable, time
    #     and the constant c which will be computed. Reprocess the model.
    a.setInitialValue(-0.8)
    b.setInitialValue(0.3)
    d.setInitialValue(-0.6)
    sharks.setInitialValue(1.0)
    fish.setInitialValue(2.0)

    #  4.d 
    #     Reprocess the model and check that the analyser is now free of errors.
    analyser.analyseModel(model)
    print_issues(analyser)

</literal_block>
            </container>
        </section>
        <section ids="step-5-generate-code-and-output" names="step\ 5:\ generate\ code\ and\ output">
            <title>Step 5: Generate code and output</title>
            <paragraph>Some exciting new functionality in libCellML is the ability to generate a runnable file from a model description.
                This means that if you already have a solver in either C or Python, you can simply translate your model from here into that language.</paragraph>
            <paragraph>The <literal classes="code">Generator</literal> has to re-interpret all of the maths, including the variables, their interaction with each other in different equations, values, initial conditions and units before it can output your model in your choice of language.
                For the maths to make sense, the definitions in your model’s variables, maths blocks and units need to be solvable too.
                There are several requirements that need to be satisfied in order for the code generation functionality to be able to work, <emphasis>beyond</emphasis> the CellML syntax requirements.
                These are:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>The mathematical model definition must be appropriately constrained (not over- or under-constrained);</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Initial conditions must be specified for variables which are integrated;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Initial conditions must not be specified for variables which are the base of integration;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The values of constants must be specified or calculable; and</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>TODO get full list of stuff here …</strong></paragraph>
                </list_item>
            </bullet_list>
            <container classes="useful">
                <paragraph><reference internal="False" refuri="https://libcellml.github.io/help/api/v0.2.0/classlibcellml_1_1Generator">Generator class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>create</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>profile</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>setModel</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>interfaceCode</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>implementationCode</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><reference internal="False" refuri="https://libcellml.github.io/help/api/v0.2.0/classlibcellml_1_1GeneratorProfile">GeneratorProfile class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>create</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>setInterfaceFileNameString</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>The GeneratorProfile class contains an enum indicating the language of profile to set.
                    In C++ this is <literal classes="code">GeneratorProfile::Profile</literal>.
                    In Python this is <literal classes="code">GeneratorProfile.Profile</literal>.</paragraph>
                <paragraph>At the time of writing two profiles are available:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><literal classes="code">C</literal> (default)</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal classes="code">PYTHON</literal></paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>5.a</strong> Create a <literal classes="code">Generator</literal> instance.
                    Instead of giving it the model to process, the generator needs an analysed model as its argument.
                    Retrieve the analysed model using the analyser’s <literal classes="code">model</literal> function and pass it to the generator using the <literal classes="code">setModel</literal> function.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.cpp" xml:space="preserve">    //  5.a  
    //      Create a Generator instance.  Instead of giving it the Model item to process, 
    //      the generator takes the output from the analyser.  
    //      Retrieve the analysed model using the Analyser::model() function and pass it
    //      to the generator using the Generator::setModel function.
    auto generator = libcellml::Generator::create();
    generator-&gt;setModel(analyser-&gt;model());

    //  The generator takes the CellML model and turns it into procedural code in another 
    //  language.  The default is C, but Python is available too.  This language choice is
    //  called the "profile", and is stored in a GeneratorProfile item.

    //  If you're using the C profile then you have the option at this stage 
    //  to specify the file name of the interface file you'll create in the
    //  next step.  This means that the two files will be prepared to link to
    //  one another without manual editing later.  

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.py" xml:space="preserve">    #  5.a  
    #     Create a Generator instance.  Instead of giving it the Model item to process, 
    #     the generator takes the output from the analyser.  
    #     Retrieve the analysed model using the Analyser.model() function and pass it
    #     to the generator using the Generator.setModel function.
    generator = Generator()
    generator.setModel(analyser.model())

    #  The generator takes the CellML model and turns it into procedural code in another 
    #  language.  The default is C, but Python is available too.  This language choice is
    #  called the "profile", and is stored in a GeneratorProfile item.

    #  The default profile has a C flavour, and it already exists inside the Generator you've just created.
    #  We need to edit that profile a little, but only to tell it the file name where they interface
    #  (header file) code will be written.  This is so that the implementation code (source file) knows
    #  where to look when it tries to #include it.  

</literal_block>
            </container>
            <paragraph>The generator takes the CellML model and turns it into procedural code in another language.
                The default is C, but Python is available too.
                This language choice is called the “profile”, and is stored in a <literal classes="code">GeneratorProfile</literal> item.</paragraph>
            <paragraph>The default profile already exists inside the <literal classes="code">Generator</literal> you’ve just created.
                We need to edit that profile a little, but only to tell it the file name where they interface (header file) code will be written.
                This is so that the implementation code (source file) knows where to look when it tries to include it.</paragraph>
            <container classes="dothis">
                <paragraph><strong>5.b</strong> Retrieve the C profile from the generator, and use its <literal classes="code">setInterfaceFileNameString</literal> function to pass in the same filename that you’ll use in 5.c below for the interface code.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.cpp" xml:space="preserve">    //  5.b
    //      You can do this by specifying the header file name in the GeneratorProfile item
    //      using the setInterfaceFileNameString("yourHeaderFileNameHere.h") function.
    //      This will need to be the same as the file which you write to in step 5.c below.
    auto profileC = generator-&gt;profile();
    profileC-&gt;setInterfaceFileNameString("PredatorPrey.h");

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.py" xml:space="preserve">    #  5.b
    #     Retrieve the C profile from the generator, and use its setInterfaceFileNameString function
    #     to pass in the same filename that you'll use in 5.c for the interface code.
    generator.profile().setInterfaceFileNameString('PredatorPrey.h')

</literal_block>
            </container>
            <container classes="dothis">
                <paragraph><strong>5.c</strong> Since we’re using the default profile (C), we need to output both the interface code (the header file) and the implementation code (the source file) from the generator and write them to their respective files.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.cpp" xml:space="preserve">    //  5.c 
    //      First we'll use the default profile (C), so we need to output both the
    //      interfaceCode (the header file) and the implementationCode (source file)
    //      from the generator and write them to their respective files.
    std::ofstream outFile("PredatorPrey.h");
    outFile &lt;&lt; generator-&gt;interfaceCode();
    outFile.close();

    outFile.open("PredatorPrey.c");
    outFile &lt;&lt; generator-&gt;implementationCode();
    outFile.close();

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.py" xml:space="preserve">    #  5.c
    #     First we'll use the default profile (C), so we need to output both the
    #     interfaceCode (the header file) and the implementationCode (source file)
    #     from the generator and write them to their respective files.
    implementation_code_C = generator.implementationCode()
    write_file = open("PredatorPrey.c", "w")
    write_file.write(implementation_code_C)
    write_file.close()

    interface_code = generator.interfaceCode()
    write_file = open("PredatorPrey.h", "w")
    write_file.write(interface_code)
    write_file.close()

</literal_block>
            </container>
            <paragraph>The generator takes the CellML model and turns it into procedural code in another language.
                The default is C, but Python is available too.
                This language choice is called the “profile”, and is stored in a <literal classes="code">GeneratorProfile</literal> item.</paragraph>
            <container classes="dothis">
                <paragraph><strong>5.d</strong> Create a <literal classes="code">GeneratorProfile</literal> item using the Profile::PYTHON enum value in the constructor.
                    Pass this profile to the <literal classes="code">setProfile</literal> function in the generator.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.cpp" xml:space="preserve">    //  5.d
    //      Create a GeneratorProfile item using the libcellml::GeneratorProfile::Profile::PYTHON
    //      enum value in the constructor.  Pass this profile to the setProfile function in the
    //      generator.
    auto profilePython =
        libcellml::GeneratorProfile::create(libcellml::GeneratorProfile::Profile::PYTHON);
    generator-&gt;setProfile(profilePython);

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.py" xml:space="preserve">    #  5.d
    #     Create a GeneratorProfile item using the libcellml.GeneratorProfile.Profile.PYTHON
    #     enum value in the constructor.  Pass this profile to the setProfile function in the
    #     generator.
    profile = GeneratorProfile(GeneratorProfile.Profile.PYTHON)
    generator.setProfile(profile)

</literal_block>
            </container>
            <container classes="dothis">
                <paragraph><strong>5.e</strong> Retrieve the Python implementation code (there is no header file) and write to a <literal classes="code">*.py</literal> file.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.cpp" xml:space="preserve">    //  5.e
    //      Retrieve the Python implementation code (there is no header file) and write to a *.py file.
    outFile.open("PredatorPrey.py");
    outFile &lt;&lt; generator-&gt;implementationCode();
    outFile.close();

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial3/tutorial3_complete.py" xml:space="preserve">    #  5.d
    #     Create a GeneratorProfile item using the libcellml.GeneratorProfile.Profile.PYTHON
    #     enum value in the constructor.  Pass this profile to the setProfile function in the
    #     generator.
    profile = GeneratorProfile(GeneratorProfile.Profile.PYTHON)
    generator.setProfile(profile)

    #  5.e
    #     Retrieve the Python implementation code (there is no header file) and write to a *.py file.
    implementation_code_python = generator.implementationCode()
    write_file = open("PredatorPrey.py", "w")
    write_file.write(implementation_code_python)

</literal_block>
            </container>
            <container classes="dothis">
                <paragraph>Go and have a cuppa, you’re done!</paragraph>
            </container>
        </section>
    </section>
</document>
