<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.16 -->
<document source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code_snippets/snippet_solve.rst">
    <target refid="snippet-solve"></target>
    <container classes="toggle" ids="snippet-solve" names="snippet_solve">
        <container classes="header-left">
            <paragraph>Perform the integration and output</paragraph>
        </container>
        <container classes="sphinx-tabs">
            <container classes="dummy">
                <container classes="item">
                    <container classes="dummy">
                        <paragraph>C++ snippet</paragraph>
                    </container>
                </container>
                <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-0-0 active">
                    <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/solver/solveGeneratedModel.cpp" xml:space="preserve">    // Numerically integrate the state variables using the Euler method to step through the solution.

    // Solution columns in output file
    for (size_t step = 1; step &lt; stepCount; ++step) {
        time = step * stepSize;
        computeRates(time, myStateVariables, myRates, myVariables);
        outFile &lt;&lt; step &lt;&lt; "\t " &lt;&lt; time;
        for (size_t s = 0; s &lt; STATE_COUNT; ++s) {
            myStateVariables[s] = myStateVariables[s] + myRates[s] * stepSize;
            outFile &lt;&lt; "\t" &lt;&lt; myStateVariables[s];
        }
        // The variables in the "myVariables" array are those which do not affect the calculation
        // of rates or state variables.  They only need to be computed when outputting the 
        // results of a timestep: if you're not saving every timestep, then you can skip this
        // until you are.
        computeVariables(time, myStateVariables, myRates, myVariables); 
        for (size_t s = 0; s &lt; VARIABLE_COUNT; ++s) {
            outFile &lt;&lt; "\t" &lt;&lt; myVariables[s];
        }
        outFile &lt;&lt; "\n";
    }
    outFile.close();

    // Housekeeping.

    deleteArray(myStateVariables);
    deleteArray(myVariables);
    deleteArray(myRates);

</literal_block>
                    <paragraph>Full context: <download_reference filename="a7dbe8fe8475e1fe24e8555329aec747/solveGeneratedModel.cpp" refdoc="howto/code_snippets/snippet_solve" refdomain="" refexplicit="True" reftarget="../code/solver/solveGeneratedModel.cpp" reftype="download" refwarn="False"><literal classes="xref download">example_solveGeneratedModel.cpp</literal></download_reference></paragraph>
                </container>
            </container>
            <container classes="dummy">
                <container classes="item">
                    <container classes="dummy">
                        <paragraph>Python snippet</paragraph>
                    </container>
                </container>
                <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-0-1">
                    <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/solver/solveGeneratedModel.py" xml:space="preserve">    # Numerically integrate using Euler steps to solve the model.
    for step in range(0, n):
        time = step * dt

        model.compute_rates(time, my_state_variables, my_rates, my_variables)

        # Formatting for output.
        row = '{}\t{}'.format(step, time)
        for s in range(0, model.STATE_COUNT):
            my_state_variables[s] = my_state_variables[s] + \
                my_rates[s] * dt
            row += '\t{}'.format(my_state_variables[s])

        # Note that the variables in the my_variables array are those which 
        # are independent of the integration: thus, they only need to be
        # computed at timesteps where the solution is to be written to the
        # output.  For large simulations, this may not be every integration 
        # timestep.
        model.compute_variables(
            time, my_state_variables, my_rates, my_variables)

        # Output the solution.
        for s in range(0, model.VARIABLE_COUNT):
            row += '\t{}'.format(my_variables[s])

        row += '\n'
        write_file.write(row)

    write_file.close()

</literal_block>
                    <paragraph>Full context: <download_reference filename="7d9d1af31caf4d3023ce09f83b103903/solveGeneratedModel.py" refdoc="howto/code_snippets/snippet_solve" refdomain="" refexplicit="True" reftarget="../code/solver/solveGeneratedModel.py" reftype="download" refwarn="False"><literal classes="xref download">example_solveGeneratedModel.py</literal></download_reference></paragraph>
                </container>
            </container>
        </container>
    </container>
</document>
