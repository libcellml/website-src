<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.16 -->
<document source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/user_profiles/users_annotation_tool_dev.rst">
    <target refid="users-annotation-tool-dev"></target>
    <section ids="annotation-tool-developer users-annotation-tool-dev" names="annotation\ tool\ developer users_annotation_tool_dev">
        <title>Annotation tool developer</title>
        <paragraph>This example walks through the processes involved in preparing a CellML model for annotation.
            Any item in the model which requires annotation needs to have a unique ID string, so the chief business of the <literal classes="code">Annotator</literal> class is working with the id attributes.
            In all other parts of libCellML, items are retrieved from their parents using either their index or their name.
            In the <literal classes="code">Annotator</literal>, the ID string is used instead.
            Because an item of any type could have an ID attribute, there is no way of knowing what kind of will be returned.
            The class makes use of casting to and from the (C++ only) <reference internal="False" refuri="https://en.cppreference.com/w/cpp/utility/any">std::any type</reference> to handle this uncertainty.</paragraph>
        <container classes="directorylist">
            <paragraph><strong>C++ resources</strong></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><download_reference filename="61b55b25a3aa0bf359ae2b69dcce7f5a/CMakeLists.txt" refdoc="howto/user_profiles/users_annotation_tool_dev" refdomain="" refexplicit="True" reftarget="../code/annotation_tool_dev/CMakeLists.txt" reftype="download" refwarn="False"><literal classes="xref download">CMakeLists.txt</literal></download_reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><download_reference filename="6b67da2fbfc46841482035367c333f90/annotationToolDev.cpp" refdoc="howto/user_profiles/users_annotation_tool_dev" refdomain="" refexplicit="True" reftarget="../code/annotation_tool_dev/annotationToolDev.cpp" reftype="download" refwarn="False"><literal classes="xref download">annotationToolDev.cpp</literal></download_reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph>resources/</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph><download_reference filename="d52db739781576a602600793f15a5c67/annotationExample.cellml" refdoc="howto/user_profiles/users_annotation_tool_dev" refdomain="" refexplicit="True" reftarget="../code/annotation_tool_dev/annotationExample.cellml" reftype="download" refwarn="False"><literal classes="xref download">annotationExample.cellml</literal></download_reference></paragraph>
                        </list_item>
                    </bullet_list>
                </list_item>
            </bullet_list>
            <paragraph><strong>Python resources</strong></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><download_reference filename="9dc110dc198bcd3d887e60d6cb882e58/annotationToolDev.py" refdoc="howto/user_profiles/users_annotation_tool_dev" refdomain="" refexplicit="True" reftarget="../code/annotation_tool_dev/annotationToolDev.py" reftype="download" refwarn="False"><literal classes="xref download">annotationToolDev.py</literal></download_reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph>resources/</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph><download_reference filename="d52db739781576a602600793f15a5c67/annotationExample.cellml" refdoc="howto/user_profiles/users_annotation_tool_dev" refdomain="" refexplicit="True" reftarget="../code/annotation_tool_dev/annotationExample.cellml" reftype="download" refwarn="False"><literal classes="xref download">annotationExample.cellml</literal></download_reference></paragraph>
                        </list_item>
                    </bullet_list>
                </list_item>
            </bullet_list>
        </container>
        <section ids="parse-an-existing-cellml-model" names="parse\ an\ existing\ cellml\ model">
            <title>Parse an existing CellML model</title>
            <paragraph>The first step in any annotation process is to open the model to be annotated.
                Here we use the <literal classes="code">Parser</literal> class to read the file, and deserialise the CellML into a <literal classes="code">Model</literal> object.</paragraph>
            <container classes="sphinx-tabs">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++ snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-0-0 active">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/annotation_tool_dev/annotationToolDev.cpp" xml:space="preserve">    // Parse an existing CellML model from a file.

    std::string inFileName = "annotationExample.cellml";
    std::ifstream inFile(inFileName);
    std::stringstream inFileContents;
    inFileContents &lt;&lt; inFile.rdbuf();

    auto parser = libcellml::Parser::create();
    auto model = parser-&gt;parseModel(inFileContents.str());
    printIssues(parser);

</literal_block>
                    </container>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-0-1">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/annotation_tool_dev/annotationToolDev.py" xml:space="preserve">    # Parse an existing CellML model from a file.
    read_file = open("annotationExample.cellml", "r")
    parser = Parser()
    model = parser.parseModel(read_file.read())

</literal_block>
                    </container>
                </container>
            </container>
        </section>
        <section ids="use-an-annotator-to-investigate-the-model" names="use\ an\ annotator\ to\ investigate\ the\ model">
            <title>Use an annotator to investigate the model</title>
            <paragraph>The <literal classes="code">Annotator</literal> class is fundamentally different from other libCellML classes in that it used ID strings (as opposed to names or indices) to retrieve and manipulate items.
                It can be used to retrieve the ID string and item type to which it pertains, using the <emphasis>dictionary</emphasis> function.</paragraph>
            <container classes="sphinx-tabs">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++ snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-1-0 active">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/annotation_tool_dev/annotationToolDev.cpp" xml:space="preserve">    // Create an Annotator instance and pass the model to it for processing.
    auto annotator = libcellml::Annotator::create();
    annotator-&gt;setModel(model);

    // Retrieve a dictionary of all the id strings and the types of items they represent.
    std::vector&lt;std::string&gt; dictionary = annotator-&gt;ids();
    std::cout &lt;&lt; "Existing id strings are:" &lt;&lt; std::endl;
    for(auto &amp;i : dictionary) {
        std::cout &lt;&lt; " - " &lt;&lt; i &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; std::endl;

</literal_block>
                    </container>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-1-1">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/annotation_tool_dev/annotationToolDev.py" xml:space="preserve">    # Create an Annotator instance and pass the model to it for processing.
    annotator = Annotator()
    annotator.setModel(model)

    # Retrieve a dictionary of all the id strings and the types of items they represent.
    dictionary = annotator.dictionary()
    print('Existing id strings are:')
    for i, itemType in dictionary:
        print(' {} = {}'.format(i, itemType))
    print()

</literal_block>
                        <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">Existing id strings are:
   beige = connection
   black = component_ref
   blue = unit
   brown = encapsulation
   duplicateId1 = units
   duplicateId1 = component
   duplicateId2 = connection
   duplicateId2 = variable
   duplicateId3 = import
   duplicateId3 = units
   duplicateId3 = variable
   duplicateId4 = component
   duplicateId4 = map_variables
   green = units
   indigo = variable
   mauve = test_value
   orange = import
   puce = map_variables
   red = model
   taupe = reset_value
   violet = reset
   yellow = component</literal_block>
                    </container>
                </container>
            </container>
        </section>
        <section ids="retrieve-items-by-id-known-type" names="retrieve\ items\ by\ id\ (known\ type)">
            <title>Retrieve items by id (known type)</title>
            <paragraph>When you know the type of item which is assigned a certain ID, it is straightforward to fetch that item from the <literal classes="code">Annotator</literal> using any of the type-specific functions, as shown below.
                A null pointer will be returned if the item does not have the type requested, or if its ID does not exist in the model.</paragraph>
            <container classes="sphinx-tabs">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++ snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-2-0 active">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/annotation_tool_dev/annotationToolDev.cpp" xml:space="preserve">    // Retrieve items by their id where the item type is known.

    // Retrieve a component with the id of "yellow". We can only do this because 
    // we have prior knowledge that the item with id of "yellow" is actually 
    // a Component.  
    auto component = annotator-&gt;component("yellow");

    // The same applies to the other item types below.
    auto variable = annotator-&gt;variable("indigo");
    auto reset = annotator-&gt;reset("violet");
    auto import = annotator-&gt;importSource("orange");
    auto units = annotator-&gt;units("green");
    auto anotherModel = annotator-&gt;model("red");
    auto unit = annotator-&gt;unit("blue");
    auto connection = annotator-&gt;connection("beige");
    auto mapVariables = annotator-&gt;mapVariables("puce");

    // Some kinds of items are returned by their parent item.  These are:
    //  - componentRef: returns the Component with this id on its encapsulation item.
    auto componentRef = annotator-&gt;componentRef("black");

    //  - encapsulation: returns the Model with this id on its encapsulation item.
    auto encapsulation = annotator-&gt;encapsulation("brown");

    //  - resetValue: returns the Reset with this id on its reset value.
    auto resetValue = annotator-&gt;resetValue("taupe");

    //  - testValue: returns the Reset with this id on its test value.
    auto testValue = annotator-&gt;testValue("mauve");
    
    // In this example reset, resetValue and testValue will be the same because the
    // "taupe" reset value and "mauve" test value are in the "violet" reset item.

</literal_block>
                    </container>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-2-1">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/annotation_tool_dev/annotationToolDev.py" xml:space="preserve">    # Retrieve items by their id where the item type is known.

    # Retrieve a component with the id of 'yellow'. We can only do this because 
    # we have prior knowledge that the item with id of 'yellow' is actually 
    # a Component.  
    component = annotator.component('yellow')

    # The same applies to the other item types below.
    variable = annotator.variable('indigo')
    reset = annotator.reset('violet')
    importSource = annotator.importSource('orange')
    units = annotator.units('green')
    unit = annotator.unit('blue')
    connection = annotator.connection('beige')
    mapVariables = annotator.mapVariables('puce')

    # Some kinds of items are returned by their parent item.  These are:
    #  - componentRef: returns the Component with this id on its encapsulation item.
    componentRef = annotator.componentRef('black')

    #  - encapsulation: returns the Model with this id on its encapsulation item.
    encapsulation = annotator.encapsulation('brown')

    #  - resetValue: returns the Reset with this id on its reset value.
    resetValue = annotator.resetValue('taupe')

    #  - testValue: returns the Reset with this id on its test value.
    testValue = annotator.testValue('mauve')
    
    # In this example reset, resetValue and testValue will be the same because the
    # 'taupe' reset value and 'mauve' test value are in the 'violet' reset item.
    
</literal_block>
                        <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">The name of the component with id of "yellow" is "component3".</literal_block>
                    </container>
                </container>
            </container>
        </section>
        <section ids="retrieve-items-by-id-unknown-type" names="retrieve\ items\ by\ id\ (unknown\ type)">
            <title>Retrieve items by id (unknown type)</title>
            <paragraph>It’s more likely that you won’t know the type of item to which a given ID relates, so will need to use the generic <emphasis>item</emphasis> function to retrieve it.
                This returns two pieces of information: the first is the appropriate <literal classes="code">CellMLElements</literal> enum value for the type, and the second is the item itself cast into the <reference internal="False" refuri="https://en.cppreference.com/w/cpp/utility/any">std::any type</reference> (in C++).
                In Python, the returned item requires no further transformation.</paragraph>
            <container classes="sphinx-tabs">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++ snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-3-0 active">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/annotation_tool_dev/annotationToolDev.cpp" xml:space="preserve">    // Dealing with unique id strings where the item has an unknown type.
    libcellml::AnyItem itemOfUnknownType;

    // Check that the id is unique in the model scope:
    if(annotator-&gt;isUnique("green")){
        // Retrieve item from the annotator by its unique id.
        itemOfUnknownType = annotator-&gt;item("green");
        std::cout &lt;&lt; "The item with id 'green' has type: "&lt;&lt; getCellmlElementTypeFromEnum(itemOfUnknownType.first) &lt;&lt; std::endl;
    }
    
    // Because these could be any kind of item, they are stored in an AnyItem
    // type.  This is a pair, where the first item is a CellmlElementType enum 
    // indicating the item's type, and the second is a std::any cast containing the
    // item itself. 

    // If you don't know the item type, you need to declare all possible types
    // outside of the switch (in this example we're using things we've declared earlier).

    switch(itemOfUnknownType.first) {
        case libcellml::CellmlElementType::COMPONENT:
            component = std::any_cast&lt;libcellml::ComponentPtr&gt;(itemOfUnknownType.second);
            break;
        case libcellml::CellmlElementType::COMPONENT_REF:
            componentRef = std::any_cast&lt;libcellml::ComponentPtr&gt;(itemOfUnknownType.second);
            break;
        case libcellml::CellmlElementType::CONNECTION:
            connection = std::any_cast&lt;libcellml::VariablePairPtr&gt;(itemOfUnknownType.second);
            break;
        case libcellml::CellmlElementType::MAP_VARIABLES:
            mapVariables = std::any_cast&lt;libcellml::VariablePairPtr&gt;(itemOfUnknownType.second);
            break;
        case libcellml::CellmlElementType::IMPORT:
            import = std::any_cast&lt;libcellml::ImportSourcePtr&gt;(itemOfUnknownType.second);
            break;
        case libcellml::CellmlElementType::ENCAPSULATION:
            encapsulation = std::any_cast&lt;libcellml::ModelPtr&gt;(itemOfUnknownType.second);
            break;
        case libcellml::CellmlElementType::MATH:
            component = std::any_cast&lt;libcellml::ComponentPtr&gt;(itemOfUnknownType.second);
            break;
        case libcellml::CellmlElementType::MODEL:
            anotherModel = std::any_cast&lt;libcellml::ModelPtr&gt;(itemOfUnknownType.second);
            break;
        case libcellml::CellmlElementType::RESET:
            reset = std::any_cast&lt;libcellml::ResetPtr&gt;(itemOfUnknownType.second);
            break;
        case libcellml::CellmlElementType::RESET_VALUE:
            resetValue = std::any_cast&lt;libcellml::ResetPtr&gt;(itemOfUnknownType.second);
            break;
        case libcellml::CellmlElementType::TEST_VALUE:
            testValue = std::any_cast&lt;libcellml::ResetPtr&gt;(itemOfUnknownType.second);
            break;
        case libcellml::CellmlElementType::UNIT:
            unit = std::any_cast&lt;libcellml::UnitPtr&gt;(itemOfUnknownType.second);
            break;
        case libcellml::CellmlElementType::UNITS:
            units = std::any_cast&lt;libcellml::UnitsPtr&gt;(itemOfUnknownType.second);
            break;
        case libcellml::CellmlElementType::VARIABLE:
            variable = std::any_cast&lt;libcellml::VariablePtr&gt;(itemOfUnknownType.second);
            break;
        case libcellml::CellmlElementType::UNDEFINED:
            break;
    }
    std::cout &lt;&lt; std::endl;

</literal_block>
                    </container>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-3-1">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/annotation_tool_dev/annotationToolDev.py" xml:space="preserve">    # Dealing with unique id strings where the item has an unknown type.

    # Check that the id is unique in the model scope:
    if annotator.isUnique('green'):
        # Retrieve item from the annotator by their unique id.
        itemOfUnknownType = annotator.item('green')

    # Because these could be any kind of item, they are stored in an AnyItem
    # type.  This is a tuple, where the first item is a CellmlElementType enum 
    # indicating the item's type, and the second is the item itself. 

    # The type can be turned into a string using the Annotator.typeAsString 
    # function on the first item in the tuple.
    print('The item with id of "green" has type of "{}".'.format(annotator.typeAsString(itemOfUnknownType[0])))
    print()

</literal_block>
                        <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">The item with id of "green" has type of "units".</literal_block>
                    </container>
                </container>
            </container>
        </section>
        <section ids="handle-duplicated-id-attributes" names="handle\ duplicated\ id\ attributes">
            <title>Handle duplicated ID attributes</title>
            <paragraph>Duplicated IDs in any XML document are not permitted, and CellML is no different.
                There are several tools to support users in removing duplicates from their models.
                The code snippet below uses the annotator to return a set of ID strings which have been duplicated within the model scope, and then uses the collective and generic function <emphasis>items</emphasis> to return all of them.
                From here, the items can be assigned an automatically generated ID string which is guaranteed to be unique within the model scope.
                Of course, you can also set the id of these items manually too if you’d rather.</paragraph>
            <container classes="sphinx-tabs">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++ snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-4-0 active">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/annotation_tool_dev/annotationToolDev.cpp" xml:space="preserve">    // Handling duplicate ID strings.

    // Find any duplicated ID strings inside the model.
    auto duplicatedIds = annotator-&gt;duplicateIds();

    std::cout &lt;&lt; "There are " &lt;&lt; duplicatedIds.size() &lt;&lt; " duplicated ids in the model." &lt;&lt; std::endl;
    for(auto const &amp;id : duplicatedIds) {
        std::cout &lt;&lt; " - " &lt;&lt; id &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; std::endl;

    // Retrieve all items with the given id string. This returns a std::vector
    // of AnyItems which will need to be cast into libcellml items before they
    // can be used.  Note that duplicated ids are not valid CellML, and need 
    // to be fixed before the model can be used.
    auto allItemsWithDuplicateId1 = annotator-&gt;items("duplicateId1");

    // A new id string which is automatically generated and unique can be
    // assigned to these items.
    std::cout &lt;&lt; "There are " &lt;&lt; allItemsWithDuplicateId1.size() &lt;&lt; " items with an id of 'duplicateId1'." &lt;&lt; std::endl;
    for(auto &amp; i: allItemsWithDuplicateId1) {
        annotator-&gt;assignId(i);
    }
    // Now there are no more items with the duplicated id "duplicateId1"
    // remaining in the model.
    allItemsWithDuplicateId1 = annotator-&gt;items("duplicateId1");
    std::cout &lt;&lt; "After assigning a new id, there are " &lt;&lt; allItemsWithDuplicateId1.size() &lt;&lt; " items with an id of 'duplicateId1'." &lt;&lt; std::endl;

    // It's straightforward to use a double loop to automatically assign new and unique ids to
    // any duplicated ids in the model.
    for(auto &amp;id: duplicatedIds){
        auto itemsWithThisId = annotator-&gt;items(id);
        for(auto &amp;item : itemsWithThisId){
            annotator-&gt;assignId(item);
        }
    }

    // Get the list of duplicates again.
    duplicatedIds = annotator-&gt;duplicateIds();
    std::cout &lt;&lt; "After assigning new ids, there are " &lt;&lt; duplicatedIds.size() &lt;&lt; " duplicated ids in the model." &lt;&lt; std::endl;
    std::cout &lt;&lt; std::endl;

</literal_block>
                    </container>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-4-1">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/annotation_tool_dev/annotationToolDev.py" xml:space="preserve">    # Handling duplicate ID strings.

    # Find any duplicated ID strings inside the model.
    duplicatedIds = annotator.duplicateIds()
    print('There are {} duplicated ids in the model.'.format(len(duplicatedIds)))
    for i in duplicatedIds:
        print(' - ' + i)
    print()

    # Retrieve all items with the given id string. This returns a std.vector
    # of AnyItems which will need to be cast into libcellml items before they
    # can be used.  Note that duplicated ids are not valid CellML, and need 
    # to be fixed before the model can be used.
    allItemsWithDuplicateId1 = annotator.items('duplicateId1')

    # A new id string which is automatically generated and unique can be
    # assigned to these items.
    print('Before assigning automatic ids there are {} items with an id of "duplicateId1".'.format(annotator.itemCount('duplicateId1')))
    for item in allItemsWithDuplicateId1:
        annotator.assignId(item)
    
    # Now there are no more items with the duplicated id 'duplicateId1'
    # remaining in the model.
    allItemsWithDuplicateId1 = annotator.items('duplicateId1')
    print('After assigning automatic ids there are {} items with an id of "duplicateId1".'.format(annotator.itemCount('duplicateId1')))

    # It's straightforward to use a double loop to automatically assign new and unique ids to
    # any duplicated ids in the model.
    duplicatedIds = annotator.duplicateIds()
    for i in duplicatedIds:
        itemsWithThisId = annotator.items(i)
        for item in itemsWithThisId:
            annotator.assignId(item)

    # Get the list of duplicates again.
    duplicatedIds = annotator.duplicateIds()
    print('After fixing all duplicates there are {} duplicated ids in the model.'.format(len(duplicatedIds)))
    print()

</literal_block>
                        <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">There are 4 duplicated ids in the model.
- duplicateId1
- duplicateId2
- duplicateId3
- duplicateId4

Before assigning automatic ids there are 2 items with an id of "duplicateId1".
After assigning automatic ids there are 0 items with an id of "duplicateId1".
After fixing all duplicates there are 0 duplicated ids in the model.</literal_block>
                    </container>
                </container>
            </container>
        </section>
        <section ids="automatically-assign-unique-ids-in-bulk" names="automatically\ assign\ unique\ ids\ in\ bulk">
            <title>Automatically assign unique IDs in bulk</title>
            <paragraph>In addition to using the automatic ID generation on individual items as shown above, you can also use it for all items of a certain type.
                The example below shows how calling the <emphasis>assignIds</emphasis> function for the <literal classes="code">CellmlElementType COMPONENT</literal> type fills in the missing ID from <literal classes="code">component2</literal> without changing the IDs of the other components.
                Finally, IDs for every item in a model can be set with the <emphasis>assignAllIds</emphasis> function, and cleared from every item using the <emphasis>clearAllIds</emphasis> function.</paragraph>
            <container classes="sphinx-tabs">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++ snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-5-0 active">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/annotation_tool_dev/annotationToolDev.cpp" xml:space="preserve">    // Automatically assign id strings to anything without them in the model.
    // This can be done by item type (eg: all the components, all the resets, etc)
    // or en masse to everything (excluding MathML) which can have an id attribute.
    
    // Print all component ids to the terminal.
    std::cout &lt;&lt; "Before automatic ids are assigned:" &lt;&lt; std::endl;
    std::cout &lt;&lt; "  Component 1: "&lt;&lt; model-&gt;component("component1")-&gt;id() &lt;&lt; std::endl;
    std::cout &lt;&lt; "  Component 2: "&lt;&lt; model-&gt;component("component2")-&gt;id() &lt;&lt; std::endl;
    std::cout &lt;&lt; "  Component 3: "&lt;&lt; model-&gt;component("component3", true)-&gt;id() &lt;&lt; std::endl;
    std::cout &lt;&lt; "  Component 4: "&lt;&lt; model-&gt;component("component4")-&gt;id() &lt;&lt; std::endl &lt;&lt; std::endl;

    // Assigns an automatic id string to all Component items which don't already have one.
    annotator-&gt;assignIds(libcellml::CellmlElementType::COMPONENT);

    std::cout &lt;&lt; "After automatic ids are assigned to component items:" &lt;&lt; std::endl;
    std::cout &lt;&lt; "  Component 1: "&lt;&lt; model-&gt;component("component1")-&gt;id() &lt;&lt; std::endl;
    std::cout &lt;&lt; "  Component 2: "&lt;&lt; model-&gt;component("component2")-&gt;id() &lt;&lt; std::endl;
    std::cout &lt;&lt; "  Component 3: "&lt;&lt; model-&gt;component("component3", true)-&gt;id() &lt;&lt; std::endl;
    std::cout &lt;&lt; "  Component 4: "&lt;&lt; model-&gt;component("component4")-&gt;id() &lt;&lt; std::endl &lt;&lt; std::endl;

    auto numberOfIds = annotator-&gt;ids().size();
    std::cout &lt;&lt; "Before assigning all automatic ids, there are " &lt;&lt; numberOfIds &lt;&lt;" items with an id attribute." &lt;&lt; std::endl;

    // Automatically assign ids to everything in the model without one already.
    annotator-&gt;assignAllIds();

    // Check the dictionary again.
    numberOfIds = annotator-&gt;ids().size();
    std::cout &lt;&lt; "After assigning all automatic ids, there are " &lt;&lt; numberOfIds &lt;&lt;" items with an id attribute." &lt;&lt; std::endl;

    // Completely clear all ids in the model.
    annotator-&gt;clearAllIds();
    numberOfIds = annotator-&gt;ids().size();
    std::cout &lt;&lt; "After clearing all ids, there are " &lt;&lt; numberOfIds &lt;&lt;" items with an id attribute." &lt;&lt; std::endl &lt;&lt; std::endl;

</literal_block>
                    </container>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-5-1">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/annotation_tool_dev/annotationToolDev.py" xml:space="preserve">    # Automatically assign id strings to anything without them in the model.
    # This can be done by item type (eg: all the components, all the resets, etc)
    # or en masse to everything (excluding MathML) which can have an id attribute.
    
    # Print all component ids to the terminal.
    print('Before automatic ids are assigned by type:')
    print('  Component 1: {}'.format(model.component('component1').id()))
    print('  Component 2: {}'.format(model.component('component2').id()))
    print('  Component 3: {}'.format(model.component('component2').component('component3').id()))
    print('  Component 4: {}'.format(model.component('component4').id()))

    # Assigns an automatic id string to all Component items which don't already have one.
    annotator.assignIds(CellmlElementType.COMPONENT)

    print('After automatic ids are assigned to component items:')
    print('  Component 1: {}'.format(model.component('component1').id()))
    print('  Component 2: {}'.format(model.component('component2').id()))
    print('  Component 3: {}'.format(model.component('component2').component('component3').id()))
    print('  Component 4: {}'.format(model.component('component4').id()))
    print()

    numberOfIds = len(annotator.dictionary())
    print('Before assigning all automatic ids, there are {} items with an id attribute.'.format(numberOfIds))

    # Automatically assign ids to everything in the model without one already.
    annotator.assignAllIds()

    # Check the dictionary again.
    numberOfIds = len(annotator.dictionary())
    print('After assigning all automatic ids, there are {} items with an id attribute.'.format(numberOfIds))

    # Completely clear all ids in the model.
    annotator.clearAllIds()
    numberOfIds = len(annotator.dictionary())
    print('After clearing all ids, there are {} items with an id attribute.'.format(numberOfIds))

</literal_block>
                        <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">Before automatic ids are assigned by type:
   Component 1: b4da56
   Component 2:
   Component 3: yellow
   Component 4: b4da5c
After automatic ids are assigned to component items:
   Component 1: b4da56
   Component 2: b4da5e
   Component 3: yellow
   Component 4: b4da5c

Before assigning all automatic ids, there are 24 items with an id attribute.
After assigning all automatic ids, there are 31 items with an id attribute.
After clearing all ids, there are 0 items with an id attribute.</literal_block>
                    </container>
                </container>
            </container>
        </section>
    </section>
</document>
