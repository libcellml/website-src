<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.16 -->
<document source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/snippets/snippet_annotator_find_item_unknown_type.rst">
    <target refid="snippet-annotator-find-item-unknown-type"></target>
    <container classes="toggle" ids="snippet-annotator-find-item-unknown-type" names="snippet_annotator_find_item_unknown_type">
        <container classes="header-left">
            <paragraph>Retrieve an item of unknown type by id</paragraph>
        </container>
        <paragraph>In situations where you have an id string, but donâ€™t know the type of the object it identifies, the item can be retrieved using a general <literal classes="code">Annotator::item(itemId)</literal> function.
            The general <literal classes="code">item</literal> function will return an <literal classes="code">AnyItem</literal> pair.
            The first part of the pair is an enum of the type of the object.
            The second part is an <literal classes="code">std::any</literal> type object, which can be cast into the correct type.
            This is demonstrated below.</paragraph>
        <container classes="sphinx-tabs">
            <container classes="dummy">
                <container classes="item">
                    <container classes="dummy">
                        <paragraph>C++</paragraph>
                    </container>
                </container>
                <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                </container>
                <literal_block force="False" highlight_args="{}" language="c++" linenos="False" xml:space="preserve">// Create an Annotator.
auto annotator = libcellml::Annotator::create();

// Build the annotator to work with the model.
annotator-&gt;buildModelIndex(model);

// Retrieve an item of unknown type from the annotator.
auto anyItem = annotator-&gt;item("findThisId");

// Depending on the item's type (which is stored in the first part of the AnyItem
// pair), cast the second part to the appropriate pointer type. Note that this means
// first declaring a range of variables of different types to which the cast
// pointer can be assigned.

libcellml::ComponentPtr itemComponent;
libcellml::VariablePtr itemVariable;
libcellml::ResetPtr itemReset;
libcellml::UnitsPtr itemUnits;
libcellml::ImportSourcePtr itemImportSource;
libcellml::VariablePair itemVariablePair;
libcellml::Unit itemUnit;

switch (anyItem.first) {
    case libcellml::Annotator::Type::COMPONENT:
    case libcellml::Annotator::Type::COMPONENT_REF:
        itemComponent = std::any_cast&lt;libcellml::ComponentPtr&gt;(anyItem.second);
        break;
    case libcellml::Annotator::Type::CONNECTION:
    case libcellml::Annotator::Type::MAP_VARIABLES:
        itemVariablePair = std::any_cast&lt;libcellml::VariablePair&gt;(anyItem.second);
        break;
    case libcellml::Annotator::Type::IMPORT:
        itemImportItem = std::any_cast&lt;libcellml::ImportSourcePtr&gt;(anyItem.second);
        break;
    case libcellml::Annotator::Type::ENCAPSULATION:
    case libcellml::Annotator::Type::MODEL:
        itemModel = std::any_cast&lt;libcellml::ModelPtr&gt;(anyItem.second);
        break;
    case libcellml::Annotator::Type::RESET:
    case libcellml::Annotator::Type::RESET_VALUE:
    case libcellml::Annotator::Type::TEST_VALUE:
        itemReset = std::any_cast&lt;libcellml::ResetPtr&gt;(anyItem.second);
        break;
    case libcellml::Annotator::Type::UNIT:
        itemUnit = std::any_cast&lt;libcellml::Unit&gt;(anyItem.second);
        break;
    case libcellml::Annotator::Type::UNITS:
        itemUnits = std::any_cast&lt;libcellml::UnitsPtr&gt;(anyItem.second);
        break;
    case libcellml::Annotator::Type::VARIABLE:
        itemVariable = std::any_cast&lt;libcellml::VariablePtr&gt;(anyItem.second);
        break;
    }
}

// Note also that attempting to cast into the wrong type will trigger a
// "bad any cast" exception.
try {
    assert(itemVariable.first == Annotator::Type::VARIABLE);
    auto thisWillNotWork = std::any_cast&lt;libcellml::UnitsPtr&gt;(itemVariable.second);
}
catch(const std::bad_any_cast&amp; e) {
    // Depending on your system, this will return a "bad any cast", "bad any_cast"
    // or "bad_any_cast" message.
    std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
}</literal_block>
            </container>
            <container classes="dummy">
                <container classes="item">
                    <container classes="dummy">
                        <paragraph>Python</paragraph>
                    </container>
                </container>
                <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                </container>
                <literal_block force="False" highlight_args="{}" language="py" linenos="False" xml:space="preserve"># TODO</literal_block>
            </container>
        </container>
    </container>
</document>
