<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.16 -->
<document source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/actions/solve_model.rst">
    <target refid="solve-model"></target>
    <section ids="interact-with-generated-code" names="interact\ with\ generated\ code">
        <title>Interact with generated code</title>
        <topic classes="contents local" ids="contents" names="contents">
            <bullet_list>
                <list_item>
                    <paragraph><reference ids="id1" refid="interface-with-the-generated-code">Interface with the generated code</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id2" refid="set-solution-parameters">Set solution parameters</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id3" refid="initialise-solution-variables">Initialise solution variables</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id4" refid="compute-the-starting-values-of-variables">Compute the starting values of variables</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id5" refid="prepare-files-for-output">Prepare files for output</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id6" refid="perform-the-integration">Perform the integration</reference></paragraph>
                </list_item>
            </bullet_list>
        </topic>
        <section ids="interface-with-the-generated-code" names="interface\ with\ the\ generated\ code">
            <title refid="id1">Interface with the generated code</title>
            <paragraph>The generated code only represents the mathematical formulation of the model, so in order to find its solution it must be connected to an integration algorithm.
                This integration is not provided, but some basic functions to interact with the model are.
                Depending on whether youâ€™re using C++ or Python, the generated code must either be compiled with your solver, or imported as a module.</paragraph>
            <target refid="snippet-build-solver"></target>
            <container classes="toggle" ids="snippet-build-solver" names="snippet_build_solver">
                <container classes="header-left">
                    <paragraph>Build a solver using generated code</paragraph>
                </container>
                <container classes="sphinx-tabs">
                    <container classes="dummy">
                        <container classes="item">
                            <container classes="dummy">
                                <paragraph>C++ snippet</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-0-0 active">
                            <paragraph>This file should be saved as a CMakeLists.txt file for generation with CMake.</paragraph>
                            <literal_block force="False" highlight_args="{'linenostart': 1}" language="cmake" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/solver/CMakeLists.txt" xml:space="preserve">cmake_minimum_required(VERSION 3.10.2)
# Delete the previous cache and configured files from this directory before configuring again
# I don't know why it doesn't work ... TODO
file(REMOVE [CMakeCache.txt Makefile cmake_install.cmake modelToSolve.cpp *.h])
file(REMOVE_RECURSE [CMakeFiles])

set(INPUT "" CACHE FILEPATH "Please enter the base name of the generated files to solve (without extension) using the syntax -DINPUT=your_filename")

if("${INPUT}" STREQUAL "")
        message(FATAL_ERROR "Please enter the base name of the generated files to solve (without extension) using the syntax -DINPUT=your_filename")
endif()

get_filename_component(INPUTNAME ${INPUT} NAME)
get_filename_component(INPUTDIR ${INPUT} DIRECTORY)

set(PROJECT_NAME solve_${INPUTNAME})

project(${PROJECT_NAME} VERSION 0.1.0)

if(EXISTS "${INPUTDIR}/${INPUTNAME}.c")
        configure_file("${INPUTDIR}/${INPUTNAME}.c" "${CMAKE_BINARY_DIR}/modelToSolve.cpp" COPYONLY)
elseif(EXISTS "${INPUTDIR}/${INPUTNAME}.cpp")
        configure_file("${INPUTDIR}/${INPUTNAME}.cpp" "${CMAKE_BINARY_DIR}/modelToSolve.cpp" COPYONLY)
endif()

configure_file("${INPUTDIR}/${INPUTNAME}.h" "${CMAKE_BINARY_DIR}/modelToSolve.h" COPYONLY)
configure_file("${INPUTDIR}/${INPUTNAME}.h" "${CMAKE_BINARY_DIR}/${INPUTNAME}.h" COPYONLY)
# TODO This line is a workaround because at present the generator expects the header file to be called "model.h"
# We don't want users to have to modify the generated code, so until there's a better way for users to set
# this in the API, this should stay here.  Yes, it's super-clumsy :(
configure_file("${INPUTDIR}/${INPUTNAME}.h" "${CMAKE_BINARY_DIR}/model.h" COPYONLY)

set (PROJECT_SRC
        solveGeneratedModel.cpp
        modelToSolve.cpp
     )

add_executable(${PROJECT_NAME} ${PROJECT_SRC})

message("")
message("1) First use 'make -j' to build the executable")
message("2) Then solve by running: ./${PROJECT_NAME} with the arguments:")
message("  -n  step_total")
message("  -dt step_size")
message("")
</literal_block>
                        </container>
                    </container>
                    <container classes="dummy">
                        <container classes="item">
                            <container classes="dummy">
                                <paragraph>Python snippet</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-0-1">
                            <literal_block force="False" highlight_args="{'linenostart': 67}" language="python" linenos="True" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/solver/solveGeneratedModel.py" xml:space="preserve">def module_from_file(input):

    # Check the extension is stripped during input.
    if input[-3:] != '.py':
        module_file = input + ".py"
        module_name = input.split("/")[-1]
    else:
        module_file = input
        module_name = ".".join(input.split("/")[-1].split(".")[:-1])

    # Import the generated code as a module, and return it.
    spec = importlib.util.spec_from_file_location(module_name, module_file)
    module = importlib.util.module_from_spec(spec)
    sys.modules[module_name] = module
    spec.loader.exec_module(module)
    return module
</literal_block>
                            <paragraph>Full context: <download_reference filename="bf985e8e35271e4312b0372fa93fa13e/solveGeneratedModel.py" refdoc="howto/actions/solve_model" refdomain="" refexplicit="True" reftarget="../code/solver/solveGeneratedModel.py" reftype="download" refwarn="False"><literal classes="xref download">solveGeneratedModel.py</literal></download_reference></paragraph>
                        </container>
                    </container>
                </container>
            </container>
        </section>
        <section ids="set-solution-parameters" names="set\ solution\ parameters">
            <title refid="id2">Set solution parameters</title>
            <paragraph>In this very simple example we take the parameters for the integration step size and number of steps from command line arguments.
                Calling the function below at the start of your program retrieves the command line arguments for use at runtime.</paragraph>
            <target refid="snippet-command-line"></target>
            <container classes="toggle" ids="snippet-command-line" names="snippet_command_line">
                <container classes="header-left">
                    <paragraph>Retrieve command line parameters</paragraph>
                </container>
                <container classes="sphinx-tabs">
                    <container classes="dummy">
                        <container classes="item">
                            <container classes="dummy">
                                <paragraph>C++ snippet</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-1-0 active">
                            <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/solver/solveGeneratedModel.cpp" xml:space="preserve">std::map&lt;std::string, std::string&gt; processArguments(int argc, char **argv)
{
    if (argc == 1) {
        std::cout &lt;&lt; "Usage:" &lt;&lt; std::endl;
        std::cout &lt;&lt; "  -n maxSteps -dt stepSize" &lt;&lt; std::endl;
        std::cout &lt;&lt; "     -n     the number of steps to take before stopping" &lt;&lt; std::endl;
        std::cout &lt;&lt; "     -dt    the step size to use" &lt;&lt; std::endl;
        exit(1);
    }

    std::map&lt;std::string, std::string&gt; argMap;
    std::string value = argv[0];
    value.erase(0, 8); // removes the "solve_" from the start of the executable name to get back to the input
    argMap["input"] = value;

    for (size_t i = 0; i &lt; argc - 1; ++i) {
        if (argv[i][0] == '-') {
            std::string key = argv[i];
            key.erase(0, 1);
            value = argv[i + 1];
            argMap[key] = value;
            i++;
        }
    }
    return argMap;
}
</literal_block>
                            <paragraph>Full context: <download_reference filename="e41c673a94724b3cb8689dc9781a0b7b/solveGeneratedModel.cpp" refdoc="howto/actions/solve_model" refdomain="" refexplicit="True" reftarget="../code/solver/solveGeneratedModel.cpp" reftype="download" refwarn="False"><literal classes="xref download">example_solveGeneratedModel.cpp</literal></download_reference></paragraph>
                        </container>
                    </container>
                    <container classes="dummy">
                        <container classes="item">
                            <container classes="dummy">
                                <paragraph>Python snippet</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-1-1">
                            <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/solver/solveGeneratedModel.py" xml:space="preserve">def process_arguments(argv):

    if (len(argv) == 1):
        print("Usage:")
        print("   -m     generated file to run")
        print("   -n     the number of steps to take before stopping")
        print("   -dt    the step size to use")
        exit(0)

    arg_map = {}
    i = 0
    while i &lt; len(argv):
        if argv[i][0] == '-':
            key = argv[i][1:]
            value = argv[i + 1]
            arg_map[key] = value
            i += 1
        else:
            i += 1

    # Cleaning up the inputs to save in the right form
    error_string = ''
    try:
        arg_map['m'][-3:] == ".py"
        arg_map['m'] = arg_map['m'][:-3]
    except:
        error_string += "/n - missing argument: -m file to run"

    try:
        arg_map['n'] = int(arg_map['n'])
    except:
        error_string += "/n - missing argument: -n number of steps to take"

    try:
        arg_map['dt'] = float(arg_map['dt'])
    except:
        error_string += "/n - missing argument: -dt step size"

    if error_string != "":
        print(error_string)
        exit(1)

    return arg_map
</literal_block>
                            <paragraph>Full context: <download_reference filename="bf985e8e35271e4312b0372fa93fa13e/solveGeneratedModel.py" refdoc="howto/actions/solve_model" refdomain="" refexplicit="True" reftarget="../code/solver/solveGeneratedModel.py" reftype="download" refwarn="False"><literal classes="xref download">example_solveGeneratedModel.py</literal></download_reference></paragraph>
                        </container>
                    </container>
                </container>
            </container>
            <paragraph>The specific parameters related to the model are available within the generated code, and can be retrieved from their structures as shown below.</paragraph>
            <target refid="snippet-get-parameters"></target>
            <container classes="toggle" ids="snippet-get-parameters" names="snippet_get_parameters">
                <container classes="header-left">
                    <paragraph>Retrieve model parameters</paragraph>
                </container>
                <container classes="sphinx-tabs">
                    <container classes="dummy">
                        <container classes="item">
                            <container classes="dummy">
                                <paragraph>C++ snippet</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-2-0 active">
                            <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/solver/solveGeneratedModel.cpp" xml:space="preserve">    // Inside the generated code are structures with information about the 
    // model and its dimensions.  These are:
    //   - VOI_INFO: a dict with the name, units, and component of the variable of integration,
    //   - STATE_INFO: a list of dicts for the state variables,
    //   - VARIABLE_INFO: a list of dicts for the non-state variables. 

    std::cout &lt;&lt; "   VARIABLE OF INTEGRATION (units) " &lt;&lt; std::endl;
    std::cout &lt;&lt; "      " &lt;&lt; VOI_INFO.name &lt;&lt; " (" &lt;&lt; VOI_INFO.units &lt;&lt; ")" &lt;&lt;std::endl 
              &lt;&lt; std::endl;
    std::cout &lt;&lt; "   STATE VARIABLES (units) " &lt;&lt; std::endl;
    std::cout &lt;&lt; "-------------------------------------------------------------" &lt;&lt; std::endl;
    for (size_t i = 0; i &lt; STATE_COUNT; ++i) {
        std::cout &lt;&lt; "      " &lt;&lt; STATE_INFO[i].name &lt;&lt; " (" &lt;&lt; STATE_INFO[i].units &lt;&lt; ")" &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; std::endl;

</literal_block>
                            <paragraph>Full context: <download_reference filename="e41c673a94724b3cb8689dc9781a0b7b/solveGeneratedModel.cpp" refdoc="howto/actions/solve_model" refdomain="" refexplicit="True" reftarget="../code/solver/solveGeneratedModel.cpp" reftype="download" refwarn="False"><literal classes="xref download">example_solveGeneratedModel.cpp</literal></download_reference></paragraph>
                        </container>
                    </container>
                    <container classes="dummy">
                        <container classes="item">
                            <container classes="dummy">
                                <paragraph>Python snippet</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-2-1">
                            <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/solver/solveGeneratedModel.py" xml:space="preserve">    # Retrieve model module from the generated code file.
    model = module_from_file(args['m'])

    # Inside the 'model' module are structures with information about the 
    # model and its dimensions.  These are:
    #   - VOI_INFO: a dict with the name, units, and component of the variable of integration,
    #   - STATE_INFO: a list of similar dicts for the state variables,
    #   - VARIABLE_INFO: a list of similar dicts for the non-state variables. 

    print('   VARIABLE OF INTEGRATION (units)')
    print('--------------------------------------------------------------------')
    print('      {} ({}, {})'.format(model.VOI_INFO['name'],
                                     model.VOI_INFO['units'],
                                     dt))
    print('      {} steps'.format(n))
    print()

</literal_block>
                            <paragraph>Full context: <download_reference filename="bf985e8e35271e4312b0372fa93fa13e/solveGeneratedModel.py" refdoc="howto/actions/solve_model" refdomain="" refexplicit="True" reftarget="../code/solver/solveGeneratedModel.py" reftype="download" refwarn="False"><literal classes="xref download">example_solveGeneratedModel.py</literal></download_reference></paragraph>
                        </container>
                    </container>
                </container>
            </container>
        </section>
        <section ids="initialise-solution-variables" names="initialise\ solution\ variables">
            <title refid="id3">Initialise solution variables</title>
            <paragraph>As well as setting the number and size of the steps, the basic integration algorithm needs to store the state variables and their rates, as well as any other variables that are independent of the integration.</paragraph>
            <target refid="snippet-allocate-arrays"></target>
            <container classes="toggle" ids="snippet-allocate-arrays" names="snippet_allocate_arrays">
                <container classes="header-left">
                    <paragraph>Allocate solution arrays</paragraph>
                </container>
                <container classes="sphinx-tabs">
                    <container classes="dummy">
                        <container classes="item">
                            <container classes="dummy">
                                <paragraph>C++ snippet</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-3-0 active">
                            <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/solver/solveGeneratedModel.cpp" xml:space="preserve">    // Call module functions to construct and initialise the variable arrays.
    // Note that both the rates and the states arrays have the same dimensions,
    // so it's possible to call the createStatesArray() function for both.
    double time = 0.0;
    auto myStateVariables = createStatesArray();
    auto myRates = createStatesArray();
    auto myVariables = createVariablesArray();

</literal_block>
                            <paragraph>Full context: <download_reference filename="e41c673a94724b3cb8689dc9781a0b7b/solveGeneratedModel.cpp" refdoc="howto/actions/solve_model" refdomain="" refexplicit="True" reftarget="../code/solver/solveGeneratedModel.cpp" reftype="download" refwarn="False"><literal classes="xref download">example_solveGeneratedModel.cpp</literal></download_reference></paragraph>
                        </container>
                    </container>
                    <container classes="dummy">
                        <container classes="item">
                            <container classes="dummy">
                                <paragraph>Python snippet</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-3-1">
                            <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/solver/solveGeneratedModel.py" xml:space="preserve">    # Call module functions to construct the variable arrays.
    # Note that both the rates and the states arrays have the same dimensions,
    # so it's possible to call the create_states_array() function for both.
    time = 0.0
    my_variables = model.create_variables_array()
    my_state_variables = model.create_states_array()
    my_rates = model.create_states_array()
    
</literal_block>
                            <paragraph>Full context: <download_reference filename="bf985e8e35271e4312b0372fa93fa13e/solveGeneratedModel.py" refdoc="howto/actions/solve_model" refdomain="" refexplicit="True" reftarget="../code/solver/solveGeneratedModel.py" reftype="download" refwarn="False"><literal classes="xref download">example_solveGeneratedModel.py</literal></download_reference></paragraph>
                        </container>
                    </container>
                </container>
            </container>
            <paragraph>Note that since the number of state variables must be identical to the number of rates, the same <emphasis>create states array</emphasis> function can be used to allocate storage for both of them.</paragraph>
            <paragraph>Following allocation, the states and constants can be initialised using the function provided.</paragraph>
        </section>
        <section ids="compute-the-starting-values-of-variables" names="compute\ the\ starting\ values\ of\ variables">
            <title refid="id4">Compute the starting values of variables</title>
            <paragraph>There are two kinds of variables stored in the generated code: those that require updating each step (the rates, but also any other variables which these depend upon); and those which do not affect the progress of the solution (everything else).
                The former kind is updated when the <emphasis>compute rates</emphasis> function is called, and the latter when the <emphasis>compute variables</emphasis> function is called.
                Constants clearly need be calculated only once, using the <emphasis>compute computed constants</emphasis> function.</paragraph>
            <paragraph>In this example we compute everything at the initial point so as to be able to output the starting values to the terminal.</paragraph>
            <target refid="snippet-initialise-solver"></target>
            <container classes="toggle" ids="snippet-initialise-solver" names="snippet_initialise_solver">
                <container classes="header-left">
                    <paragraph>Initialise variables</paragraph>
                </container>
                <container classes="sphinx-tabs">
                    <container classes="dummy">
                        <container classes="item">
                            <container classes="dummy">
                                <paragraph>C++ snippet</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-4-0 active">
                            <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/solver/solveGeneratedModel.cpp" xml:space="preserve">    // Make use of the access functions provided to initialise the variable arrays.
    initialiseStatesAndConstants(myStateVariables, myVariables);
    computeComputedConstants(myVariables);
    computeRates(time, myStateVariables, myRates, myVariables);
    computeVariables(time, myStateVariables, myRates, myVariables);

</literal_block>
                            <paragraph>Full context: <download_reference filename="e41c673a94724b3cb8689dc9781a0b7b/solveGeneratedModel.cpp" refdoc="howto/actions/solve_model" refdomain="" refexplicit="True" reftarget="../code/solver/solveGeneratedModel.cpp" reftype="download" refwarn="False"><literal classes="xref download">example_solveGeneratedModel.cpp</literal></download_reference></paragraph>
                        </container>
                    </container>
                    <container classes="dummy">
                        <container classes="item">
                            <container classes="dummy">
                                <paragraph>Python snippet</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-4-1">
                            <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/solver/solveGeneratedModel.py" xml:space="preserve">    # Compute the parameters which require it, including the rates and variable values.
    model.initialise_states_and_constants(my_state_variables, my_variables)
    model.compute_computed_constants(my_variables)
    model.compute_rates(0, my_state_variables, my_rates, my_variables)
    model.compute_variables(0, my_state_variables, my_rates, my_variables)

    print('   STATE VARIABLES (units, initial value)')
    print('--------------------------------------------------------------------')
    for i in range(0, model.STATE_COUNT):
        print('      {} ({}, {})'.format(model.STATE_INFO[i]['name'],
                                         model.STATE_INFO[i]['units'],
                                         my_state_variables[i]))
    print()
    print('   VARIABLES (units, initial value)')
    print('--------------------------------------------------------------------')

    for v in range(0, model.VARIABLE_COUNT):
        print('      {} ({}, {})'.format(model.VARIABLE_INFO[v]['name'],
                                         model.VARIABLE_INFO[v]['units'],
                                         my_variables[v]))

</literal_block>
                            <paragraph>Full context: <download_reference filename="bf985e8e35271e4312b0372fa93fa13e/solveGeneratedModel.py" refdoc="howto/actions/solve_model" refdomain="" refexplicit="True" reftarget="../code/solver/solveGeneratedModel.py" reftype="download" refwarn="False"><literal classes="xref download">example_solveGeneratedModel.py</literal></download_reference></paragraph>
                        </container>
                    </container>
                </container>
            </container>
        </section>
        <section ids="prepare-files-for-output" names="prepare\ files\ for\ output">
            <title refid="id5">Prepare files for output</title>
            <paragraph>The solution is to be written directly to an output file during the iteration process, and this step is simply the preparation for that.
                The file is created and opened, and the columns labelled with information from the model.</paragraph>
            <target refid="snippet-create-output"></target>
            <container classes="toggle" ids="snippet-create-output" names="snippet_create_output">
                <container classes="header-left">
                    <paragraph>Prepare for output</paragraph>
                </container>
                <container classes="sphinx-tabs">
                    <container classes="dummy">
                        <container classes="item">
                            <container classes="dummy">
                                <paragraph>C++ snippet</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-5-0 active">
                            <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/solver/solveGeneratedModel.cpp" xml:space="preserve">    // Prepare a file for writing during the solution process.
    std::cout &lt;&lt; "   INITIAL CONDITIONS" &lt;&lt; std::endl;
    std::cout &lt;&lt; "-------------------------------------------------------------" &lt;&lt; std::endl;
    for (size_t i = 0; i &lt; STATE_COUNT; ++i) {
        std::cout &lt;&lt; "      " &lt;&lt; STATE_INFO[i].name &lt;&lt; "(" &lt;&lt; VOI_INFO.name &lt;&lt; " = 0) = " &lt;&lt; myStateVariables[i] &lt;&lt; std::endl;
    }
    for (size_t i = 0; i &lt; VARIABLE_COUNT; ++i) {
        std::cout &lt;&lt; "      " &lt;&lt; VARIABLE_INFO[i].name &lt;&lt; "(" &lt;&lt; VOI_INFO.name &lt;&lt; " = 0) = " &lt;&lt; myVariables[i] &lt;&lt; std::endl;
    }

    std::cout &lt;&lt; std::endl;
    std::string outFileName = args["input"] + "_solution.txt";
    std::ofstream outFile(outFileName);

    // Header line for output file
    outFile &lt;&lt; "iteration";
    outFile &lt;&lt; "\t" &lt;&lt; VOI_INFO.name &lt;&lt; " (" &lt;&lt; VOI_INFO.units &lt;&lt; ")";
    for (size_t s = 0; s &lt; STATE_COUNT; ++s) {
        outFile &lt;&lt; "\t" &lt;&lt; STATE_INFO[s].name;
    }
    for (size_t s = 0; s &lt; VARIABLE_COUNT; ++s) {
        outFile &lt;&lt; "\t" &lt;&lt; VARIABLE_INFO[s].name;
    }
    outFile &lt;&lt; std::endl;

    // Initial conditions in output file
    outFile &lt;&lt; 0;
    outFile &lt;&lt; "\t" &lt;&lt; 0;
    for (size_t s = 0; s &lt; STATE_COUNT; ++s) {
        outFile &lt;&lt; "\t" &lt;&lt; myStateVariables[s];
    }
    for (size_t s = 0; s &lt; VARIABLE_COUNT; ++s) {
        outFile &lt;&lt; "\t" &lt;&lt; myVariables[s];
    }
    outFile &lt;&lt; std::endl;

</literal_block>
                            <paragraph>Full context: <download_reference filename="e41c673a94724b3cb8689dc9781a0b7b/solveGeneratedModel.cpp" refdoc="howto/actions/solve_model" refdomain="" refexplicit="True" reftarget="../code/solver/solveGeneratedModel.cpp" reftype="download" refwarn="False"><literal classes="xref download">example_solveGeneratedModel.cpp</literal></download_reference></paragraph>
                        </container>
                    </container>
                    <container classes="dummy">
                        <container classes="item">
                            <container classes="dummy">
                                <paragraph>Python snippet</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-5-1">
                            <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/solver/solveGeneratedModel.py" xml:space="preserve">    # Prepare to write output to a file during the solution process.
    row = 'iteration\t{}({})'.format(
        model.VOI_INFO['name'], model.VOI_INFO['units'])
    for s in range(0, model.STATE_COUNT):
        row += '\t{}({})'.format(model.STATE_INFO[s]
                                 ['name'], model.STATE_INFO[s]['units'])
    for s in range(0, model.VARIABLE_COUNT):
        row += '\t{}({})'.format(model.VARIABLE_INFO[s]
                                 ['name'], model.VARIABLE_INFO[s]['units'])
    row += '\n'

    write_file_name = '{}_solution.txt'.format(args['m'])
    write_file = open(write_file_name, 'w')
    write_file.write(row)

</literal_block>
                            <paragraph>Full context: <download_reference filename="bf985e8e35271e4312b0372fa93fa13e/solveGeneratedModel.py" refdoc="howto/actions/solve_model" refdomain="" refexplicit="True" reftarget="../code/solver/solveGeneratedModel.py" reftype="download" refwarn="False"><literal classes="xref download">example_solveGeneratedModel.py</literal></download_reference></paragraph>
                        </container>
                    </container>
                </container>
            </container>
        </section>
        <section ids="perform-the-integration" names="perform\ the\ integration">
            <title refid="id6">Perform the integration</title>
            <paragraph>There are myriad stepping schemes for numerical integration, but here we use the very basic Euler method.
                At each step, new rates are calculated by calling the <emphasis>compute rates</emphasis> function.
                The states are then extrapolated from the rates using the Euler approximation step.
                In this example we are writing the output at every step, so we also need to update the variables too using the <emphasis>compute variables</emphasis> function, and everything is written to the output file.</paragraph>
            <target refid="snippet-solve"></target>
            <container classes="toggle" ids="snippet-solve" names="snippet_solve">
                <container classes="header-left">
                    <paragraph>Perform the integration and output</paragraph>
                </container>
                <container classes="sphinx-tabs">
                    <container classes="dummy">
                        <container classes="item">
                            <container classes="dummy">
                                <paragraph>C++ snippet</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-6-0 active">
                            <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/solver/solveGeneratedModel.cpp" xml:space="preserve">    // Numerically integrate the state variables using the Euler method to step through the solution.

    // Solution columns in output file
    for (size_t step = 1; step &lt; stepCount; ++step) {
        time = step * stepSize;
        computeRates(time, myStateVariables, myRates, myVariables);
        outFile &lt;&lt; step &lt;&lt; "\t " &lt;&lt; time;
        for (size_t s = 0; s &lt; STATE_COUNT; ++s) {
            myStateVariables[s] = myStateVariables[s] + myRates[s] * stepSize;
            outFile &lt;&lt; "\t" &lt;&lt; myStateVariables[s];
        }
        // The variables in the "myVariables" array are those which do not affect the calculation
        // of rates or state variables.  They only need to be computed when outputting the 
        // results of a timestep: if you're not saving every timestep, then you can skip this
        // until you are.
        computeVariables(time, myStateVariables, myRates, myVariables); 
        for (size_t s = 0; s &lt; VARIABLE_COUNT; ++s) {
            outFile &lt;&lt; "\t" &lt;&lt; myVariables[s];
        }
        outFile &lt;&lt; "\n";
    }
    outFile.close();

    // Housekeeping.

    deleteArray(myStateVariables);
    deleteArray(myVariables);
    deleteArray(myRates);

</literal_block>
                            <paragraph>Full context: <download_reference filename="e41c673a94724b3cb8689dc9781a0b7b/solveGeneratedModel.cpp" refdoc="howto/actions/solve_model" refdomain="" refexplicit="True" reftarget="../code/solver/solveGeneratedModel.cpp" reftype="download" refwarn="False"><literal classes="xref download">example_solveGeneratedModel.cpp</literal></download_reference></paragraph>
                        </container>
                    </container>
                    <container classes="dummy">
                        <container classes="item">
                            <container classes="dummy">
                                <paragraph>Python snippet</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-6-1">
                            <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/solver/solveGeneratedModel.py" xml:space="preserve">    # Numerically integrate using Euler steps to solve the model.
    for step in range(0, n):
        time = step * dt

        model.compute_rates(time, my_state_variables, my_rates, my_variables)

        # Formatting for output.
        row = '{}\t{}'.format(step, time)
        for s in range(0, model.STATE_COUNT):
            my_state_variables[s] = my_state_variables[s] + \
                my_rates[s] * dt
            row += '\t{}'.format(my_state_variables[s])

        # Note that the variables in the my_variables array are those which 
        # are independent of the integration: thus, they only need to be
        # computed at timesteps where the solution is to be written to the
        # output.  For large simulations, this may not be every integration 
        # timestep.
        model.compute_variables(
            time, my_state_variables, my_rates, my_variables)

        # Output the solution.
        for s in range(0, model.VARIABLE_COUNT):
            row += '\t{}'.format(my_variables[s])

        row += '\n'
        write_file.write(row)

    write_file.close()

</literal_block>
                            <paragraph>Full context: <download_reference filename="bf985e8e35271e4312b0372fa93fa13e/solveGeneratedModel.py" refdoc="howto/actions/solve_model" refdomain="" refexplicit="True" reftarget="../code/solver/solveGeneratedModel.py" reftype="download" refwarn="False"><literal classes="xref download">example_solveGeneratedModel.py</literal></download_reference></paragraph>
                        </container>
                    </container>
                </container>
            </container>
        </section>
    </section>
</document>
