<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.16 -->
<document source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/actions/understand_collections.rst">
    <target refid="understand-collections"></target>
    <section ids="understand-collections-of-items understand-collections" names="understand\ collections\ of\ items understand_collections">
        <title>Understand collections of items</title>
        <paragraph>Where an item can contain more than one child item (for example, more than one <literal classes="code">Variable</literal> in a <literal classes="code">Component</literal>, more than one <literal classes="code">Units</literal> item in a <literal classes="code">Model</literal>, etc) the processes for curating that collection follow the patterns outlined below.</paragraph>
        <paragraph><strong>NB:</strong> All of this explanation uses “thing” in place of the specific type of item (component, variable etc).</paragraph>
        <paragraph><strong>NB:</strong> This section explains the basic rationale of the collections.
            For practical information about how they are used, please see the <reference internal="True" refuri="view_model#view-model"><inline classes="std std-ref">Viewing a model</inline></reference> and <reference internal="True" refuri="edit_model#edit-model"><inline classes="std std-ref">Editing a model</inline></reference> pages.</paragraph>
        <container classes="toggle">
            <container classes="header-left">
                <paragraph>Count things</paragraph>
            </container>
            <paragraph>Generic counting functions will return the number of child items using the <literal classes="code">thingCount()</literal> function to get the number of <literal classes="code">thing</literal> children.
                For example, <literal classes="code">unitsCount()</literal> returns the number of <literal classes="code">Units</literal> items in a <literal classes="code">Model</literal>.
                This is useful when iterating through a collection or before using an index to access one of its members.</paragraph>
        </container>
        <container classes="toggle">
            <container classes="header-left">
                <paragraph>Get a thing</paragraph>
            </container>
            <paragraph>Pointers to items within a collection can be retrieved in two ways: by <emphasis>getting</emphasis> or by <emphasis>taking</emphasis>.
                The first does not affect the collection, and returns a pointer to the item: this is accomplished using the <literal classes="code">thing</literal> function.</paragraph>
            <paragraph>There are two overloaded arguments for the get functionality:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal classes="code">thing(i)</literal> returns a pointer to the thing at the i-th index position; and</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="code">thing("myThingName")</literal> returns a pointer to the thing named “myThingName”.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Note that in this case the retrieval of the thing does not alter it, and neither does it alter the parent which owns it.</paragraph>
        </container>
        <container classes="toggle">
            <container classes="header-left">
                <paragraph>Add a thing</paragraph>
            </container>
            <paragraph>To add to a collection use the <literal classes="code">addThing</literal> functionality.
                The basic form of adding is by symbol: <literal classes="code">addThing(thingToAdd)</literal> which will append the pointer to <literal classes="code">thingToAdd</literal> to the collection.
                Special cases of this are:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>The <literal classes="code">addComponent</literal> function will return a boolean variable telling you whether the operation was successful or not.
                        In situations where the component has already been included in the collection, is present in another collection, or is not found, this operation will return false.
                        Other add functions do not return any value.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The <literal classes="code">addUnit</literal> function has many overloaded argument lists.
                        Please refer to the full <reference internal="False" refuri="/documentation/api/latest/classlibcellml_1_1Units?fName=addUnit">API addUnit</reference> reference for details.</paragraph>
                </list_item>
            </bullet_list>
        </container>
        <container classes="toggle">
            <container classes="header-left">
                <paragraph>Remove a thing</paragraph>
            </container>
            <paragraph>To remove an item from the collection and detach its parent without returning a pointer to that item, use the <literal classes="code">removeThing</literal> functions.</paragraph>
            <container classes="nb">
                <paragraph>Because the collections are stored as a group of smart pointers, if no references exist to the item then its contents will also be deleted.
                    If other references do exist, the parent pointer will be detached, but they won’t otherwise be affected.</paragraph>
            </container>
        </container>
        <container classes="toggle">
            <container classes="header-left">
                <paragraph>Remove all the things</paragraph>
            </container>
            <paragraph>In addition to the removal of specific items from a collection as above, you can also clear the entire collection using the <literal classes="code">removeAllThings</literal> functions.</paragraph>
        </container>
        <container classes="toggle">
            <container classes="header-left">
                <paragraph>Take a thing</paragraph>
            </container>
            <paragraph>The <literal classes="code">takeThing</literal> functions combine a little of the <emphasis>remove</emphasis> and a little of the <emphasis>get</emphasis> functionality.
                It will return a pointer to the item (like the <emphasis>get</emphasis> <literal classes="code">thing</literal> functionality above), but it will also remove the item from the collection (like <literal classes="code">removeThing</literal>), updating both the collection as well as the item’s parent.
                The item is thus detached from its parent, and “taken” by the returned pointer.</paragraph>
            <paragraph>Examples are shown for C++ and Python below.</paragraph>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show code examples</paragraph>
                </container>
                <container classes="sphinx-tabs">
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>C++</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="c++" linenos="False" xml:space="preserve">// Consider the case where we already have a model containing a component named "myComponent" at index 0.

// Case 1: Use the get and remove functionality together.
auto component = model-&gt;component(0);               // Get either by index,
auto component = model-&gt;component("componentName"); // or by name.

bool componentWasRemoved = model-&gt;removeComponent(0);               // Remove either by index,
bool componentWasRemoved = model-&gt;removeComponent("componentName"); // by name,
bool componentWasRemoved = model-&gt;removeComponent(component);       // or by symbol.

// At this point, the model's components collection no longer contains the component, and the component
// pointer has no parent.

// Case 2: Use the take functionality.
auto component = model-&gt;takeComponent(0);             // Take either by index,
auto component = model-&gt;takeComponent("myComponent"); // or by name.

// At this point, we have the same outcome as in Case 1 above.  The model's component collection no
// longer contains the component, and the component itself has no parent.

// Case 3: A cautionary tale using remove without get.
auto iAmABooleanNotAComponent = model-&gt;removeComponent(0); // Remove either by index, name or symbol as above.

// In the situation where no other reference to the component exists (ie: we did not "get" it as in Case 1),
// the model's collection will no longer contain the component AND the entire contents of that component
// will be permanently deleted.</literal_block>
                    </container>
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>Python</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="py" linenos="False" xml:space="preserve"># Consider the case where we already have a model containing a component named "myComponent" at index 0.

# Case 1: Use the get and remove functionality together.
component = model.component(0)                    # Get either by index,
component = model.component("componentName") # or by name.

was_removed = model.removeComponent(0)               # Remove either by index,
was_removed = model.removeComponent("componentName") # by name,
was_removed = model.removeComponent(component)       # or by symbol.

# At this point, the model's components collection no longer contains the component, and the component
# pointer has no parent.

# Case 2: Use the take functionality.
component = model.takeComponent(0)             # Take either by index,
component = model.takeComponent("myComponent") # or by name.

# At this point, we have the same outcome as in Case 1 above.  The model's component collection no
# longer contains the component, and the component itself has no parent.

# Case 3: A cautionary tale using remove without get.
i_am_a_bool_not_a_component = model.removeComponent(0) # Remove either by index, name or symbol as above.

# In the situation where no other reference to the component exists (ie: we did not "get" it as in Case 1),
# the model's collection will no longer contain the component AND the entire contents of that component
# will be permanently deleted.</literal_block>
                    </container>
                </container>
            </container>
        </container>
        <container classes="toggle">
            <container classes="header-left">
                <paragraph>Replace a thing</paragraph>
            </container>
            <paragraph>Within the <literal classes="code">Model</literal> and <literal classes="code">Component</literal> items are <literal classes="code">replaceUnits</literal> and <literal classes="code">replaceComponent</literal> functions respectively.
                Their operation is straightforward: a position within the collection is specified (either using an index, or the name of an existing item in the collection), and a replacement item is supplied.
                The replacement item overwrites what was previously stored at the position in the collection.
                In addition, the <literal classes="code">replaceComponent</literal> takes an optional boolean argument indicating whether to search the encapsulated children for the item, if specified by name.
                By default this is set to <literal classes="code">true</literal>.
                For more information about replacement, please see the API documentation for <reference internal="False" refuri="/documentation/api/latest/classlibcellml_1_1Model">Model</reference> and <reference internal="False" refuri="/documentation/api/latest/classlibcellml_1_1Component">Component</reference> items directly.</paragraph>
            <container classes="nb">
                <paragraph>Note that these <strong>only</strong> operate on collections of items.  That is:
                    - the collections of <literal classes="code">Units</literal>, <literal classes="code">Component</literal> and <literal classes="code">ImportSource</literal> items in a parent <literal classes="code">Model</literal>;
                    - the encapsulated child <literal classes="code">Component</literal>, <literal classes="code">Reset</literal> or <literal classes="code">Variable</literal> items in a parent <literal classes="code">Component</literal>;
                    - the child <literal classes="code">Unit</literal> items in a parent <literal classes="code">Units</literal> item;
                    - the imported <literal classes="code">Units</literal> or <literal classes="code">Component</literal> items in a parent <literal classes="code">ImportSource</literal>; and
                    - the added <literal classes="code">Model</literal> items in an <literal classes="code">Importer</literal> instance.</paragraph>
            </container>
        </container>
    </section>
</document>
