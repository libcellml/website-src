<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.16 -->
<document source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/actions/annotate_model.rst">
    <target refid="annotate-model"></target>
    <section ids="annotate-a-model annotate-model" names="annotate\ a\ model annotate_model">
        <title>Annotate a model</title>
        <paragraph>libCellML does not provide annotation functionality directly, but it can help with some of the things that you might need to know in order to implement your own.
            Each annotation is attached to a unique ID locator which can be retrieved and edited, or created automatically if you haven’t already set them yourself.
            Since CellML is a subset of XML, any item may have an ID attribute, including operations within the MathML blocks, CellML entities, and CellML non-entity items (connections, encapsulations etc).
            These ID attributes themselves must follow the specification rules: please see <reference internal="False" refuri="https://cellml-specification.readthedocs.io/en/latest/specA2.html?issue=1.2.5">1.2.5 XML ID attributes</reference> for details.</paragraph>
        <container classes="nb">
            <paragraph>At present, items within MathML blocks which have <literal classes="code">id</literal> attributes are not retrieved or edited by the annotation class.
                Any editing or manipulation must be done external to libCellML.</paragraph>
        </container>
        <topic classes="contents local" ids="contents" names="contents">
            <bullet_list>
                <list_item>
                    <paragraph><reference ids="id1" refid="annotation-tools-for-entity-items">Annotation tools for entity items</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id2" refid="annotation-tools-for-other-item-types">Annotation tools for other item types</reference></paragraph>
                    <bullet_list>
                        <list_item>
                            <paragraph><reference ids="id3" refid="connections-and-variable-equivalence">Connections and variable equivalence</reference></paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><reference ids="id4" refid="encapsulation-and-component-references">Encapsulation and component references</reference></paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><reference ids="id5" refid="unit-item-children-reset-value-test-value-item-children">Unit item children; reset_value, test_value item children</reference></paragraph>
                        </list_item>
                    </bullet_list>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id6" refid="annotator-type-and-returned-types">Annotator <literal>Type</literal> and returned types</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id7" refid="useful-snippets-for-annotation">Useful snippets for annotation</reference></paragraph>
                </list_item>
            </bullet_list>
        </topic>
        <section ids="annotation-tools-for-entity-items" names="annotation\ tools\ for\ entity\ items">
            <title refid="id1">Annotation tools for entity items</title>
            <paragraph>Entity item types are:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal classes="code">Model</literal> items;</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="code">Component</literal> items;</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="code">Variable</literal> items;</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="code">Units</literal> items;</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="code">Reset</literal> items; and</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="code">ImportSource</literal> items.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The <literal classes="code">id</literal> attribute for each of these entity types can be retrieved using the <literal classes="code">id()</literal> function for the object, or set through its <literal classes="code">setId()</literal> function.</paragraph>
            <container classes="sphinx-tabs">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                    </container>
                    <literal_block force="False" highlight_args="{}" language="c++" linenos="False" xml:space="preserve">// Set the ID attribute for a Model item.
model-&gt;setId("myModelId");

// Retrieve the ID attribute from a Model item.
std::string myModelIdString = model-&gt;id();</literal_block>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                    </container>
                    <literal_block force="False" highlight_args="{}" language="py" linenos="False" xml:space="preserve"># Set the ID attribute for a Model item.
model.setId("myModelId")

# Retrieve the ID attribute from a Model item.
my_model_id_string = model.id()</literal_block>
                </container>
            </container>
        </section>
        <section ids="annotation-tools-for-other-item-types" names="annotation\ tools\ for\ other\ item\ types">
            <title refid="id2">Annotation tools for other item types</title>
            <section ids="connections-and-variable-equivalence" names="connections\ and\ variable\ equivalence">
                <title refid="id3">Connections and variable equivalence</title>
                <paragraph>Items which specify the relationship between two entities (such as connections between components, and mappings between variables) are accessed and identified by the pair of entities.
                    Consider the simple example shown below.</paragraph>
                <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">model:
  ├─ component: name = "c1", id = "c1id"
  │   └ variable: name = "v1", id = "v1id" &lt;╴╴╴┐
  └─ component: name = "c2", id = "c2id"     equivalent variables
      └ variable: name = "v2", id = "v2id" &lt;╴╴╴┘</literal_block>
                <container classes="toggle">
                    <container classes="header">
                        <paragraph>Show CellML syntax</paragraph>
                    </container>
                    <literal_block force="False" highlight_args="{}" language="xml" linenos="False" xml:space="preserve">&lt;model&gt;
  &lt;component name="c1" id="c1id"&gt;
    &lt;variable name="v1" id="v1id" /&gt;
  &lt;/component&gt;
  &lt;component name="c2" id="c2id"&gt;
    &lt;variable name="v2" id="v2id" /&gt;
  &lt;/component&gt;

  &lt;!-- The variable equivalence is stored separately to the variables themselves. --&gt;
  &lt;connection component1="c1" component2="c2" id="c1c2id" &gt;
    &lt;map_variables variable1="v1" variable2="v2" id="v1v2id" /&gt;
  &lt;/connection&gt;
&lt;/model&gt;</literal_block>
                </container>
                <container classes="sphinx-tabs">
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>C++</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="c++" linenos="False" xml:space="preserve">// Set the ID of the mapping between variables v1 and v2.
Variable::setEquivalentVariableId(v1, v2, "v1v2Id");

// Get the ID of the mapping between variables v1 and v2. Note that
// equivalences and connections go both ways, so the ID is the same
// whichever order the variables are specified.
std::string v1v2IdString = Variable::equivalentVariableId(v1, v2);

// Since a connection item between two components will only exist
// when there is a variable equivalence between at least one each
// of their children.  The connection is accessed through those
// child variable pairs, just as the equivalence mapping itself is.
Variable::setConnectionId(v1, v2, "c1c2id");

// Get the ID of the connection between the parent components of
// equivalent variable pair. Note that equivalences and connections
// go both ways, so the ID is the same whichever order the variables
// are specified.
std::string c1c2IdString = Variable::connectionId(v1, v2);</literal_block>
                    </container>
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>Python</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="py" linenos="False" xml:space="preserve"># Set the ID of the mapping between variables v1 and v2.
Variable.setEquivalentVariableId(v1, v2, "v1v2Id")

# Get the ID of the mapping between variables v1 and v2.
# Note that equivalences and connections go both ways, so
# the ID is the same whichever order the variables are specified.
v1v2_id_string = Variable.equivalentVariableId(v1, v2)

# Since a connection item between two components will only exist
# when there is a variable equivalence between at least one each
# of their children.  The connection is accessed through those
# child variable pairs, just as the equivalence mapping itself is.
Variable.setConnectionId(v1, v2, "c1c2id")

# Get the ID of the connection between the parent components
# of equivalent variable pair.
# Note that equivalences and connections go both ways, so
# the ID is the same whichever order the variables are specified.
c1c2IdString = Variable.connectionId(v1, v2)</literal_block>
                    </container>
                </container>
            </section>
            <section ids="encapsulation-and-component-references" names="encapsulation\ and\ component\ references">
                <title refid="id4">Encapsulation and component references</title>
                <paragraph>The model’s encapsulation and the component references which it contains may have ID attributes too.
                    These are accessed through the <literal classes="code">encapsulationId()</literal> functions, as shown below.</paragraph>
                <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">model:
  └ encapsulation:
      └ component: grandparent
          └ component: parent
              └ component: child</literal_block>
                <container classes="toggle">
                    <container classes="header">
                        <paragraph>Show CellML syntax</paragraph>
                    </container>
                    <literal_block force="False" highlight_args="{}" language="xml" linenos="False" xml:space="preserve">&lt;model&gt;
  &lt;component name="grandparent" id="grandparentComponentId" /&gt;
  &lt;component name="parent" id="parentComponentId" /&gt;
  &lt;component name="child" id="childComponentId" /&gt;

  &lt;!-- The ids of the components in the encapsulation structure are distinct
       from the ids on the components themselves. --&gt;
  &lt;encapsulation id="encapsId"&gt;
    &lt;component_ref component="grandparent" id="grandparentEncapsId" &gt;
      &lt;component_ref component="parent" id="parentEncapsId" &gt;
        &lt;component_ref component="child" id="childEncapsId" &gt;
      &lt;/component_ref&gt;
    &lt;/component_ref&gt;
  &lt;/encapsulation&gt;
&lt;/model&gt;</literal_block>
                </container>
                <paragraph>There is only one encapsulation in a model, and its <literal classes="code">id</literal> attribute is accessed using the very simple functions from the model instance.
                    The position of each component within that encapsulation structure is referenced using the same functions, but on the component instance instead.</paragraph>
                <container classes="sphinx-tabs">
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>C++</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="c++" linenos="False" xml:space="preserve">// Set the encapsulation ID.
model-&gt;setEncapsulationId("encapsId");
grandparentComponent-&gt;setEncapsulationId("grandparentEncapsId");

// Get the encapsulation ID.
std::string modelEncapsulationId = model-&gt;encapsulationId();
std::string grandparentEncapsulationId = grandparentComponent-&gt;encapsulationId();</literal_block>
                    </container>
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>Python</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="py" linenos="False" xml:space="preserve"># Set the encapsulation ID.
model.setEncapsulationId("encapsId")
grandparent_component.setEncapsulationId("grandparentEncapsId")

# Get the encapsulation ID.
model_encapsulation_id = model.encapsulationId()
grandparent_encapsulation_id = grandparent_component.encapsulationId()</literal_block>
                    </container>
                </container>
            </section>
            <section ids="unit-item-children-reset-value-test-value-item-children" names="unit\ item\ children;\ reset_value,\ test_value\ item\ children">
                <title refid="id5">Unit item children; reset_value, test_value item children</title>
                <paragraph>Some items are most readily accessed through their entity-type parents, these being:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><literal classes="code">unit</literal> items, a collection of which defines a <literal classes="code">Units</literal> item; and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal classes="code">test_value</literal> and <literal classes="code">reset_value</literal> children of <literal classes="code">Reset</literal> items.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Unit children of <literal classes="code">Units</literal> items can be accessed either through the streamlined ID-only functions <literal classes="code">unitId(index)</literal> and <literal classes="code">setUnitId(index)</literal>, or through the <literal classes="code">unitAttributes</literal> family of functions.
                    Note that there are several overloads of the arguments for this function; please see the complete documentation on the <reference internal="False" refuri="/documentation/api/latest/classlibcellml_1_1Units?fName=addUnit">Units functions API page</reference>.</paragraph>
                <container classes="sphinx-tabs">
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>C++</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="c++" linenos="False" xml:space="preserve">// Create a Units item representing millimetre^3 per second.
auto mm3PerSecond = libcellml::Units::create("mm3PerSecond");

// Add the per second part with the ID "perSecondUnitId".
mm3PerSecond-&gt;addUnit("second", 0, -1.0, 1.0, "perSecondUnitId");

// Add the mm^3 part with with the ID "mmCubedUnitId".
mm3PerSecond-&gt;addUnit("metre", "milli", 3.0, 1.0, "mmCubedUnitId");

// Check that the ID has been assigned to the Unit children.
auto checkId1 = mm3PerSecond-&gt;unitId(0); // returns "perSecondUnitId".
auto checkId2 = mm3PerSecond-&gt;unitId(1); // returns "mmCubedUnitId".

// Change the ID of the second (ie: index = 1) child to be "millimetreCubedUnitId":
mm3PerSecond-&gt;setUnitId(1, "millimetreCubedUnitId");

// Retrieve the unit attributes for the first (index = 0) unit item, including the ID attribute:
std::string unitReference;
std::string unitPrefix;
double unitExponent;
double unitMultiplier;
std::string unitId;
mm3PerSecond-&gt;unitAttributes(0, unitReference, unitPrefix, unitExponent, unitMultiplier, unitId);</literal_block>
                    </container>
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>Python</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="py" linenos="False" xml:space="preserve"># Create a Units item representing millimetre^3 per second.
mm3_per_second = Units.create("mm3PerSecond")

# Add the per second part with the ID "perSecondUnitId".
mm3_per_second.addUnit("second", 0, -1.0, 1.0, "perSecondUnitId")

# Add the mm^3 part with with the ID "mmCubedUnitId".
mm3_per_second.addUnit("metre", "milli", 3.0, 1.0, "mmCubedUnitId")

# Retrieve both ids from the child units.
check_1 = mm3_per_second.unitId(0) # returns "perSecondUnitId"
check_2 = mm3_per_second.unitId(1) # returns "mmCubedUnitId"

# Change the ID of the second (ie: index = 1) Unit child to be "millimetreCubedUnitId".
mm3_per_second.setUnitId(1, "millimetreCubedUnitId")

# Retrieve the unit attributes for the second (index = 0) unit item, including the ID attribute:
mm3PerSecond.unitAttributes(0, unitReference, unitPrefix, unitExponent, unitMultiplier, unitId)</literal_block>
                    </container>
                </container>
            </section>
        </section>
        <section ids="annotator-type-and-returned-types" names="annotator\ type\ and\ returned\ types">
            <title refid="id6">Annotator <literal>Type</literal> and returned types</title>
            <table align="default">
                <tgroup cols="2">
                    <colspec colwidth="19"></colspec>
                    <colspec colwidth="101"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph>enumeration value</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Object type in the “any” container.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>COMPONENT</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Pointer to a <literal classes="code">Component</literal> with the given <literal classes="code">id</literal>.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>COMPONENT_REF</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Pointer to a <literal classes="code">Component</literal>, whose encapsulation <literal classes="code">component_ref</literal> has the given <literal classes="code">id</literal>.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>CONNECTION</paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal classes="code">VariablePair</literal> containing pointers to two <literal classes="code">Variable</literal> items which span the connection.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>ENCAPSULATION</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Pointer to the <literal classes="code">Model</literal> item with the given <literal classes="code">id</literal>.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>IMPORT</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Pointer to an <literal classes="code">ImportSource</literal> item with the given <literal classes="code">id</literal>.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>ISSUE</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Pointer to an <literal classes="code">Issue</literal> item, created when something has gone wrong.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>MAP_VARIABLES</paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal classes="code">VariablePair</literal> containing the two <literal classes="code">Variable</literal> items connected by a variable
                                    equivalence with the given <literal classes="code">id</literal>.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>MODEL</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Pointer to the <literal classes="code">Model</literal> item with the given <literal classes="code">id</literal>.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>RESET</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Pointer to the <literal classes="code">Reset</literal> item with the given <literal classes="code">id</literal>.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>RESET_VALUE</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Pointer to the parent <literal classes="code">Reset</literal> item containing a reset value with the given <literal classes="code">id</literal>.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>TEST_VALUE</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Pointer to the parent <literal classes="code">Reset</literal> item containing a test value with the given <literal classes="code">id</literal>.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>UNIT</paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal classes="code">Unit</literal> pair, when the first attribute is a <literal classes="code">Units</literal> pointer to the parent of
                                    the unit with the given <literal classes="code">id</literal>, and the second attribute is the index within the
                                    <literal classes="code">Units</literal> item at which the unit can be found.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>UNITS</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Pointer to a <literal classes="code">Units</literal> item with the given <literal classes="code">id</literal>.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>VARIABLE</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Pointer to a <literal classes="code">Variable</literal> item with the given <literal classes="code">id</literal>.</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section ids="useful-snippets-for-annotation" names="useful\ snippets\ for\ annotation">
            <title refid="id7">Useful snippets for annotation</title>
            <target refid="snippet-annotator-auto-ids"></target>
            <container classes="toggle" ids="snippet-annotator-auto-ids" names="snippet_annotator_auto_ids">
                <container classes="header-left">
                    <paragraph>Automatically assign unique ids to items</paragraph>
                </container>
                <paragraph>Because the <literal classes="code">id</literal> attribute is simply a token, its contents (provided they follow the XML rules) could be anything.
                    Ids are not intended to be interacted with by humans; they are there as a placeholder or location specifier so that other (more human-friendly) documentation can be added to the right objects.
                    With this in mind, it’s possible to automate the creation of unique ids for a single item, a set of items of the same type (eg: all the <literal classes="code">Component</literal> items), or for every annotatable item in a CellML model.</paragraph>
                <container classes="sphinx-tabs">
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>C++</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="c++" linenos="False" xml:space="preserve">// Create an Annotator instance.
auto annotator = libcellml::Annotator::create();

// ---------- OPTION 1: Automatic ids for everything -------------------------
//
// Submit the model to the Annotator, and instruct it to create and assign a
// set of unique ids to any annotatable item in the model.
// Note that this function replaces any previously stored model within the
// Annotator, and rebuilds the internal index with respect to this model.
// There is no need to either build the index first (as all the ids will
// be altered anyway) or afterwards (as it's built during the assignment
// process).
annotator-&gt;assignAllIds(model);

// ---------- OPTION 2: Automatic ids by type -----------------------
//
// First submit the model to the Annotator and build its index.
annotator-&gt;buildModelIndex(model);

// Next, specify the type of item to assign automatic ids to using the
// Type enumeration options.  This will assign every Variable in the model
// a unique id string.
annotator-&gt;assignIds(libcellml::Annotator::Type::VARIABLE);

// ---------- OPTION 3: Automatic id by item -------------------------
//
// Finally, you can submit single items for automatic id.
// There are two ways to do this as shown below.  Note that when you use the
// built-in Annotator functions to assign ids, there is no need to rebuild the
// annotator's index.
//
// The two options below are identical.
//
// EITHER Submit an AnyItem struct (a pair of Type enum, and the item) ...
AnyItem myComponentRef = std::make_pair(libcellml::Annotator::Type::COMPONENT_REF, model-&gt;component(0));
annotator-&gt;assignId(myComponentRef);

// ... OR submit both the Type enum and the item as separate arguments.
annotator-&gt;assignId(libcellml::Annotator::Type::COMPONENT_REF, model-&gt;component(0));</literal_block>
                    </container>
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>Python</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="py" linenos="False" xml:space="preserve"># Create an Annotator instance.
from libcellml import Annotator
annotator = Annotator()

# ---------- OPTION 1: Automatic ids for everything -------------------------
#
# Submit the model to the Annotator, and instruct it to create and assign a
# set of unique ids to any annotatable item in the model.
# Note that this function replaces any previously stored model within the
# Annotator, and rebuilds the internal index with respect to this model.
# There is no need to either build the index first (as all the ids will
# be altered anyway) or afterwards (as it's built during the assignment
# process).
annotator.assignAllIds(model)

# ---------- OPTION 2: Automatic ids by type -----------------------
#
# First submit the model to the Annotator and build its index.
annotator.buildModelIndex(model)

# Next, specify the type of item to assign automatic ids to using the
# Type enumeration options.  This will assign every Variable in the model
# a unique id string.
annotator.assignIds(Annotator.Type.VARIABLE)

# ---------- OPTION 3: Automatic id by item -------------------------
#
# Finally, you can submit single items for automatic id.
# There are two ways to do this as shown below.  Note that when you use the
# built-in Annotator functions to assign ids, there is no need to rebuild the
# annotator's index.
#
# Submit both the Type enum and the item as separate arguments.
annotator.assignId(Annotator.Type.COMPONENT_REF, model.component(0))</literal_block>
                    </container>
                </container>
            </container>
            <target refid="snippet-annotator-clear-all-ids"></target>
            <container classes="toggle" ids="snippet-annotator-clear-all-ids" names="snippet_annotator_clear_all_ids">
                <container classes="header-left">
                    <paragraph>Remove ids from all items</paragraph>
                </container>
                <paragraph>In addition to creating id attributes, the <literal classes="code">Annotator</literal> can be used to clear them from all items in the model.
                    There are two ways in which this can be done.
                    First, a <literal classes="code">Model</literal> instance can be passed to the annotator for clearing.
                    This process will replace any previously stored model with the new one, as well as clearing all ids from the given model.
                    Alternatively, if a model is already stored in the annotator instance, the ids of that stored model can be cleared by calling the <title_reference>clearAllIds()</title_reference> function without arguments.</paragraph>
                <container classes="sphinx-tabs">
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>C++</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="c++" linenos="False" xml:space="preserve">// Assuming we have two models, with references model1, and model2.

// Create an Annotator instance.
auto annotator = libcellml::Annotator::create();

// EITHER: Pass a new Model to the annotator so that its ids can be cleared.
annotator-&gt;clearAllIds(model1);  // This will clear ids in model1,
                                 // and associate model1 with the annotator.

// Note: There is no need to build the annotator's index beforehand as
// clearing the ids will also clear the index.  The model1 given will be
// stored as the current model within the annotator.

// OR: Clear all ids in a model which is was previously associated with the annotator.
annotator-&gt;buildModelIndex(model2);
annotator-&gt;clearAllIds();  // This will clear ids in model2, the model stored in the annotator.</literal_block>
                    </container>
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>Python</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="py" linenos="False" xml:space="preserve"># Assuming we have two models, with references model1, and model2.

# Create an Annotator instance.
annotator = Annotator()

# EITHER: Pass a new Model to the annotator so that its ids can be cleared.
annotator.clearAllIds(model1)   # This will clear ids in model1,
                                 # and associate model1 with the annotator.

# Note: There is no need to build the annotator's index beforehand as
# clearing the ids will also clear the index.  The model1 given will be
# stored as the current model within the annotator.

# OR: Clear all ids in a model which is was previously associated with the annotator.
annotator.buildModelIndex(model2)
annotator.clearAllIds()  # This will clear ids in model2, the model stored in the annotator.</literal_block>
                    </container>
                </container>
            </container>
            <target refid="snippet-annotator-find-item-known-type"></target>
            <container classes="toggle" ids="snippet-annotator-find-item-known-type" names="snippet_annotator_find_item_known_type">
                <container classes="header-left">
                    <paragraph>Retrieve an item of known type by id</paragraph>
                </container>
                <paragraph>Where you know the type of item (eg: <literal classes="code">Component</literal>, <literal classes="code">Variable</literal> etc) before retrieving it, a collection of helper functions exist, as demonstrated below.
                    Where the known type is an entity type, a pointer to the item is returned.
                    Where the type is a non-entity type, pointers to significant related items are returned, as discussed earlier.</paragraph>
                <container classes="sphinx-tabs">
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>C++</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="c++" linenos="False" xml:space="preserve">// Create an Annotator.
auto annotator = libcellml::Annotator::create();

// Build the annotator to work with the model.
annotator-&gt;buildModelIndex(model);

// Retrieve entity items of known type using their id attribute.
auto myComponent = annotator-&gt;component("myComponentId");
auto myVariable = annotator-&gt;variable("myVariableId");
auto myReset = annotator-&gt;reset("myResetId");
auto myUnits = annotator-&gt;units("myUnitsId");
auto myImportSource = annotator-&gt;importSource("myImportSourceId");
auto myModel = annotator-&gt;model("myModelId");

// Retrieve non-entity items of known type using their id attribute.
// NOTE that the type of object returned by retrieving a non-entity item
// is defined in the text above.

// Connections are returned as a VariablePair type, where the first and second
// items in the pair define Variables in the first and second components of the
// connection.  Note that as multiple variable pairs could exist between two
// given components, the return value for this function is not unique.
auto myConnection = annotator-&gt;connection("myConnectionId");

// Variable equivalences (from the map_variables) are returned as a VariablePair,
// where the first and second items in the pair define the Variables which are made
// equivalent by this mapping.
auto myMappedVariables = annotator-&gt;mapVariables("myMapVariablesId");

// Unit items are returned as a Unit pair, where the first item is a pointer to
// the parent Units item, and the second is the index at which the child unit item's
// attributes can be found.
auto myUnitItem = annotator-&gt;unit("myUnitId");
std::string myUnitsReference;
std::string myPrefix;
std::string myId;
double myExponent;
double myMultiplier;

// The first item in the pair is a pointer to the parent Units.
myUnitItem.first-&gt;unitAttributes(myUnitItem.second, // The second item in the pair is the index.
                                 myReference, myPrefix, myExponent,
                                 myMultiplier,myId);

// The location of a component in an encapsulation hierarchy is set by a component_ref
// block.  Retrieving a component_ref item by id will return a pointer to the
// Component item which is located at that position in the encapsulation.
auto myReferencedComponent = annotator-&gt;componentRef("myComponentReferenceId");

// The reset_value and test_value block children of a Reset item are returned as a
// pointer to their parent Reset item.
auto myTestValueParent = annotator-&gt;testValue("myTestValueId");
auto myResetValueParent = annotator-&gt;resetValue("myResetValueId");
// Their values can then be retrieved using the test_value() and
// reset_value() functions on that Reset item parent.
auto myTestValue = myTestValueParent-&gt;test_value();
auto myResetValue = myResetValueParent-&gt;reset_value();

// An encapsulation item is returned as a pointer to its parent model.
auto myEncapsulatedModel = annotator-&gt;encapsulation("myEncapsulationId");</literal_block>
                    </container>
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>Python</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="py" linenos="False" xml:space="preserve"># Create an Annotator.
annotator = Annotator()

# Build the annotator to work with the model.
annotator.buildModelIndex(model)

# Retrieve entity items of known type using their id attribute.
my_component = annotator.component("myComponentId")
my_variable = annotator.variable("myVariableId")
my_reset = annotator.reset("myResetId")
my_units = annotator.units("myUnitsId")
my_import_source = annotator.importSource("myImportSourceId")
my_model = annotator.model("myModelId")

# Retrieve non-entity items of known type using their id attribute.
# NOTE that the type of object returned by retrieving a non-entity item
# is defined in the text above.

# Connections are returned as a VariablePair type, where the first and second
# items in the pair define Variables in the first and second components of the
# connection.  Note that as multiple variable pairs could exist between two
# given components, the return value for this function is not unique.
my_connection = annotator.connection("myConnectionId")

# Variable equivalences (from the map_variables) are returned as a VariablePair,
# where the first and second items in the pair define the Variables which are made
# equivalent by this mapping.
my_mapped_variables = annotator.mapVariables("myMapVariablesId")

# Unit items are returned as a Unit pair, where the first item is a pointer to
# the parent Units item, and the second is the index at which the child unit item's
# attributes can be found.
my_unit_item = annotator.unit("myUnitId")

# The first item in the pair is a pointer to the parent Units.
# TODO: check how Python handles the std::pair class.

# The location of a component in an encapsulation hierarchy is set by a component_ref
# block.  Retrieving a component_ref item by id will return a pointer to the
# Component item which is located at that position in the encapsulation.
my_referenced_component = annotator.componentRef("myComponentReferenceId")

# The reset_value and test_value block children of a Reset item are returned as a
# pointer to their parent Reset item.
my_test_value_parent = annotator.testValue("myTestValueId")
my_reset_value_parent = annotator.resetValue("myResetValueId")
# Their values can then be retrieved using the test_value() and
# reset_value() functions on that Reset item parent.
my_test_value = my_test_value_parent.test_value()
my_reset_value = my_reset_value_parent.reset_value()

# An encapsulation item is returned as a pointer to its parent model.
my_encapsulated_model = annotator.encapsulation("myEncapsulationId")</literal_block>
                    </container>
                </container>
            </container>
            <target refid="snippet-annotator-find-item-unknown-type"></target>
            <container classes="toggle" ids="snippet-annotator-find-item-unknown-type" names="snippet_annotator_find_item_unknown_type">
                <container classes="header-left">
                    <paragraph>Retrieve an item of unknown type by id</paragraph>
                </container>
                <paragraph>In situations where you have an id string, but don’t know the type of the object it identifies, the item can be retrieved using a general <literal classes="code">Annotator::item(itemId)</literal> function.
                    The general <literal classes="code">item</literal> function will return an <literal classes="code">AnyItem</literal> pair.
                    The first part of the pair is an enum of the type of the object.
                    The second part is an <literal classes="code">std::any</literal> type object, which can be cast into the correct type.
                    This is demonstrated below.</paragraph>
                <container classes="sphinx-tabs">
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>C++</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="c++" linenos="False" xml:space="preserve">// Create an Annotator.
auto annotator = libcellml::Annotator::create();

// Build the annotator to work with the model.
annotator-&gt;buildModelIndex(model);

// Retrieve an item of unknown type from the annotator.
auto anyItem = annotator-&gt;item("findThisId");

// Depending on the item's type (which is stored in the first part of the AnyItem
// pair), cast the second part to the appropriate pointer type. Note that this means
// first declaring a range of variables of different types to which the cast
// pointer can be assigned.

libcellml::ComponentPtr itemComponent;
libcellml::VariablePtr itemVariable;
libcellml::ResetPtr itemReset;
libcellml::UnitsPtr itemUnits;
libcellml::ImportSourcePtr itemImportSource;
libcellml::VariablePair itemVariablePair;
libcellml::Unit itemUnit;

switch (anyItem.first) {
    case libcellml::Annotator::Type::COMPONENT:
    case libcellml::Annotator::Type::COMPONENT_REF:
        itemComponent = std::any_cast&lt;libcellml::ComponentPtr&gt;(anyItem.second);
        break;
    case libcellml::Annotator::Type::CONNECTION:
    case libcellml::Annotator::Type::MAP_VARIABLES:
        itemVariablePair = std::any_cast&lt;libcellml::VariablePair&gt;(anyItem.second);
        break;
    case libcellml::Annotator::Type::IMPORT:
        itemImportItem = std::any_cast&lt;libcellml::ImportSourcePtr&gt;(anyItem.second);
        break;
    case libcellml::Annotator::Type::ENCAPSULATION:
    case libcellml::Annotator::Type::MODEL:
        itemModel = std::any_cast&lt;libcellml::ModelPtr&gt;(anyItem.second);
        break;
    case libcellml::Annotator::Type::RESET:
    case libcellml::Annotator::Type::RESET_VALUE:
    case libcellml::Annotator::Type::TEST_VALUE:
        itemReset = std::any_cast&lt;libcellml::ResetPtr&gt;(anyItem.second);
        break;
    case libcellml::Annotator::Type::UNIT:
        itemUnit = std::any_cast&lt;libcellml::Unit&gt;(anyItem.second);
        break;
    case libcellml::Annotator::Type::UNITS:
        itemUnits = std::any_cast&lt;libcellml::UnitsPtr&gt;(anyItem.second);
        break;
    case libcellml::Annotator::Type::VARIABLE:
        itemVariable = std::any_cast&lt;libcellml::VariablePtr&gt;(anyItem.second);
        break;
    }
}

// Note also that attempting to cast into the wrong type will trigger a
// "bad any cast" exception.
try {
    assert(itemVariable.first == Annotator::Type::VARIABLE);
    auto thisWillNotWork = std::any_cast&lt;libcellml::UnitsPtr&gt;(itemVariable.second);
}
catch(const std::bad_any_cast&amp; e) {
    // Depending on your system, this will return a "bad any cast", "bad any_cast"
    // or "bad_any_cast" message.
    std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
}</literal_block>
                    </container>
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>Python</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="py" linenos="False" xml:space="preserve"># TODO</literal_block>
                    </container>
                </container>
            </container>
            <target refid="snippet-annotator-find-duplicate-ids"></target>
            <container classes="toggle" ids="snippet-annotator-find-duplicate-ids" names="snippet_annotator_find_duplicate_ids">
                <container classes="header-left">
                    <paragraph>Locate items with duplicate ids</paragraph>
                </container>
                <paragraph>The <literal classes="code">Annotator</literal> functionality can be used to report id strings which have been duplicated within a model’s scope, as well as to return all items associated with a duplicated id string.</paragraph>
                <container classes="sphinx-tabs">
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>C++</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="c++" linenos="False" xml:space="preserve">// Create an Annotator instance.
auto annotator = libcellml::Annotator::create();

// Create a model, with the id string "duplicateId" used on a component
// and a variable item, and an id string "anotherDuplicateId" on a units
// and encapsulation item.
auto model = libcellml::Model::create("myModelName");
auto component = libcellml::Component::create("myComponentName");
auto variable = libcellml::Variable::create("myVariableName");
auto units = libcellml::Units::create("myUnitsName");

model-&gt;addComponent(component);
model-&gt;addUnits(units);
component-&gt;addVariable(variable);

// Set the ids.
component-&gt;setId("duplicateId");
variable-&gt;setId("duplicateId");
units-&gt;setId("anotherDuplicateId");
model-&gt;setEncapsulationId("anotherDuplicateId");

// Pass the model to the annotator and build the index.
annotator-&gt;buildModelIndex(model);

// Retrieve a list of duplicated ids from the annotator.
auto duplicateIdList = annotator-&gt;duplicateIds();

// Now duplicateIdList is a vector of strings of the ids which are duplicated.
// In this example it will contain "duplicateId", and "anotherDuplicateId".</literal_block>
                    </container>
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>Python</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="py" linenos="False" xml:space="preserve"># Create an Annotator instance.
annotator = Annotator()

# Create a model, with the id string "duplicateId" used on a component
# and a variable item, and an id string "anotherDuplicateId" on a units
# and encapsulation item.
model = Model("myModelName")
component = Component("myComponentName")
variable = Variable("myVariableName")
units = Units("myUnitsName")

model.addComponent(component)
model.addUnits(units)
component.addVariable(variable)

# Set the ids.
component.setId("duplicateId")
variable.setId("duplicateId")
units.setId("anotherDuplicateId")
model.setEncapsulationId("anotherDuplicateId")

# Pass the model to the annotator and build the index.
annotator.buildModelIndex(model)

# Retrieve a list of duplicated ids from the annotator.
duplicateIdList = annotator.duplicateIds()

# Now duplicateIdList is a vector of strings of the ids which are duplicated.
# In this example it will contain "duplicateId", and "anotherDuplicateId".</literal_block>
                    </container>
                </container>
            </container>
            <target refid="snippet-annotator-retrieve-duplicated-ids"></target>
            <container classes="toggle" ids="snippet-annotator-retrieve-duplicated-ids" names="snippet_annotator_retrieve_duplicated_ids">
                <container classes="header-left">
                    <paragraph>Retrieve items with duplicated ids</paragraph>
                </container>
                <paragraph>Items with a unique id can be retrieved using the <literal classes="code">item("uniqueId")</literal> function, items whose ids are not unique must be retrieved with the <literal classes="code">items("duplicatedId")</literal> function instead.</paragraph>
                <container classes="sphinx-tabs">
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>C++</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="c++" linenos="False" xml:space="preserve">// Create an Annotator instance.
auto annotator = libcellml::Annotator::create();

// Pass the model to the annotator and build the index.
annotator-&gt;buildModelIndex(model);

auto duplicatedIdItems = annotator-&gt;items("duplicatedId");
// The duplicateIdItems is a vector of AnyItem items; pairs whose first
// attribute is an Annotator::Type enum, and the second is an std::any cast
// of the item.</literal_block>
                    </container>
                    <container>
                        <container classes="item">
                            <container>
                                <paragraph>Python</paragraph>
                            </container>
                        </container>
                        <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                        </container>
                        <literal_block force="False" highlight_args="{}" language="py" linenos="False" xml:space="preserve"># Create an Annotator instance.
annotator = Annotator()

# Pass the model to the annotator and build the index.
annotator.buildModelIndex(model)

duplicatedIdItems = annotator.items("duplicatedId")
# The duplicateIdItems is a vector of items with "duplicatedId"
# as an id attribute.</literal_block>
                    </container>
                </container>
            </container>
        </section>
    </section>
</document>
