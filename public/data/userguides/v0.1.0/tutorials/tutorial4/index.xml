<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.16 -->
<document source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial4/index.rst">
    <target refid="tutorial4"></target>
    <section ids="tutorial-4-using-generated-code-to-run-a-simulation tutorial4" names="tutorial\ 4:\ using\ generated\ code\ to\ run\ a\ simulation tutorial4">
        <title>Tutorial 4: Using generated code to run a simulation</title>
        <paragraph>By the time you have worked through Tutorial 4 you will be able to:</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph>Investigate and understand the contents of files created by the <literal classes="code">Generator</literal>; and</paragraph>
            </list_item>
            <list_item>
                <paragraph>Integrate generated code into a simple solver to run a simulation.</paragraph>
            </list_item>
        </bullet_list>
        <paragraph>This tutorial assumes that you are comfortable with:</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph>Interacting with a model and its entities using the API (see <reference internal="True" refuri="../tutorial1/index#tutorial1"><inline classes="std std-ref">Tutorial 1</inline></reference> and <reference internal="True" refuri="../tutorial2/index#tutorial2"><inline classes="std std-ref">Tutorial 2</inline></reference>); and</paragraph>
            </list_item>
            <list_item>
                <paragraph>Using the <literal classes="code">Generator</literal> functionality to output files in C or Python (see <reference internal="True" refuri="../tutorial3/index#tutorial3"><inline classes="std std-ref">Tutorial 3</inline></reference>).</paragraph>
            </list_item>
        </bullet_list>
        <section ids="requirements" names="requirements">
            <title>Requirements</title>
            <container classes="directorylist">
                <paragraph><strong>C++ resources</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><download_reference filename="b823ad3768149a1f2a5a2857310b261b/CMakeLists.txt" refdoc="tutorials/tutorial4/index" refdomain="" refexplicit="False" reftarget="CMakeLists.txt" reftype="download" refwarn="False"><literal classes="xref download">CMakeLists.txt</literal></download_reference> The CMake file for building this tutorial;</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><download_reference filename="eb4ab4f66611bd3ca404fe8faad9b469/tutorial4.cpp" refdoc="tutorials/tutorial4/index" refdomain="" refexplicit="False" reftarget="tutorial4.cpp" reftype="download" refwarn="False"><literal classes="xref download">tutorial4.cpp</literal></download_reference> The skeleton code; or</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><download_reference filename="8c1bb8893280da8cbfc558077f80080b/tutorial4_complete.cpp" refdoc="tutorials/tutorial4/index" refdomain="" refexplicit="False" reftarget="tutorial4_complete.cpp" reftype="download" refwarn="False"><literal classes="xref download">tutorial4_complete.cpp</literal></download_reference> the completed tutorial code; and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><download_reference filename="633f84e50b39f993a9a5feaff12bbc4f/utilities.h" refdoc="tutorials/tutorial4/index" refdomain="" refexplicit="True" reftarget="../utilities/utilities.h" reftype="download" refwarn="False"><literal classes="xref download">utilities.h</literal></download_reference> and <download_reference filename="16e702781af8601b1f222d5dc5260a72/utilities.cpp" refdoc="tutorials/tutorial4/index" refdomain="" refexplicit="True" reftarget="../utilities/utilities.cpp" reftype="download" refwarn="False"><literal classes="xref download">utilities.cpp</literal></download_reference> Utility functions for use in the tutorials.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>Python resources</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><download_reference filename="de61349f7b2826284ee9376b63b016c3/tutorial4.py" refdoc="tutorials/tutorial4/index" refdomain="" refexplicit="False" reftarget="tutorial4.py" reftype="download" refwarn="False"><literal classes="xref download">tutorial4.py</literal></download_reference> Either the skeleton code; or</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><download_reference filename="19ce6689396a43a885a2203818e30b22/tutorial4_complete.py" refdoc="tutorials/tutorial4/index" refdomain="" refexplicit="False" reftarget="tutorial4_complete.py" reftype="download" refwarn="False"><literal classes="xref download">tutorial4_complete.py</literal></download_reference> the completed tutorial code; and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><download_reference filename="5a0301f7b835ccda86f6105901923b16/utilities.py" refdoc="tutorials/tutorial4/index" refdomain="" refexplicit="True" reftarget="../utilities/utilities.py" reftype="download" refwarn="False"><literal classes="xref download">utilities.py</literal></download_reference>  Utility functions for use in the tutorials.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>CellML resources</strong></paragraph>
                <paragraph>This tutorial is built upon the <reference internal="True" refuri="../tutorial3/index#tutorial3"><inline classes="std std-ref">previous Tutorial 3</inline></reference> and uses the output created there.
                    If you haven’t completed this tutorial, you can download those output files here:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><download_reference filename="090eae9f70a4cc74756ff281bb52f1b2/PredatorPrey.py" refdoc="tutorials/tutorial4/index" refdomain="" refexplicit="True" reftarget="PredatorPrey.py" reftype="download" refwarn="False"><literal classes="xref download">PredatorPrey.py</literal></download_reference> for use with Python; or</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><download_reference filename="cbbc9cb4f8e0b287316a771d67fb07e6/PredatorPrey.cpp" refdoc="tutorials/tutorial4/index" refdomain="" refexplicit="True" reftarget="PredatorPrey.cpp" reftype="download" refwarn="False"><literal classes="xref download">PredatorPrey.cpp</literal></download_reference> and <download_reference filename="122910c1fa59130841ccb630ef679c57/PredatorPrey.h" refdoc="tutorials/tutorial4/index" refdomain="" refexplicit="True" reftarget="PredatorPrey.h" reftype="download" refwarn="False"><literal classes="xref download">PredatorPrey.h</literal></download_reference> for use with C++.</paragraph>
                    </list_item>
                </bullet_list>
            </container>
        </section>
        <section ids="overview" names="overview">
            <title>Overview</title>
            <paragraph>During this tutorial you will take the code you generated during <reference internal="True" refuri="../tutorial3/index#tutorial3"><inline classes="std std-ref">Tutorial 3</inline></reference> which represented the population dynamics of two species - a predator, the sharks, and their prey, the fish - and investigate the files’ contents.
                Once the <literal classes="code">Generator</literal> output is understood, you will use a simple numerical integrator to solve the system of equations which governs the model’s behaviour.</paragraph>
        </section>
        <section ids="step-1-link-to-the-generated-code" names="step\ 1:\ link\ to\ the\ generated\ code">
            <title>Step 1: Link to the generated code</title>
            <paragraph>The first step in interacting with the output from the code generation is including the generated files in the project.
                There are necessarily big differences between C++ and Python for this tutorial!</paragraph>
            <container classes="sphinx-tabs">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++ instructions</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-0-0 active">
                        <container classes="dothis">
                            <paragraph><strong>1.a</strong> Enter the path to the generated header/interface <literal classes="code">*.h</literal> file in the #include block above.</paragraph>
                        </container>
                        <container classes="dothis">
                            <paragraph><strong>1.b</strong> Add the name and path of the implementation <literal classes="code">*.cpp</literal> file in the CMakeLists.txt file, (or whatever your local toolchain requires).</paragraph>
                        </container>
                        <container classes="dothis">
                            <paragraph><strong>1.c</strong> Open the implementation file <literal classes="code">*.cpp</literal> file and verify that the #include statement in line 3 has the filename of your interface <literal classes="code">*.h</literal> file.
                                Amend if needed and close the file.</paragraph>
                        </container>
                        <container classes="dothis">
                            <paragraph><strong>1.d</strong> Call cmake to create the Makefile.
                                Call make -j to build the executable.
                                Run the code so far to check that the libCellML versions match.</paragraph>
                        </container>
                        <container classes="toggle">
                            <container classes="header">
                                <paragraph>Show C++ snippet</paragraph>
                            </container>
                            <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial4/tutorial4_complete.cpp" xml:space="preserve">    //  1.e 
    //      Retrieve the version numbers from the libCellML library and the generated code you've just included.
    std::cout &lt;&lt; "The generated code used libCellML version " &lt;&lt; LIBCELLML_VERSION &lt;&lt; std::endl;
    std::cout &lt;&lt; "The library version of libCellML is " &lt;&lt; libcellml::versionString() &lt;&lt; std::endl;

</literal_block>
                        </container>
                    </container>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python instructions</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-0-1">
                        <container classes="dothis">
                            <paragraph><strong>1.a</strong> Use the <literal classes="code">importlib</literal> functionality to connect with the generated code file.</paragraph>
                        </container>
                        <container classes="dothis">
                            <paragraph><strong>1.b</strong> Load into a module.</paragraph>
                        </container>
                        <container classes="toggle">
                            <container classes="header">
                                <paragraph>Show Python snippet</paragraph>
                            </container>
                            <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial4/tutorial4_complete.py" xml:space="preserve">    #  1.a
    #       Use the importlib functionality to open the generated code file.
    spec = importlib.util.spec_from_file_location('PredatorPrey', 'PredatorPrey.py')
    module = importlib.util.module_from_spec(spec)

    #  1.b
    #       Load into a module.
    sys.modules['PredatorPrey'] = module
    spec.loader.exec_module(module)
    model = module

</literal_block>
                        </container>
                    </container>
                </container>
            </container>
        </section>
        <section ids="step-2-access-the-variables-in-the-generated-files" names="step\ 2:\ access\ the\ variables\ in\ the\ generated\ files">
            <title>Step 2: Access the variables in the generated files</title>
            <paragraph>Probably the best way to understand the contents of the generated files is to open them and look!
                The implementation file <literal classes="code">*.cpp</literal> has two types of items:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>information structures (in all-caps); and</paragraph>
                </list_item>
                <list_item>
                    <paragraph>access functions.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>It’s important to remember that in the generated code we don’t have the notion of separate components: they are listed here with the variables only in order to give the correct context to the variable names.</paragraph>
            <paragraph>“Variables” are anything which does not require integration as part of the solution, and could have types <literal classes="code">COMPUTED_CONSTANT</literal> (needs to be calculated but doesn’t need integration), <literal classes="code">CONSTANT</literal> (no calculation needed), or <literal classes="code">ALGEBRAIC</literal> as defined in the <literal classes="code">VariableType</literal> enum.
                They are stored in an array of <literal classes="code">VariableInfoWithType</literal> structs called <literal classes="code">VARIABLE_INFO</literal> which is <literal classes="code">VARIABLE_COUNT</literal> long.</paragraph>
            <container classes="shortlist">
                <paragraph>The <literal classes="code">VariableInfoWithType</literal> contains:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>name,</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>units,</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>component, and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>VariableType.</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.a</strong> Get the number of variables and iterate through the <literal classes="code">VARIABLE_INFO</literal> structure to retrieve and print each variable’s information to the terminal.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial4/tutorial4_complete.cpp" xml:space="preserve">    //  2.a
    //      Get the number of variables and iterate through the VARIABLE_INFO structure to
    //      retrieve and print each variable's information to the terminal.

    std::cout &lt;&lt; "VARIABLE_COUNT = " &lt;&lt; VARIABLE_COUNT &lt;&lt; std::endl;
    for (size_t v = 0; v &lt; VARIABLE_COUNT; ++v) {
        std::cout &lt;&lt; "Variable " &lt;&lt; v &lt;&lt; ": " &lt;&lt; std::endl;
        std::cout &lt;&lt; "  name = " &lt;&lt; VARIABLE_INFO[v].name &lt;&lt; std::endl;
        std::cout &lt;&lt; "  units = " &lt;&lt; VARIABLE_INFO[v].units &lt;&lt; std::endl;
        std::cout &lt;&lt; "  component = " &lt;&lt; VARIABLE_INFO[v].component &lt;&lt; std::endl;
        std::cout &lt;&lt; "  type = " &lt;&lt; VARIABLE_INFO[v].type &lt;&lt; std::endl;
    }

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial4/tutorial4_complete.py" xml:space="preserve">    #  2.a
    #       Get the number of variables and iterate through the VARIABLE_INFO dict to
    #       retrieve and print each variable's information to the terminal.
    print('VARIABLE_COUNT = {}'.format(model.VARIABLE_COUNT))

    for v in range (0, model.VARIABLE_COUNT):
        print('Variable {}:'.format(v))
        print('  name = {}'.format(model.VARIABLE_INFO[v]['name']))
        print('  units = {}'.format(model.VARIABLE_INFO[v]['units']))
        print('  component = {}'.format(model.VARIABLE_INFO[v]['component']))
        print('  type = {}'.format(model.VARIABLE_INFO[v]['type']))
    print()

</literal_block>
            </container>
            <paragraph>“State variables” are those which need integration.
                They are stored in an array of <literal classes="code">VariableInfo</literal> structs called <literal classes="code">STATE_INFO</literal> which
                is <literal classes="code">STATE_COUNT</literal> long.</paragraph>
            <container classes="shortlist">
                <paragraph>The <literal classes="code">VariableInfo</literal> struct contains:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>name,</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>units, and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>component.</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.b</strong> Get the number of state variables and iterate through the <literal classes="code">STATE_INFO</literal> structure to retrieve and print each state variable’s information to the terminal.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial4/tutorial4_complete.cpp" xml:space="preserve">    //  2.b
    //      Get the number of state variables and iterate through the STATE_INFO structure to
    //      retrieve and print each state variable's information to the terminal.
    std::cout &lt;&lt; std::endl;
    std::cout &lt;&lt; "STATE_COUNT = " &lt;&lt; STATE_COUNT &lt;&lt; std::endl;
    for (size_t s = 0; s &lt; STATE_COUNT; ++s) {
        std::cout &lt;&lt; "State variable " &lt;&lt; s &lt;&lt; ": " &lt;&lt; std::endl;
        std::cout &lt;&lt; "  name = " &lt;&lt; STATE_INFO[s].name &lt;&lt; std::endl;
        std::cout &lt;&lt; "  units = " &lt;&lt; STATE_INFO[s].units &lt;&lt; std::endl;
        std::cout &lt;&lt; "  component = " &lt;&lt; STATE_INFO[s].component &lt;&lt; std::endl;
    }

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial4/tutorial4_complete.py" xml:space="preserve">    #  2.b
    #       Get the number of state variables and iterate through the STATE_INFO dict to
    #       retrieve and print each state variable's information to the terminal.
    print('STATE_COUNT = {}'.format(model.STATE_COUNT))
    for s in range(0, model.STATE_COUNT):
        print('State variable {}:'.format(s))
        print('  name = {}'.format(model.STATE_INFO[s]['name']))
        print('  units = {}'.format(model.STATE_INFO[s]['units']))
        print('  component = {}'.format(model.STATE_INFO[s]['component']))
    print()

</literal_block>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.c</strong> Get the integration variable and print its information to the terminal.
                    This is stored in a <literal classes="code">VariableInfo</literal> struct called <literal classes="code">VOI_INFO</literal>.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial4/tutorial4_complete.cpp" xml:space="preserve">    //  2.c 
    //      Get the integration variable and print its information to the terminal. This
    //      is stored in a VariableInfo struct called VOI_INFO.
    std::cout &lt;&lt; std::endl;
    std::cout &lt;&lt; "VOI_INFO" &lt;&lt; std::endl;
    std::cout &lt;&lt; "  name = " &lt;&lt; VOI_INFO.name &lt;&lt; std::endl;
    std::cout &lt;&lt; "  units = " &lt;&lt; VOI_INFO.units &lt;&lt; std::endl;
    std::cout &lt;&lt; "  component = " &lt;&lt; VOI_INFO.component &lt;&lt; std::endl;
    std::cout &lt;&lt; std::endl;

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial4/tutorial4_complete.py" xml:space="preserve">    #  2.c 
    #       Get the integration variable and print its information to the terminal. This
    #       is stored in a dict called VOI_INFO.
    print('VOI_INFO')
    print('  name = {}'.format(model.VOI_INFO['name']))
    print('  units = {}'.format(model.VOI_INFO['units']))
    print('  component = {}'.format(model.VOI_INFO['component']))
    print()

</literal_block>
            </container>
        </section>
        <section ids="step-3-access-the-functions-in-the-generated-files" names="step\ 3:\ access\ the\ functions\ in\ the\ generated\ files">
            <title>Step 3: Access the functions in the generated files</title>
            <container classes="sphinx-tabs">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-1-0 active">
                        <paragraph>The generated code contains seven functions:</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph><literal classes="code">createStatesArray()</literal> to allocate an array of length <literal classes="code">STATE_COUNT</literal>.
                                    This can be used to allocate the “rates” or gradient function array too as they’re the same length;</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">createVariablesArray()</literal> to allocate an array of length <literal classes="code">VARIABLE_COUNT</literal>;</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">deleteArray()</literal> to free memory used by the given array;</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">initialiseStatesAndConstants(states, variables)</literal> will do what it says on the tin, and populate the given pre-allocated arrays with the initial values for all of the model’s state variables and constants.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">computeComputedConstants(variables)</literal> will fill in values for any variables that do not change in value throughout the solution, but still need to be calculated;</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">computeRates(VOI, states, rates, variables)</literal> updates the rates array with the gradients of the state variables, given the values of the other variables and the variable of integration (VOI);</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">computeVariables(VOI, states, rates, variables)</literal> updates any non-integrated variables whose values do not affect the integration.
                                    Since this doesn’t affect the solution process it only needs to be called whenever the values need to be output; not necessarily each integration timestep.</paragraph>
                            </list_item>
                        </bullet_list>
                    </container>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-1-1">
                        <paragraph>The generated code contains seven functions:</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph><literal classes="code">create_states_array()</literal> to allocate an array of length <literal classes="code">STATE_COUNT</literal>.
                                    This can be used to allocate the “rates” or gradient function array too as they’re the same length;</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">create_variables_array()</literal> to allocate an array of length <literal classes="code">VARIABLE_COUNT</literal>;</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">delete_array()</literal> to free memory used by the given array;</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">initialise_states_and_constants(states, variables)</literal> will do what it says on the tin, and populate the given pre-allocated arrays with the initial values for all of the model’s state variables and constants.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">compute_computed_constants(variables)</literal> will fill in values for any variables that do not change in value throughout the solution, but still need to be calculated;</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">compute_rates(VOI, states, rates, variables)</literal> updates the rates array with the gradients of the state variables, given the values of the other variables and the variable of integration (VOI);</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">compute_variables(VOI, states, rates, variables)</literal> updates any non-integrated variables whose values do not affect the integration.
                                    Since this doesn’t affect the solution process it only needs to be called whenever the values need to be output; not necessarily each integration timestep.</paragraph>
                            </list_item>
                        </bullet_list>
                    </container>
                </container>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.a</strong> Create three arrays representing:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>the variables (which here includes constants)</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>the states (the integrated variables)</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>the rates</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Create and initialise a variable of integration, time.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial4/tutorial4_complete.cpp" xml:space="preserve">    //  3.a 
    //      Create three arrays and use the functions to allocate them, representing
    //      - variables,
    //      - rates
    //      - states.
    //      Create a variable of integration and set it to 0.
    auto myVariables = createVariablesArray();
    auto myStateVariables = createStatesArray();
    auto myRates = createStatesArray();
    double time = 0;

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial4/tutorial4_complete.py" xml:space="preserve">    #  3.a 
    #       Create three arrays representing:
    #       - the variables (which here includes constants)
    #       - the states (the integrated variables)
    #       - the rates 
    #       Create and initialise a variable of integration, time.
    my_variables = model.create_variables_array()
    my_state_variables = model.create_states_array()
    my_rates = model.create_states_array()
    time = 0.0

</literal_block>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.b</strong> Use the functions provided to initialise the states array you created, then print them to the screen for checking.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial4/tutorial4_complete.cpp" xml:space="preserve">    //  3.b 
    //      Use the functions provided to initialise the arrays you created, then print them 
    //      to the screen for checking.
    initialiseStatesAndConstants(myStateVariables, myVariables);

    std::cout &lt;&lt; "The initial conditions for state variables are:" &lt;&lt; std::endl;
    for (size_t v = 0; v &lt; STATE_COUNT; ++v) {
        std::cout &lt;&lt; "  " &lt;&lt; STATE_INFO[v].component &lt;&lt; " " &lt;&lt; STATE_INFO[v].name &lt;&lt; "  = " &lt;&lt; myStateVariables[v] &lt;&lt; " (" &lt;&lt; STATE_INFO[v].units &lt;&lt; ")"&lt;&lt; std::endl;
    }
    std::cout &lt;&lt; std::endl;

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial4/tutorial4_complete.py" xml:space="preserve">    #  3.b 
    #       Use the functions provided to initialise the arrays you created, then print them 
    #       to the screen for checking.
    model.initialise_states_and_constants(my_state_variables, my_variables)
    print('The initial conditions for state variables are:')
    for v in range(0, model.STATE_COUNT):
        print('{} {} = {} ({})'.format(
            model.STATE_INFO[v]['component'],
            model.STATE_INFO[v]['name'],
            my_state_variables[v],
            model.STATE_INFO[v]['units']
            ))
    print()

</literal_block>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.c</strong> Compute the constants, compute the variables, and print them to the screen for checking.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial4/tutorial4_complete.cpp" xml:space="preserve">    //  3.c 
    //      Compute the constants, compute the variables, and print them to the screen for checking.
    computeComputedConstants(myVariables);
    computeVariables(time, myStateVariables, myRates, myVariables);
    std::cout &lt;&lt; "The initial values including all computed constants are:" &lt;&lt; std::endl;
    for (size_t v = 0; v &lt; VARIABLE_COUNT; ++v) {
        std::cout &lt;&lt; "  " &lt;&lt; VARIABLE_INFO[v].name &lt;&lt; " = " &lt;&lt; myVariables[v] &lt;&lt; " (" &lt;&lt; VARIABLE_INFO[v].units &lt;&lt; ")"&lt;&lt;std::endl;
    }
    std::cout &lt;&lt; std::endl;

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial4/tutorial4_complete.py" xml:space="preserve">    #  3.c 
    #       Compute the constants, compute the variables,  and print them to the screen for checking.
    print('The initial values including all computed constants are:')
    model.compute_computed_constants(my_variables)
    model.compute_variables(time, my_state_variables, my_rates, my_variables)
    for v in range(0, model.VARIABLE_COUNT):
        print('  {} = {} ({})'.format(
            model.VARIABLE_INFO[v]['name'],
            my_variables[v],
            model.VARIABLE_INFO[v]['units']
            ))
    print()

</literal_block>
            </container>
        </section>
        <section ids="step-4-iterate-through-the-solution" names="step\ 4:\ iterate\ through\ the\ solution">
            <title>Step 4: Iterate through the solution</title>
            <paragraph>This part will make use of a simple routine to step through the solution iterations using the Euler method to update the state variables.</paragraph>
            <container classes="dothis">
                <paragraph><strong>4.a</strong> Create variables which control how the solution will run, representing:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>step size; and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>the number of steps to take.</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial4/tutorial4_complete.cpp" xml:space="preserve">    //  4.a 
    //      Create variables which control how the solution will run, representing:
    //      - variable of integration (time);
    //      - step size; and
    //      - the number of steps to take.
    double stepSize = 0.01;
    int stepCount = 2000;
    int incr = (int)(stepCount/60) + 1;

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial4/tutorial4_complete.py" xml:space="preserve">    #  4.a 
    #       Create variables which control how the solution will run, representing:
    #       - step size and
    #       - the number of steps to take.
    step_size = 0.01
    step_count = 2000
    incr = int(step_count/60) + 1

</literal_block>
            </container>
            <container classes="dothis">
                <paragraph><strong>4.b</strong> Create a file for output and open it.
                    You can use the information to name columns with the variables, component, and units so you can keep track later.</paragraph>
            </container>
            <paragraph>The Euler update method is: <math>x[n+1] = x[n] + x'[n].dx</math></paragraph>
            <container classes="shortlist">
                <paragraph>At each step you will need to:</paragraph>
                <block_quote>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>Compute the rates;</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>Compute the state variables using the update method above;</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>Compute the variables; **</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>Print to a file.</paragraph>
                        </list_item>
                    </bullet_list>
                </block_quote>
                <paragraph>** We only need to compute these each timestep here because we’re also writing the values to the file at each timestep.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial4/tutorial4_complete.cpp" xml:space="preserve">    //  4.b 
    //      Create a file for output and open it. You can use the information to name columns
    //      with the variables, component, and units so you can keep track later.
    std::ofstream outFile("solution.txt");
    outFile &lt;&lt; "iteration";
    outFile &lt;&lt; "\t" &lt;&lt; VOI_INFO.name &lt;&lt; " (" &lt;&lt; VOI_INFO.units &lt;&lt; ")";
    for (size_t v = 0; v &lt; VARIABLE_COUNT; ++v) {
        outFile &lt;&lt; "\t" &lt;&lt; VARIABLE_INFO[v].component&lt;&lt;":"&lt;&lt;VARIABLE_INFO[v].name &lt;&lt; " (" &lt;&lt; VARIABLE_INFO[v].units &lt;&lt; ")";
    }
    for (size_t s = 0; s &lt; STATE_COUNT; ++s) {
        outFile &lt;&lt; "\t" &lt;&lt; STATE_INFO[s].component&lt;&lt;":"&lt;&lt;STATE_INFO[s].name &lt;&lt; " (" &lt;&lt; STATE_INFO[s].units &lt;&lt; ")";
    }
    outFile &lt;&lt; std::endl;
   
</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial4/tutorial4_complete.py" xml:space="preserve">    #  4.b 
    #       Create a file for output and open it. You can use the information to name columns
    #       with the variables, component, and units so you can keep track later.
    write_file = open('solution.txt', 'w')
    row = 'iteration\t{}({})'.format(
        model.VOI_INFO['name'], model.VOI_INFO['units'])
    for s in range(0, model.STATE_COUNT):
        row += '\t{}({})'.format(model.STATE_INFO[s]
                                 ['name'], model.STATE_INFO[s]['units'])
    for s in range(0, model.VARIABLE_COUNT):
        row += '\t{}({})'.format(model.VARIABLE_INFO[s]
                                 ['name'], model.VARIABLE_INFO[s]['units'])
    row += '\n'
    write_file.write(row)

</literal_block>
            </container>
            <container classes="dothis">
                <paragraph><strong>4.c</strong> Iterate through the time domain, calculate and write the solution at each step.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial4/tutorial4_complete.cpp" xml:space="preserve">    //  4.c
    //      Iterate through the time domain and write the solution at each step. 
    for (size_t step = 0; step &lt; stepCount; ++step) {
        time = step * stepSize;

        // Compute the rates at this step using the given function.
        computeRates(time, myStateVariables, myRates, myVariables);
        
        // Compute the solution at the next step using whatever numerical integration 
        // method you choose. In this example we've used Euler, as given above.
        for (size_t s = 0; s &lt; STATE_COUNT; ++s) {
            myStateVariables[s] = myStateVariables[s] + myRates[s] * stepSize;
        }

        // Compute the variables at this step using the given function.
        computeVariables(time, myStateVariables, myRates, myVariables);

        // Write everything to the output file.  Keep the order of columns consistent with
        // whatever you've used in step 4.c.
        outFile &lt;&lt; step &lt;&lt; "\t " &lt;&lt; time;
        for(size_t v = 0; v &lt; VARIABLE_COUNT; ++v) {
            outFile &lt;&lt; "\t " &lt;&lt; myVariables[v];
        }
        for (size_t s = 0; s &lt; STATE_COUNT; ++s) {
            outFile &lt;&lt; "\t" &lt;&lt; myStateVariables[s];
        }
        outFile &lt;&lt; "\n";
        if(step % incr == 0) {
            std::cout &lt;&lt; "." &lt;&lt; std::flush;
        }
    }
    std::cout &lt;&lt; std::endl &lt;&lt; "Finished!" &lt;&lt; std::endl;
    outFile.close();

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial4/tutorial4_complete.py" xml:space="preserve">    #  4.c 
    #      Iterate through the time domain and write the solution at each step. 
    for step in range(0, step_count):
        time = step * step_size

        # Compute the rates at this step using the given function.
        model.compute_rates(time, my_state_variables, my_rates, my_variables)

        row = '{}\t{}'.format(step, time)

        # Compute the states.
        for s in range(0, model.STATE_COUNT):
            my_state_variables[s] = my_state_variables[s] + my_rates[s] * step_size
            row += '\t{}'.format(my_state_variables[s])

        # Compute the variables.
        model.compute_variables(time, my_state_variables, my_rates, my_variables)
        for s in range(0, model.VARIABLE_COUNT):
            row += '\t{}'.format(my_variables[s])

        row += '\n'
        # Write to file.
        write_file.write(row)

        # Print progress bar.
        if step % incr == 0:
            print('.', end='', flush=True)

    write_file.close()
   
</literal_block>
            </container>
        </section>
        <section ids="step-5-sanity-check" names="step\ 5:\ sanity\ check">
            <title>Step 5: Sanity check</title>
            <paragraph>You should find results similar to the figure below, where the cyclical dependency of the shark and fish populations can be seen.</paragraph>
            <figure align="center" ids="sharksandfish" names="sharksandfish">
                <image alt="Population dynamics of sharks and fish" candidates="{'*': 'tutorials/tutorial4/../images/sharks_and_fish.png'}" uri="tutorials/tutorial4/../images/sharks_and_fish.png"></image>
                <caption>Population dynamics for the sharks and fish.</caption>
            </figure>
        </section>
    </section>
</document>
