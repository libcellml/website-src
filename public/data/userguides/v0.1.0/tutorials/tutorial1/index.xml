<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.16 -->
<document source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial1/index.rst">
    <target refid="tutorial1"></target>
    <section ids="tutorial-1-reading-and-writing-cellml-files tutorial1" names="tutorial\ 1:\ reading\ and\ writing\ cellml\ files tutorial1">
        <title>Tutorial 1: Reading and writing CellML files</title>
        <paragraph>Welcome to the introductory tutorial for the use of the libCellML library.
            Using these tutorials in sequence will walk you through the functionality and build your knowledge step by step.
            If, however, you just need to jump in and figure out one specific idea, you can find a tutorial related to that subject using the <reference internal="True" refuri="../../howto/index#howto"><inline classes="std std-ref">How-to pages</inline></reference>.</paragraph>
        <container classes="shortlist">
            <paragraph>After completing this tutorial you will be able to:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Read the contents of a CellML file;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Deserialise its contents using the <literal classes="code">Parser</literal> to create a <literal classes="code">Model</literal> structure;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Investigate the hierarchical contents of the <literal classes="code">Model</literal>, including the <literal classes="code">Components</literal>, <literal classes="code">Variables</literal>, and MathML blocks; and</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Serialise the model and write to another file using the <literal classes="code">Printer</literal>.</paragraph>
                </list_item>
            </bullet_list>
        </container>
        <section ids="requirements" names="requirements">
            <title>Requirements</title>
            <container classes="directorylist">
                <paragraph><strong>C++ resources</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><download_reference filename="f569ae31e378f9944d5d3a27fd8d2cbe/CMakeLists.txt" refdoc="tutorials/tutorial1/index" refdomain="" refexplicit="True" reftarget="CMakeLists.txt" reftype="download" refwarn="False"><literal classes="xref download">CMakeLists.txt</literal></download_reference> The CMake file for building;</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><download_reference filename="b85f96ac1f7dbff74f0f3dc1273c0ea8/tutorial1.cpp" refdoc="tutorials/tutorial1/index" refdomain="" refexplicit="True" reftarget="tutorial1.cpp" reftype="download" refwarn="False"><literal classes="xref download">tutorial1.cpp</literal></download_reference> The skeleton code or</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><download_reference filename="27c7aee0282cf5e923e4d6fe57d371f8/tutorial1_complete.cpp" refdoc="tutorials/tutorial1/index" refdomain="" refexplicit="True" reftarget="tutorial1_complete.cpp" reftype="download" refwarn="False"><literal classes="xref download">tutorial1_complete.cpp</literal></download_reference> the completed code.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>Python resources</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><download_reference filename="09bc82cea89b7f0b74c0249ad730717c/tutorial1.py" refdoc="tutorials/tutorial1/index" refdomain="" refexplicit="False" reftarget="tutorial1.py" reftype="download" refwarn="False"><literal classes="xref download">tutorial1.py</literal></download_reference> The skeleton code or</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><download_reference filename="a85763f4c4cbde6a1889b75c1ac65f6b/tutorial1_complete.py" refdoc="tutorials/tutorial1/index" refdomain="" refexplicit="False" reftarget="tutorial1_complete.py" reftype="download" refwarn="False"><literal classes="xref download">tutorial1_complete.py</literal></download_reference> the completed code.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>CellML resources</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><download_reference filename="b46923916a5af65d7692c758f0334959/tutorial1.cellml" refdoc="tutorials/tutorial1/index" refdomain="" refexplicit="True" reftarget="tutorial1.cellml" reftype="download" refwarn="False"><literal classes="xref download">tutorial1.cellml</literal></download_reference> the input CellML file.</paragraph>
                    </list_item>
                </bullet_list>
            </container>
        </section>
        <section ids="step-0-set-up" names="step\ 0:\ set-up">
            <title>Step 0: Set-up</title>
            <paragraph>For each of the tutorials, there is template code provided for you to get started.
                If you’d rather see the completed code instead of working through the tasks yourself, simply rename the completed files so that they match the skeleton file names (that is, remove the <literal classes="code">_completed</literal> from their names).</paragraph>
            <container classes="sphinx-tabs">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-0-0 active">
                        <container classes="dothis">
                            <paragraph><strong>0.a</strong> Navigate into the <literal classes="code">tutorial1</literal> folder and confirm that you’re able to compile and run this template against the libCellML library.</paragraph>
                        </container>
                        <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">cmake -DINSTALL_PREFIX=../../install
make -j</literal_block>
                        <paragraph>Running the template:</paragraph>
                        <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">./tutorial1</literal_block>
                        <paragraph>… should give the output:</paragraph>
                        <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">-----------------------------------------------
 TUTORIAL 1: READING AND WRITING CELLML FILES
-----------------------------------------------</literal_block>
                    </container>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-0-1">
                        <paragraph>For each of the tutorials, there is template code provided for you to get started in each of the <literal classes="code">tutorial*.py</literal> files.</paragraph>
                        <container classes="dothis">
                            <paragraph><strong>0.a</strong> Confirm that you’re able to run the <literal classes="code">tutorial1.py</literal> template against the libCellML library.
                                Navigate into the directory and run the skeleton code file, <literal classes="code">tutorial1.py</literal>.</paragraph>
                        </container>
                        <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">cd tutorial1
python3 tutorial1.py</literal_block>
                        <paragraph>This should give the output:</paragraph>
                        <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">-----------------------------------------------------
    TUTORIAL 1: READING AND WRITING CellML2 FILES
-----------------------------------------------------</literal_block>
                    </container>
                </container>
            </container>
        </section>
        <section ids="step-1-deserialise-a-cellml2-file" names="step\ 1:\ deserialise\ a\ cellml2\ file">
            <title>Step 1: Deserialise a CellML2 file</title>
            <paragraph>CellML is a format in which all the information is stored in a strict hierarchical way.
                In order for this information to be transformed into a format which can be <emphasis>used</emphasis> for modelling and simulation it needs to be
                <emphasis>deserialised</emphasis> into the internal <literal classes="code">Model</literal> format.
                The hard work of this transformation is done by the <literal classes="code">Parser</literal> object which will take a raw CellML string which represents a model and return its corresponding <literal classes="code">Model</literal> item.</paragraph>
            <container classes="useful">
                <paragraph><reference internal="False" refuri="/documentation/api/latest/classlibcellml_1_1Parser">Parser class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference internal="False" refuri="/documentation/api/latest/classlibcellml_1_1Parser?fName=create">create</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference internal="False" refuri="/documentation/api/latest/classlibcellml_1_1Parser?fName=parseModel">parseModel</reference></paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>1.a</strong> You’ve been provided with a CellML file which we’ll be reading in this tutorial, <literal classes="code">tutorial1.cellml</literal>.
                    Open the file and read its entire contents into a string.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>1.b</strong> Create a <literal classes="code">Parser</literal> instance.
                    Pass the string you read above into the parser using the <literal classes="code">parseModel</literal> function.
                    This will return a newly-created <literal classes="code">Model</literal> instance.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial1/tutorial1_complete.cpp" xml:space="preserve">    //  1.a   
    //      Open the file and read its contents into a buffer stream.

    std::string inFileName = "tutorial1.cellml";
    std::ifstream inFile(inFileName);
    std::stringstream inFileContents;
    inFileContents &lt;&lt; inFile.rdbuf();

    std::cout &lt;&lt; "Opening the CellML file" &lt;&lt; std::endl;

    //  1.b   
    //      Create a libCellML Parser, and use it to parse the fileContents
    //      string and convert it into a CellML Model structure.
    
    auto parser = libcellml::Parser::create();
    auto model = parser-&gt;parseModel(inFileContents.str());

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial1/tutorial1_complete.py" xml:space="preserve">    #  1.a
    #     Open the tutorial1.cellml file for reading
    read_file = open("tutorial1.cellml", "r")

    #  1.b   
    #     Create a libCellML Parser, and use it to parse the file
    #     string contents and convert it into a CellML Model structure
    parser = Parser()
    model = parser.parseModel(read_file.read())

</literal_block>
            </container>
            <paragraph>Now we have a <emphasis>deserialised</emphasis> CellML model which we can manipulate using the libCellML library.</paragraph>
        </section>
        <section ids="step-2-investigate-the-contents-of-the-model" names="step\ 2:\ investigate\ the\ contents\ of\ the\ model">
            <title>Step 2: Investigate the contents of the model</title>
            <paragraph>Now that we have a model, let’s see what’s inside it.
                All retrieval functions - where you want to read something about any item - are callable from simple functions naming the thing you want.</paragraph>
            <container classes="useful">
                <paragraph><reference internal="False" refuri="/documentation/api/latest/classlibcellml_1_1Model">Model class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference internal="False" refuri="/documentation/api/latest/classlibcellml_1_1Model?fName=name">name</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference internal="False" refuri="/documentation/api/latest/classlibcellml_1_1Model?fName=id">id</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference internal="False" refuri="/documentation/api/latest/classlibcellml_1_1Model?fName=componentCount">componentCount</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference internal="False" refuri="/documentation/api/latest/classlibcellml_1_1Model?fName=unitsCount">unitsCount</reference></paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><reference internal="False" refuri="/documentation/api/latest/classlibcellml_1_1Component">Component class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference internal="False" refuri="/documentation/api/latest/classlibcellml_1_1Component?fName=name">name</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference internal="False" refuri="/documentation/api/latest/classlibcellml_1_1Component?fName=id">id</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference internal="False" refuri="/documentation/api/latest/classlibcellml_1_1Component?fName=variableCount">variableCount</reference></paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><reference internal="False" refuri="/documentation/api/latest/classlibcellml_1_1Variable">Variable class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference internal="False" refuri="/documentation/api/latest/classlibcellml_1_1Variable?fName=name">name</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference internal="False" refuri="/documentation/api/latest/classlibcellml_1_1Variable?fName=id">id</reference></paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <paragraph>For example, to find the name of the model we simply call its <literal classes="code">name()</literal> function to return the string of its name.</paragraph>
            <container classes="dothis">
                <paragraph><strong>2.a</strong> Find out the name and id of your model and print them to the terminal.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">The model name is: tutorial_1_model
The model id is: tutorial_1_model_id_is_here</literal_block>
            <paragraph>The <literal classes="code">Model</literal> itself stores two kinds of objects: a set of <literal classes="code">Units</literal> objects, and a set of <literal classes="code">Component</literal> objects.
                There are generic <literal classes="code">somethingCount()</literal> functions which will return the number of <literal classes="code">Something</literal> items within that object:</paragraph>
            <container classes="sphinx-tabs">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                    </container>
                    <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">auto numberOfComponents = myFirstModel-&gt;componentCount();</literal_block>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                    </container>
                    <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">number_of_components = my_first_model.componentCount()</literal_block>
                </container>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.b</strong> Find out the number of <literal classes="code">Component</literal> items in the model, and print it to the terminal.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">The tutorial_1_model model has 1 component(s)</literal_block>
            <paragraph>Items like components and units (and later, variables) which are stored in sets can be accessed by their index as well as by their name.
                At this stage, since we don’t <emphasis>know</emphasis> the name of the components, we’ll have to use their indices to access them for printing to the terminal.
                The indices start at <literal classes="code">0</literal>.</paragraph>
            <paragraph>Each <literal classes="code">Component</literal> itself (or later, <literal classes="code">Units</literal> or <literal classes="code">Variable</literal>) is retrieved from its parent item as a pointer (that is, a <literal classes="code">ComponentPtr</literal> type) using the same idiom as the names and ids:</paragraph>
            <container classes="sphinx-tabs">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                    </container>
                    <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Retrieve the 33rd component from myFirstModel.  Note the indexing from zero.
auto thirtyThirdComponent = myFirstModel-&gt;component(32);</literal_block>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                    </container>
                    <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Retrieve the 33rd component from my_first_model.  Note the indexing from zero.
thirty_third_component = my_first_model.component(32)</literal_block>
                </container>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.c</strong> Retrieve the first component from the model, and print its name and id to the terminal.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">The tutorial_1_model model has 1 component(s):
    Component[0] has name: i_am_a_component
    Component[0] has id: my_component_id</literal_block>
            <paragraph><literal classes="code">Component</literal> items in turn contain four kinds of items, these being:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>a set of <literal classes="code">Variable</literal> items;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>a <literal classes="code">MathML</literal> string which controls the governing mathematical equations of the model behaviour;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>(for later) a set of <literal classes="code">Reset</literal> items; and</paragraph>
                </list_item>
                <list_item>
                    <paragraph>(also for later) an optional nested subset of <literal classes="code">Component</literal> items too.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>In this tutorial we’ll only look at the variables and maths.</paragraph>
            <container classes="dothis">
                <paragraph><strong>2.d</strong> Retrieve the number of variables inside your component, and print it to the screen.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.e</strong> Create a loop through the variables, retrieve each, and print their names to the screen.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">The i_am_a_component component has 3 variable(s):
    Variable[0] has name: a
    Variable[1] has name: b
    Variable[2] has name: c</literal_block>
            <container classes="dothis">
                <paragraph><strong>2.f</strong> We will look more at what the MathML string actually <emphasis>means</emphasis> in later tutorials, but for now, retrieve the MathML string from your component using the <literal classes="code">math()</literal> function, and print it to the screen.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">Component i_am_a_component has a MathML string of:
    &lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;
    &lt;apply&gt;
        &lt;eq/&gt;
        &lt;ci&gt;a&lt;/ci&gt;
        &lt;apply&gt;
        &lt;plus/&gt;
        &lt;ci&gt;b&lt;/ci&gt;
        &lt;ci&gt;c&lt;/ci&gt;
        &lt;/apply&gt;
    &lt;/apply&gt;
    &lt;/math&gt;</literal_block>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial1/tutorial1_complete.cpp" xml:space="preserve">    //  2.a  
    //      Return the name and id of the new model, and print to the terminal.

    std::string modelName = model-&gt;name();
    std::string modelId = model-&gt;id();

    std::cout &lt;&lt; "The model name is: " &lt;&lt; modelName &lt;&lt; std::endl;
    std::cout &lt;&lt; "The model id is: " &lt;&lt; modelId &lt;&lt; std::endl;

    //  2.b
    //      Return the number of components contained in the model, and print
    //      to the screen.

    int numberOfComponents = model-&gt;componentCount();
    std::cout &lt;&lt; "The " &lt;&lt; modelName &lt;&lt; " model has " &lt;&lt; numberOfComponents
              &lt;&lt; " component(s):" &lt;&lt; std::endl;

    assert(numberOfComponents &gt; 0);

    //  2.c   
    //      Return the name and id of the first component and print them to
    //      the screen.

    auto component = model-&gt;component(0);
    std::string componentName = component-&gt;name();
    std::string componentId = component-&gt;id();
    std::cout &lt;&lt; "  Component[0] has name: " &lt;&lt; componentName &lt;&lt; std::endl;
    std::cout &lt;&lt; "  Component[0] has id: " &lt;&lt; componentId &lt;&lt; std::endl;

    //  2.d   
    //      Retrieve the number of variables in this component, and print
    //      to the screen.

    int numberOfVariables = component-&gt;variableCount();
    std::cout &lt;&lt; "  The " &lt;&lt; componentName &lt;&lt; " component has "
              &lt;&lt; numberOfVariables &lt;&lt; " variable(s):" &lt;&lt; std::endl;

    //  2.e
    //      Loop through the variables and print their names to the terminal.

    for (size_t v = 0; v &lt; numberOfVariables; ++v) {
        auto variable = component-&gt;variable(v);
        std::string variableName = variable-&gt;name();

        std::cout &lt;&lt; "    Variable[" &lt;&lt; v &lt;&lt; "] has name: " &lt;&lt; variableName
                  &lt;&lt; std::endl;
    }

    //  2.f
    //      Investigate the maths which connects the variables in this
    //      component.  Note that maths in libCellML is stored as a
    //      single string, which could contain any number of MathML blocks.

    std::string mathsString = component-&gt;math();
    std::cout &lt;&lt; "  Component " &lt;&lt; componentName
              &lt;&lt; " has a MathML string of: " &lt;&lt; std::endl;
    std::cout &lt;&lt; "  " &lt;&lt; mathsString &lt;&lt; std::endl;

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial1/tutorial1_complete.py" xml:space="preserve">    #  2.a
    #     Return the name and id of the new model, and print to the terminal.
    model_name = model.name()
    model_id = model.id()

    print("The model name is: " + model_name)
    print("The model id is: " + model_id)

    #  2.b
    #     Return the number of components contained in the model, and print to the screen.
    number_of_components = model.componentCount()
    print("The '{m}' model has {n} component(s):".format(
        m=model_name,
        n=number_of_components)
    )

    #  2.c
    #     Return the name and id of the first component and print them to the screen.
    component = model.component(0)
    component_name = component.name()
    component_id = component.id()
    print("  Component[0] has name: ", component_name)
    print("  Component[0] has id: ", component_id)

    #  2.d
    #     Retrieve the number of variables in the component, and print to the screen.
    number_of_variables = component.variableCount()
    print("  The '{c}' component has {n} variable(s):".format(
        c=component_name,
        n=number_of_variables)
    )
    #  2.e
    #     Loop through the variables in the component, and print their names to the terminal.
    for v in range(0, number_of_variables):
        print("    Variable[{v}] has name: {n}".format(v=v, n=component.variable(v).name()))

    #  2.f
    #     Investigate the maths which connects the variables in this component.  Note that
    #     maths in libCellML is stored as a single MathML2 string.
    maths_string = component.math()
    print("  Component '{c}' has a MathML string of: ".format(c=component_name))
    print("		"+maths_string)

</literal_block>
            </container>
        </section>
        <section ids="step-3-serialise-the-model-and-output-to-a-file" names="step\ 3:\ serialise\ the\ model\ and\ output\ to\ a\ file">
            <title>Step 3: Serialise the model and output to a file</title>
            <paragraph>Now that you’ve seen how to <emphasis>deserialise</emphasis> a CellML file into a model using the <literal classes="code">Parser</literal>, it’s time to go in the other direction.
                This reverse operation is handled by the <literal classes="code">Printer</literal>, which will transform a model into a string for output to a file.</paragraph>
            <container classes="useful">
                <paragraph><reference internal="False" refuri="/documentation/api/latest/classlibcellml_1_1Printer">Printer class</reference></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference internal="False" refuri="/documentation/api/latest/classlibcellml_1_1Printer?fName=create">create</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference internal="False" refuri="/documentation/api/latest/classlibcellml_1_1Printer?fName=printModel">printModel</reference></paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="sphinx-tabs">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                    </container>
                    <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">auto printer = libcellml::Printer::create();
std::string serialisedModelString = printer-&gt;printModel(myFirstModel);</literal_block>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                    </container>
                    <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">printer = Printer()
serialised_model_string = printer.printModel(my_first_model)</literal_block>
                </container>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.a</strong> Create a printer and use it to serialise your model.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.b</strong> Write that serialised string to a new <literal classes="code">.cellml</literal> file.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.c</strong> Go and have a cuppa, you’re done :)</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial1/tutorial1_complete.cpp" xml:space="preserve">    //  3.a
    //      Create a Printer and use it to serialise the model to a string.

    auto printer = libcellml::Printer::create();
    std::string serialisedModelString = printer-&gt;printModel(model);

    //  3.b
    //      Write the serialised string to a file.

    std::string outFileName = "tutorial1_printed.cellml";
    std::ofstream outFile(outFileName);
    outFile &lt;&lt; serialisedModelString;
    outFile.close();

    std::cout &lt;&lt; "The " &lt;&lt; modelName &lt;&lt; " has been printed to: " &lt;&lt; outFileName
              &lt;&lt; std::endl;

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/tutorial1/tutorial1_complete.py" xml:space="preserve">    #  3.a
    #     Create a Printer and use it to serialise the model to a string.
    printer = Printer()
    serialised_model = printer.printModel(model)

    #  3.b
    #     Write the serialised string to a file.
    write_file = open("tutorial1_printed.cellml", "w")
    write_file.write(serialised_model)
    print("The {} has been printed to tutorial1_printed.cellml".format(model_name))

</literal_block>
            </container>
        </section>
    </section>
</document>
