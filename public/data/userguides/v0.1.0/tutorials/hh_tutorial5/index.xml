<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.16 -->
<document source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorial5/index.rst">
    <target refid="solvegeneratedcode"></target>
    <section ids="hodgkin-huxley-5-interact-with-generated-code solvegeneratedcode" names="hodgkin-huxley\ 5:\ interact\ with\ generated\ code solvegeneratedcode">
        <title>Hodgkin-Huxley 5: Interact with generated code</title>
        <container classes="shortlist">
            <paragraph>By the time you have worked through this tutorial you will be able to:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Investigate and understand the contents of files created by the Generator; and</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Integrate generated code into a simple solver to run a simulation.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>This tutorial assumes that you are comfortable with:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Interacting with a model and its entities using the API;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Using the <literal classes="code">Generator</literal> functionality to output files in C or Python; and</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The basic idea of numerical integration using Euler’s method.</paragraph>
                </list_item>
            </bullet_list>
        </container>
        <container classes="directorylist">
            <paragraph><strong>C++ resources</strong></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><download_reference filename="b48bbfbc8ba9fd012702dc5cdf0a1102/CMakeLists.txt" refdoc="tutorials/hh_tutorial5/index" refdomain="" refexplicit="True" reftarget="CMakeLists.txt" reftype="download" refwarn="False"><literal classes="xref download">CMakeLists.txt</literal></download_reference> The CMake file for building this tutorial;</paragraph>
                </list_item>
                <list_item>
                    <paragraph><download_reference filename="887699a23290595598710e669a90db29/solveGeneratedCode.cpp" refdoc="tutorials/hh_tutorial5/index" refdomain="" refexplicit="True" reftarget="solveGeneratedCode.cpp" reftype="download" refwarn="False"><literal classes="xref download">solveGeneratedCode.cpp</literal></download_reference> Either the skeleton code, or ..</paragraph>
                </list_item>
                <list_item>
                    <paragraph><download_reference filename="09bfb7623b1acabaa173f45128b03126/solveGeneratedCode_completed.cpp" refdoc="tutorials/hh_tutorial5/index" refdomain="" refexplicit="True" reftarget="solveGeneratedCode_completed.cpp" reftype="download" refwarn="False"><literal classes="xref download">solveGeneratedCode_completed.cpp</literal></download_reference> the completed tutorial code;</paragraph>
                </list_item>
                <list_item>
                    <paragraph><download_reference filename="fdf6f335e1d7e260121061429d55819f/HodgkinHuxleyModel.cpp" refdoc="tutorials/hh_tutorial5/index" refdomain="" refexplicit="True" reftarget="HodgkinHuxleyModel.cpp" reftype="download" refwarn="False"><literal classes="xref download">HodgkinHuxleyModel.cpp</literal></download_reference> Generated implementation code from Tutorial 4; and</paragraph>
                </list_item>
                <list_item>
                    <paragraph><download_reference filename="48bb1439f5f2f277c7b4db5e69bdf8e9/HodgkinHuxleyModel.h" refdoc="tutorials/hh_tutorial5/index" refdomain="" refexplicit="True" reftarget="HodgkinHuxleyModel.h" reftype="download" refwarn="False"><literal classes="xref download">HodgkinHuxleyModel.h</literal></download_reference> Generated interface code from Tutorial 4.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph><strong>Python resources</strong></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><download_reference filename="52127715dd1e089b58dfd023c749321c/solveGeneratedCode.py" refdoc="tutorials/hh_tutorial5/index" refdomain="" refexplicit="True" reftarget="solveGeneratedCode.py" reftype="download" refwarn="False"><literal classes="xref download">solveGeneratedCode.py</literal></download_reference> Either the skeleton code, or ..</paragraph>
                </list_item>
                <list_item>
                    <paragraph><download_reference filename="f772ccc245216e3aac7cd36b2a26d7f5/solveGeneratedCode_completed.py" refdoc="tutorials/hh_tutorial5/index" refdomain="" refexplicit="True" reftarget="solveGeneratedCode_completed.py" reftype="download" refwarn="False"><literal classes="xref download">solveGeneratedCode_completed.py</literal></download_reference> the completed tutorial code;</paragraph>
                </list_item>
                <list_item>
                    <paragraph><download_reference filename="cacc75e5c31e3f37cc271c7a3de402ca/HodgkinHuxleyModel.py" refdoc="tutorials/hh_tutorial5/index" refdomain="" refexplicit="True" reftarget="HodgkinHuxleyModel.py" reftype="download" refwarn="False"><literal classes="xref download">HodgkinHuxleyModel.py</literal></download_reference> Generated implementation code from Tutorial 4.</paragraph>
                </list_item>
            </bullet_list>
        </container>
        <section ids="step-1-link-to-the-generated-code" names="step\ 1:\ link\ to\ the\ generated\ code">
            <title>Step 1: Link to the generated code</title>
            <paragraph>The first step in interacting with the output from the code generation is including the generated files in the project.
                There are necessarily big differences between C++ and Python for this tutorial!</paragraph>
            <container classes="sphinx-tabs">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++ instructions</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-0-0 active">
                        <container classes="dothis">
                            <paragraph><strong>1.a</strong> Enter the path to the generated header/interface <literal classes="code">*.h</literal> file in the #include block above.</paragraph>
                        </container>
                        <container classes="dothis">
                            <paragraph><strong>1.b</strong> Add the name and path of the implementation <literal classes="code">*.cpp</literal> file in the CMakeLists.txt file, (or whatever your local toolchain requires).</paragraph>
                        </container>
                        <container classes="dothis">
                            <paragraph><strong>1.c</strong> Open the implementation file <literal classes="code">*.cpp</literal> file and verify that the <literal classes="code">#include</literal> statement in line 3 has the filename of your interface <literal classes="code">*.h</literal> file.
                                Amend if needed and close the file.</paragraph>
                        </container>
                        <container classes="dothis">
                            <paragraph><strong>1.d</strong> Call cmake to create the Makefile.
                                Call make -j to build the executable.
                                Run the code so far to check that the libCellML versions match.</paragraph>
                        </container>
                        <container classes="toggle">
                            <container classes="header">
                                <paragraph>Show C++ snippet</paragraph>
                            </container>
                            <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorial5/solveGeneratedCode_completed.cpp" xml:space="preserve">    //  1.a 
    //      Enter the path to the generated header/interface *.h file in the #include block above.

    //  1.b 
    //      Add the name and path of the implementation *.cpp file in the CMakeLists.txt file, 
    //      (or whatever your local toolchain requires).

    //  1.c 
    //      Open the implementation file *.cpp file and verify that the #include statement in
    //      line 3 has the filename of your interface *.h file.  Amend if needed and close the file.

    //  1.d 
    //      Call cmake to create the Makefile.  Call make -j to build the executable.
    //      Run the code so far to check that the libCellML versions match.

</literal_block>
                        </container>
                    </container>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python instructions</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-0-1">
                        <container classes="dothis">
                            <paragraph><strong>1.a</strong> Use the importlib functionality to open the generated code file.</paragraph>
                        </container>
                        <container classes="dothis">
                            <paragraph><strong>1.b</strong> Load into a module.</paragraph>
                        </container>
                        <container classes="toggle">
                            <container classes="header">
                                <paragraph>Show Python snippet</paragraph>
                            </container>
                            <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorial5/solveGeneratedCode_completed.py" xml:space="preserve">    #  1.a
    #       Use the importlib functionality to open the generated code file.
    spec = importlib.util.spec_from_file_location('HodgkinHuxleyModel', 'HodgkinHuxleyModel.py')
    module = importlib.util.module_from_spec(spec)

    #  1.b
    #       Load into a module.
    sys.modules['HodgkinHuxleyModel'] = module
    spec.loader.exec_module(module)
    model = module

</literal_block>
                        </container>
                    </container>
                </container>
            </container>
        </section>
        <section ids="step-2-access-the-variables-in-the-generated-files" names="step\ 2:\ access\ the\ variables\ in\ the\ generated\ files">
            <title>Step 2: Access the variables in the generated files</title>
            <paragraph>Probably the best way to understand the contents of the generated files is o open them and look!
                The implementation file <literal classes="code">*.cpp</literal> has two types of items:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>information structures (in all-caps); and</paragraph>
                </list_item>
                <list_item>
                    <paragraph>access functions.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>It’s important to remember that in the generated code we don’t have the notion of separate components: they are listed here with the variables only in order to give the correct context to the variable names.</paragraph>
            <paragraph>“Variables” are anything which does not require integration as part of the solution, and could have types <literal classes="code">COMPUTED_CONSTANT</literal> (needs to be calculated but doesn’t need integration), <literal classes="code">CONSTANT</literal> (no calculation needed), or <literal classes="code">ALGEBRAIC</literal> (<strong>TODO</strong>) as defined in the <literal classes="code">VariableType</literal> enum.
                They are stored in an array of <literal classes="code">VariableInfoWithType</literal> structs called <literal classes="code">VARIABLE_INFO</literal> which is <literal classes="code">VARIABLE_COUNT</literal> long.</paragraph>
            <container classes="shortlist">
                <paragraph>The <literal classes="code">VariableInfoWithType</literal> contains:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>name,</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>units,</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>component, and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>VariableType.</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.a</strong> Get the number of variables and iterate through the <literal classes="code">VARIABLE_INFO</literal> structure to retrieve and print each variable’s information to the terminal.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorial5/solveGeneratedCode_completed.cpp" xml:space="preserve">    //  2.a
    //      Get the number of variables and iterate through the VARIABLE_INFO structure to
    //      retrieve and print each variable's information to the terminal.

    std::cout &lt;&lt; "VARIABLE_COUNT = " &lt;&lt; VARIABLE_COUNT &lt;&lt; std::endl;
    for (size_t v = 0; v &lt; VARIABLE_COUNT; ++v) {
        std::cout &lt;&lt; "Variable " &lt;&lt; v &lt;&lt; ": " &lt;&lt; std::endl;
        std::cout &lt;&lt; "  name = " &lt;&lt; VARIABLE_INFO[v].name &lt;&lt; std::endl;
        std::cout &lt;&lt; "  units = " &lt;&lt; VARIABLE_INFO[v].units &lt;&lt; std::endl;
        std::cout &lt;&lt; "  component = " &lt;&lt; VARIABLE_INFO[v].component &lt;&lt; std::endl;
        std::cout &lt;&lt; "  type = " &lt;&lt; VARIABLE_INFO[v].type &lt;&lt; std::endl;
    }

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorial5/solveGeneratedCode_completed.py" xml:space="preserve">    #  2.a
    #       Get the number of variables and iterate through the VARIABLE_INFO dict to
    #       retrieve and print each variable's information to the terminal.
    print('VARIABLE_COUNT = {}'.format(model.VARIABLE_COUNT))

    for v in range (0, model.VARIABLE_COUNT):
        print('Variable {}:'.format(v))
        print('  name = {}'.format(model.VARIABLE_INFO[v]['name']))
        print('  units = {}'.format(model.VARIABLE_INFO[v]['units']))
        print('  component = {}'.format(model.VARIABLE_INFO[v]['component']))
        print('  type = {}'.format(model.VARIABLE_INFO[v]['type']))
    print()

</literal_block>
            </container>
            <paragraph>“State variables” are those which need integration.
                They are stored in an array of <literal classes="code">VariableInfo</literal> structs called <literal classes="code">STATE_INFO</literal> which
                is <literal classes="code">STATE_COUNT</literal> long.</paragraph>
            <container classes="shortlist">
                <paragraph>The <literal classes="code">VariableInfo</literal> struct contains:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>name,</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>units, and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>component.</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.b</strong> Get the number of state variables and iterate through the <literal classes="code">STATE_INFO</literal> structure to retrieve and print each state variable’s information to the terminal.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorial5/solveGeneratedCode_completed.cpp" xml:space="preserve">    //  2.b
    //      Get the number of state variables and iterate through the STATE_INFO structure to
    //      retrieve and print each state variable's information to the terminal.
    std::cout &lt;&lt; std::endl;
    std::cout &lt;&lt; "STATE_COUNT = " &lt;&lt; STATE_COUNT &lt;&lt; std::endl;
    for (size_t s = 0; s &lt; STATE_COUNT; ++s) {
        std::cout &lt;&lt; "State variable " &lt;&lt; s &lt;&lt; ": " &lt;&lt; std::endl;
        std::cout &lt;&lt; "  name = " &lt;&lt; STATE_INFO[s].name &lt;&lt; std::endl;
        std::cout &lt;&lt; "  units = " &lt;&lt; STATE_INFO[s].units &lt;&lt; std::endl;
        std::cout &lt;&lt; "  component = " &lt;&lt; STATE_INFO[s].component &lt;&lt; std::endl;
    }

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorial5/solveGeneratedCode_completed.py" xml:space="preserve">    #  2.b
    #       Get the number of state variables and iterate through the STATE_INFO dict to
    #       retrieve and print each state variable's information to the terminal.
    print('STATE_COUNT = {}'.format(model.STATE_COUNT))
    for s in range(0, model.STATE_COUNT):
        print('State variable {}:'.format(s))
        print('  name = {}'.format(model.STATE_INFO[s]['name']))
        print('  units = {}'.format(model.STATE_INFO[s]['units']))
        print('  component = {}'.format(model.STATE_INFO[s]['component']))
    print()

</literal_block>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.c</strong> Get the integration variable and print its information to the terminal.
                    This is stored in a <literal classes="code">VariableInfo</literal> struct called <literal classes="code">VOI_INFO</literal>.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorial5/solveGeneratedCode_completed.cpp" xml:space="preserve">    //  2.c 
    //      Get the integration variable and print its information to the terminal. This
    //      is stored in a VariableInfo struct called VOI_INFO.
    std::cout &lt;&lt; std::endl;
    std::cout &lt;&lt; "VOI_INFO" &lt;&lt; std::endl;
    std::cout &lt;&lt; "  name = " &lt;&lt; VOI_INFO.name &lt;&lt; std::endl;
    std::cout &lt;&lt; "  units = " &lt;&lt; VOI_INFO.units &lt;&lt; std::endl;
    std::cout &lt;&lt; "  component = " &lt;&lt; VOI_INFO.component &lt;&lt; std::endl;
    std::cout &lt;&lt; std::endl;

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorial5/solveGeneratedCode_completed.py" xml:space="preserve">    #  2.c 
    #       Get the integration variable and print its information to the terminal. This
    #       is stored in a dict called VOI_INFO.
    print('VOI_INFO')
    print('  name = {}'.format(model.VOI_INFO['name']))
    print('  units = {}'.format(model.VOI_INFO['units']))
    print('  component = {}'.format(model.VOI_INFO['component']))
    print()

</literal_block>
            </container>
        </section>
        <section ids="step-3-access-the-functions-in-the-generated-files" names="step\ 3:\ access\ the\ functions\ in\ the\ generated\ files">
            <title>Step 3: Access the functions in the generated files</title>
            <container classes="sphinx-tabs">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-1-0 active">
                        <paragraph>The generated code contains seven functions:</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph><literal classes="code">createStatesArray()</literal> to allocate an array of length <literal classes="code">STATE_COUNT</literal>.
                                    This can be used to allocate the “rates” or gradient function array too as they’re the same length;</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">createVariablesArray()</literal> to allocate an array of length <literal classes="code">VARIABLE_COUNT</literal>;</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">deleteArray()</literal> to free memory used by the given array;</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">initialiseStatesAndConstants(states, variables)</literal> will do what it says on the tin, and populate the given pre-allocated arrays with the initial values for all of the model’s state variables and constants.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">computeComputedConstants(variables)</literal> will fill in values for any variables that do not change in value throughout the solution, but still need to be calculated;</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">computeRates(VOI, states, rates, variables)</literal> updates the rates array with the gradients of the state variables, given the values of the other variables and the variable of integration (VOI);</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">computeVariables(VOI, states, rates, variables)</literal> updates any non-integrated variables whose values do not affect the integration.
                                    Since this doesn’t affect the solution process it only needs to be called whenever the values need to be output; not necessarily each integration timestep.</paragraph>
                            </list_item>
                        </bullet_list>
                    </container>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-1-1">
                        <paragraph>The generated code contains seven functions:</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph><literal classes="code">create_states_array()</literal> to allocate an array of length <literal classes="code">STATE_COUNT</literal>.
                                    This can be used to allocate the “rates” or gradient function array too as they’re the same length;</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">create_variables_array()</literal> to allocate an array of length <literal classes="code">VARIABLE_COUNT</literal>;</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">delete_array()</literal> to free memory used by the given array;</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">initialise_states_and_constants(states, variables)</literal> will do what it says on the tin, and populate the given pre-allocated arrays with the initial values for all of the model’s state variables and constants.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">compute_computed_constants(variables)</literal> will fill in values for any variables that do not change in value throughout the solution, but still need to be calculated;</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">compute_rates(VOI, states, rates, variables)</literal> updates the rates array with the gradients of the state variables, given the values of the other variables and the variable of integration (VOI);</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal classes="code">compute_variables(VOI, states, rates, variables)</literal> updates any non-integrated variables whose values do not affect the integration.
                                    Since this doesn’t affect the solution process it only needs to be called whenever the values need to be output; not necessarily each integration timestep.</paragraph>
                            </list_item>
                        </bullet_list>
                    </container>
                </container>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.a</strong> Create three arrays representing:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>the variables (which here includes constants);</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>the states (the integrated variables); and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>the rates.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Create and initialise a variable of integration, time.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorial5/solveGeneratedCode_completed.cpp" xml:space="preserve">    //  3.a 
    //      Create three arrays and use the functions to allocate them, representing
    //      - variables,
    //      - rates
    //      - states.
    //      Create a variable of integration and set it to 0.
    auto myVariables = createVariablesArray();
    auto myStateVariables = createStatesArray();
    auto myRates = createStatesArray();
    double time = 0;

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorial5/solveGeneratedCode_completed.py" xml:space="preserve">    #  3.a 
    #       Create three arrays representing:
    #       - the variables (which here includes constants)
    #       - the states (the integrated variables)
    #       - the rates 
    #       Create and initialise a variable of integration, time.
    my_variables = model.create_variables_array()
    my_state_variables = model.create_states_array()
    my_rates = model.create_states_array()
    time = 0.0

</literal_block>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.b</strong> Use the functions provided to initialise the states array you created, then print them to the screen for checking.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorial5/solveGeneratedCode_completed.cpp" xml:space="preserve">    //  3.b 
    //      Use the functions provided to initialise the arrays you created, then print them 
    //      to the screen for checking.
    initialiseStatesAndConstants(myStateVariables, myVariables);

    std::cout &lt;&lt; "The initial conditions for state variables are:" &lt;&lt; std::endl;
    for (size_t v = 0; v &lt; STATE_COUNT; ++v) {
        std::cout &lt;&lt; "  " &lt;&lt; STATE_INFO[v].component &lt;&lt; " " &lt;&lt; STATE_INFO[v].name &lt;&lt; "  = " &lt;&lt; myStateVariables[v] &lt;&lt; " (" &lt;&lt; STATE_INFO[v].units &lt;&lt; ")"&lt;&lt; std::endl;
    }
    std::cout &lt;&lt; std::endl;

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorial5/solveGeneratedCode_completed.py" xml:space="preserve">    #  3.b 
    #       Use the functions provided to initialise the arrays you created, then print them 
    #       to the screen for checking.
    model.initialise_states_and_constants(my_state_variables, my_variables)
    print('The initial conditions for state variables are:')
    for v in range(0, model.STATE_COUNT):
        print('{} {} = {} ({})'.format(
            model.STATE_INFO[v]['component'],
            model.STATE_INFO[v]['name'],
            my_state_variables[v],
            model.STATE_INFO[v]['units']
            ))
    print()

</literal_block>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.c</strong> Compute the constants, compute the variables, and print them to the screen for checking.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorial5/solveGeneratedCode_completed.cpp" xml:space="preserve">    //  3.c 
    //      Compute the constants, compute the variables, and print them to the screen for checking.
    computeComputedConstants(myVariables);
    computeVariables(time, myStateVariables, myRates, myVariables);
    std::cout &lt;&lt; "The initial values including all computed constants are:" &lt;&lt; std::endl;
    for (size_t v = 0; v &lt; VARIABLE_COUNT; ++v) {
        std::cout &lt;&lt; "  " &lt;&lt; VARIABLE_INFO[v].name &lt;&lt; " = " &lt;&lt; myVariables[v] &lt;&lt; " (" &lt;&lt; VARIABLE_INFO[v].units &lt;&lt; ")"&lt;&lt;std::endl;
    }
    std::cout &lt;&lt; std::endl;

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorial5/solveGeneratedCode_completed.py" xml:space="preserve">    #  3.c 
    #       Compute the constants, compute the variables,  and print them to the screen for checking.
    print('The initial values including all computed constants are:')
    model.compute_computed_constants(my_variables)
    model.compute_variables(time, my_state_variables, my_rates, my_variables)
    for v in range(0, model.VARIABLE_COUNT):
        print('  {} = {} ({})'.format(
            model.VARIABLE_INFO[v]['name'],
            my_variables[v],
            model.VARIABLE_INFO[v]['units']
            ))
    print()

</literal_block>
            </container>
        </section>
        <section ids="step-4-iterate-through-the-solution" names="step\ 4:\ iterate\ through\ the\ solution">
            <title>Step 4: Iterate through the solution</title>
            <paragraph>This part will make use of a simple routine to step through the solution iterations using the Euler method to update the state variables.</paragraph>
            <container classes="dothis">
                <paragraph><strong>4.a</strong> Create variables which control how the solution will run, representing:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>step size; and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>the number of steps to take.</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorial5/solveGeneratedCode_completed.cpp" xml:space="preserve">    //  4.a 
    //      Create variables which control how the solution will run, representing:
    //      - variable of integration (time);
    //      - step size; and
    //      - the number of steps to take.
    double stepSize = 0.01;
    int stepCount = 2000;
    int incr = (int)(stepCount/60) + 1;

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorial5/solveGeneratedCode_completed.py" xml:space="preserve">    #  4.a 
    #       Create variables which control how the solution will run, representing:
    #       - step size and
    #       - the number of steps to take.
    step_size = 0.01
    step_count = 2000
    incr = int(step_count/60) + 1

</literal_block>
            </container>
            <container classes="dothis">
                <paragraph><strong>4.b</strong> Create a file for output and open it.
                    You can use the information to name columns with the variables, component, and units so you can keep track later.</paragraph>
            </container>
            <paragraph>The Euler update method is: <math>x[n+1] = x[n] + x'[n].dx</math></paragraph>
            <container classes="shortlist">
                <definition_list>
                    <definition_list_item>
                        <term>At each step you will need to:</term>
                        <definition>
                            <bullet_list bullet="-">
                                <list_item>
                                    <paragraph>Compute the rates;</paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph>Compute the state variables using the update method above;</paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph>Compute the variables; **</paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph>Print to a file.</paragraph>
                                </list_item>
                            </bullet_list>
                        </definition>
                    </definition_list_item>
                </definition_list>
                <paragraph>** We only need to compute these each timestep here because we’re also writing the values to the file at each timestep.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorial5/solveGeneratedCode_completed.cpp" xml:space="preserve">    //  4.b 
    //      Create a file for output and open it. You can use the information to name columns
    //      with the variables, component, and units so you can keep track later.
    std::ofstream outFile("HodgkinHuxleyModelSolution.txt");
    outFile &lt;&lt; "iteration";
    outFile &lt;&lt; "\t" &lt;&lt; VOI_INFO.name &lt;&lt; " (" &lt;&lt; VOI_INFO.units &lt;&lt; ")";
    for (size_t v = 0; v &lt; VARIABLE_COUNT; ++v) {
        outFile &lt;&lt; "\t" &lt;&lt; VARIABLE_INFO[v].component&lt;&lt;":"&lt;&lt;VARIABLE_INFO[v].name &lt;&lt; " (" &lt;&lt; VARIABLE_INFO[v].units &lt;&lt; ")";
    }
    for (size_t s = 0; s &lt; STATE_COUNT; ++s) {
        outFile &lt;&lt; "\t" &lt;&lt; STATE_INFO[s].component&lt;&lt;":"&lt;&lt;STATE_INFO[s].name &lt;&lt; " (" &lt;&lt; STATE_INFO[s].units &lt;&lt; ")";
    }
    outFile &lt;&lt; std::endl;
   
</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorial5/solveGeneratedCode_completed.py" xml:space="preserve">    #  4.b Create a file for output and open it. You can use the information to name columns
    #      with the variables, component, and units so you can keep track later.
    write_file = open('HodgkinHuxleyModelSolution.txt', 'w')
    row = 'iteration\t{}({})'.format(
        model.VOI_INFO['name'], model.VOI_INFO['units'])
    for s in range(0, model.STATE_COUNT):
        row += '\t{}({})'.format(model.STATE_INFO[s]
                                 ['name'], model.STATE_INFO[s]['units'])
    for s in range(0, model.VARIABLE_COUNT):
        row += '\t{}({})'.format(model.VARIABLE_INFO[s]
                                 ['name'], model.VARIABLE_INFO[s]['units'])
    row += '\n'
    write_file.write(row)

</literal_block>
            </container>
            <container classes="dothis">
                <paragraph><strong>4.c</strong> Iterate through the time domain, calculate and write the solution at each step.</paragraph>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show C++ snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorial5/solveGeneratedCode_completed.cpp" xml:space="preserve">    //  4.c
    //      Iterate through the time domain and write the solution at each step. 
    for (size_t step = 0; step &lt; stepCount; ++step) {
        time = step * stepSize;

        // Compute the rates at this step using the given function.
        computeRates(time, myStateVariables, myRates, myVariables);
        
        // Compute the solution at the next step using whatever numerical integration 
        // method you choose. In this example we've used Euler, as given above.
        for (size_t s = 0; s &lt; STATE_COUNT; ++s) {
            myStateVariables[s] = myStateVariables[s] + myRates[s] * stepSize;
        }

        // Compute the variables at this step using the given function.
        computeVariables(time, myStateVariables, myRates, myVariables);

        // Write everything to the output file.  Keep the order of columns consistent with
        // whatever you've used in step 4.c.
        outFile &lt;&lt; step &lt;&lt; "\t " &lt;&lt; time;
        for(size_t v = 0; v &lt; VARIABLE_COUNT; ++v) {
            outFile &lt;&lt; "\t " &lt;&lt; myVariables[v];
        }
        for (size_t s = 0; s &lt; STATE_COUNT; ++s) {
            outFile &lt;&lt; "\t" &lt;&lt; myStateVariables[s];
        }
        outFile &lt;&lt; "\n";
        if(step % incr == 0) {
            std::cout &lt;&lt; "." &lt;&lt; std::flush;
        }
    }
    std::cout &lt;&lt; std::endl &lt;&lt; "Finished!" &lt;&lt; std::endl;
    outFile.close();

</literal_block>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show Python snippet</paragraph>
                </container>
                <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/hh_tutorial5/solveGeneratedCode_completed.py" xml:space="preserve">    #  4.c 
    #      Iterate through the time domain and write the solution at each step. 
    for step in range(0, step_count):
        time = step * step_size

        # Compute the rates at this step using the given function.
        model.compute_rates(time, my_state_variables, my_rates, my_variables)

        row = '{}\t{}'.format(step, time)

        # Compute the states.
        for s in range(0, model.STATE_COUNT):
            my_state_variables[s] = my_state_variables[s] + my_rates[s] * step_size
            row += '\t{}'.format(my_state_variables[s])

        # Compute the variables.
        model.compute_variables(time, my_state_variables, my_rates, my_variables)
        for s in range(0, model.VARIABLE_COUNT):
            row += '\t{}'.format(my_variables[s])

        row += '\n'
        # Write to file.
        write_file.write(row)

        # Print progress bar.
        if step % incr == 0:
            print('.', end='', flush=True)

    write_file.close()
   
</literal_block>
            </container>
        </section>
        <section ids="step-5-sanity-check" names="step\ 5:\ sanity\ check">
            <title>Step 5: Sanity check</title>
            <paragraph>The file that results from running the completed version of this tutorial can be downloaded from <download_reference filename="c3dd6396afe5daaf976b97c08651b82e/HodgkinHuxleyModelSolution.txt" refdoc="tutorials/hh_tutorial5/index" refdomain="" refexplicit="True" reftarget="HodgkinHuxleyModelSolution.txt" reftype="download" refwarn="False"><literal classes="xref download">HodgkinHuxleyModelSolution.txt</literal></download_reference>, and is a tab-delimited file that can be easily read into your favourite plotting program.</paragraph>
        </section>
    </section>
</document>
