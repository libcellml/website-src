<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.16 -->
<document source="/Users/kmoy001/libcellml/libcellml-tutorials/asides/aside_constant_vs_variable.rst">
    <target refid="aside-constant-vs-variable"></target>
    <section ids="constants-vs-variables aside-constant-vs-variable" names="constants\ vs\ variables aside_constant_vs_variable">
        <title>Constants vs Variables</title>
        <paragraph>In your model, there is mathematics.
            And in your mathematics, there are variables.
            Some of these variables will, well, <emphasis>vary</emphasis> in value, but others might not.
            This note is to help you understand the different ways in which <literal classes="code">variable</literal> elements are assigned value, and what it means to your whole model’s interpretation.</paragraph>
        <paragraph>There are six ways to assign a value to a <literal classes="code">variable</literal> element:</paragraph>
        <section ids="assign-to-a-number-in-a-math-block" names="1.\ assign\ to\ a\ number\ in\ a\ math\ block">
            <title>1. Assign to a number in a math block</title>
            <paragraph>These are classed as “eternal truths”, and are statements which are held to be true throughout the entirety of the simulation.
                If you use a <literal classes="code">math</literal> block statement to assign value to a <literal classes="code">variable</literal> element using a hard-coded numerical value, then that value can <strong>never</strong> be changed.
                Any attempt to change it will make the model over-defined.
                In the example below, <literal classes="code">A</literal> is a constant with value 1 for the entire simulation.</paragraph>
            <container classes="sphinx-tabs">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                    </container>
                    <literal_block force="False" highlight_args="{}" language="c++" linenos="False" xml:space="preserve">// Setting A = 1 using a math block:
std::string myMathString = "&lt;math&gt;&lt;apply&gt;&lt;eq/&gt;&lt;ci&gt;A&lt;/ci&gt;&lt;cn cellml:units=\"dimensionless\"&gt;1&lt;/ci&gt;&lt;/apply&gt;&lt;/math&gt;";
myComponent-&gt;appendMath(myMathString);</literal_block>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                    </container>
                    <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Setting A = 1 using a math block:
my_math_string = '&lt;math&gt;&lt;apply&gt;&lt;eq/&gt;&lt;ci&gt;A&lt;/ci&gt;&lt;cn cellml:units="dimensionless"&gt;1&lt;/ci&gt;&lt;/apply&gt;&lt;/math&gt;'
my_component.appendMath(my_math_string)</literal_block>
                </container>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show CellML</paragraph>
                </container>
                <literal_block force="False" highlight_args="{}" language="xml" linenos="False" xml:space="preserve">&lt;math&gt;
  &lt;apply&gt;&lt;eq/&gt;
    &lt;ci&gt;A&lt;/ci&gt;
    &lt;cn cellml:units="dimensionless"&gt;1&lt;/cn&gt;
  &lt;/apply&gt;
&lt;/math&gt;</literal_block>
            </container>
        </section>
        <section ids="assign-to-another-variable-or-expression-in-a-math-block" names="2.\ assign\ to\ another\ variable\ or\ expression\ in\ a\ math\ block">
            <title>2. Assign to another variable or expression in a math block</title>
            <paragraph>As above, these are classed as “eternal truths”, but of course the actual value held by the variables may change as the expression is evaluated at different times.
                The <literal classes="code">math</literal> statements are not <emphasis>assignments</emphasis> (as you’d expect in a programming language), but rather <emphasis>equations</emphasis> (as you’d expect in mathematics).
                This means that writing <math>B = C</math> is equivalent to writing <math>C = B</math>, just as it is in normal mathematics, and can be read “The value of B is always the same as the value of C”.
                Compare that to the assignment statement we’re familiar with in programming, <literal classes="code">B := C</literal> (“set the value of B to be the current value of C”) which is <emphasis>not</emphasis> the same as <literal classes="code">C := B</literal> (“set the value of C to be the current value of B”).
                Of course <math>B = C</math> is perhaps the simplest equation possible, and yours will be a lot more complicated than this!</paragraph>
            <container classes="sphinx-tabs">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                    </container>
                    <literal_block force="False" highlight_args="{}" language="c++" linenos="False" xml:space="preserve">// Setting B = C using a math block:
std::string myMathString = "&lt;math&gt;&lt;apply&gt;&lt;eq/&gt;&lt;ci&gt;B&lt;/ci&gt;&lt;ci&gt;C&lt;/ci&gt;&lt;/apply&gt;&lt;/math&gt;";
myComponent-&gt;appendMath(myMathString);</literal_block>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                    </container>
                    <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Setting B = C using a math block:
my_math_string = '&lt;math&gt;&lt;apply&gt;&lt;eq/&gt;&lt;ci&gt;B&lt;/ci&gt;&lt;ci&gt;C&lt;/ci&gt;&lt;/apply&gt;&lt;/math&gt;'
my_component.appendMath(my_math_string)</literal_block>
                </container>
            </container>
        </section>
        <section ids="assign-as-an-initial-value-attribute" names="3.\ assign\ as\ an\ initial\ value\ attribute">
            <title>3. Assign as an initial value attribute</title>
            <paragraph>The term “initial value” might lead you to believe that the <literal classes="code">initial_value</literal> attributes are only used for variables of integration.
                In reality, <emphasis>any</emphasis> variable which will have a non-constant value during the simulation <emphasis>may</emphasis> be set using this attribute.
                This includes values which are changed by resets, or by solving a differential or algebraic equation.
                The only situation where you don’t need to set a variable’s value like this is where the variable is defined by evaluation of a <literal classes="code">math</literal> block statement.
                In that situation, having an initial value specified as well as a maths definition will make the model over-defined.</paragraph>
            <container classes="sphinx-tabs">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                    </container>
                    <literal_block force="False" highlight_args="{}" language="c++" linenos="False" xml:space="preserve">// Setting the initial value of B:
myComponent-&gt;variable("B")-&gt;setInitialValue(1);

// Setting B = C using a math block:
std::string myMathString = "&lt;math&gt;&lt;apply&gt;&lt;eq/&gt;&lt;ci&gt;B&lt;/ci&gt;&lt;ci&gt;C&lt;/ci&gt;&lt;/apply&gt;&lt;/math&gt;";
myComponent-&gt;appendMath(myMathString);</literal_block>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                    </container>
                    <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Setting the initial value of B:
my_component-&gt;variable('B')-&gt;setInitialValue(1)

# Setting B = C using a math block:
my_math_string = '&lt;math&gt;&lt;apply&gt;&lt;eq/&gt;&lt;ci&gt;B&lt;/ci&gt;&lt;ci&gt;C&lt;/ci&gt;&lt;/apply&gt;&lt;/math&gt;'
my_component.appendMath(my_math_string)</literal_block>
                </container>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show CellML</paragraph>
                </container>
                <literal_block force="False" highlight_args="{}" language="xml" linenos="False" xml:space="preserve">&lt;!-- The variable B can change in value during the simulation. --&gt;
&lt;variable name="B" initial_value="1" units="dimensionless" /&gt;

&lt;!-- The variable C does not use initialisation, as it is
    constrained by the maths below to always have the same
    value as B, which has been initialised. --&gt;
&lt;variable name="C" units="dimensionless" /&gt;
&lt;math&gt;
  &lt;apply&gt;&lt;eq/&gt;
    &lt;ci&gt;B&lt;/ci&gt;
    &lt;ci&gt;C&lt;/ci&gt;
  &lt;/apply&gt;
&lt;/math&gt;

&lt;!-- The statement above is an equation, not an assignment,
    so is equivalent to: --&gt;
&lt;math&gt;
  &lt;apply&gt;&lt;eq/&gt;
    &lt;ci&gt;C&lt;/ci&gt;
    &lt;ci&gt;B&lt;/ci&gt;
  &lt;/apply&gt;
&lt;/math&gt;</literal_block>
            </container>
        </section>
        <section ids="assign-by-solving-a-differential-equation" names="4.\ assign\ by\ solving\ a\ differential\ equation">
            <title>4. Assign by solving a differential equation</title>
            <paragraph>This is similar to point 2 above, in that the variable’s definition is contained within a mathematical statement.
                The difference is that when a <literal classes="code">variable</literal> element is a state variable (ie: the numerator of a differential equation), it <emphasis>must</emphasis> have a value which is specified (either locally or somewhere in its equivalent variable set) by an <literal classes="code">initial_value</literal> attribute.</paragraph>
            <container classes="sphinx-tabs">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-Qysr active">
                    </container>
                    <literal_block force="False" highlight_args="{}" language="c++" linenos="False" xml:space="preserve">// Setting the initial value of E:
myComponent-&gt;variable("E")-&gt;setInitialValue(3);

// Solving for E using a differential equation:
std::string myDifferentialEquation = "&lt;math&gt;\n"
  "  &lt;apply&gt;&lt;eq/&gt;\n"
  "    &lt;diff&gt;\n"
  "      &lt;ci&gt;E&lt;/ci&gt;\n"
  "      &lt;bvar&gt;t&lt;/bvar&gt;\n"
  "    &lt;/diff&gt;\n"
  "    &lt;cn cellml:units=\"dimensionless\"&gt;1&lt;/cn&gt;\n"
  "  &lt;/apply&gt;\n"
  "&lt;/math&gt;";
myComponent-&gt;appendMath(myDifferentialEquation);</literal_block>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment code-tab sphinx-data-tab-UHl0aG9u">
                    </container>
                    <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Setting the initial value of E:
my_component-&gt;variable('E')-&gt;setInitialValue(3)

# Solving for E using a differential equation:
my_differential_equation = '&lt;math&gt;\n'
  '  &lt;apply&gt;&lt;eq/&gt;\n'
  '    &lt;diff&gt;\n'
  '      &lt;ci&gt;E&lt;/ci&gt;\n'
  '      &lt;bvar&gt;t&lt;/bvar&gt;\n'
  '    &lt;/diff&gt;\n'
  '    &lt;cn cellml:units="dimensionless"&gt;1&lt;/cn&gt;\n'
  '  &lt;/apply&gt;\n'
  '&lt;/math&gt;'
my_component.appendMath(my_math_string)</literal_block>
                </container>
            </container>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Show CellML</paragraph>
                </container>
                <literal_block force="False" highlight_args="{}" language="xml" linenos="False" xml:space="preserve">&lt;!-- A state variable must have an initial value specified.
      Note that this could be applied to a connected variable in another component. --&gt;
&lt;variable name="E" units="dimensionless" initial_value="3" /&gt;
&lt;math&gt;
  &lt;apply&gt;&lt;eq/&gt;
    &lt;diff&gt;
      &lt;ci&gt;E&lt;/ci&gt;
      &lt;bvar&gt;t&lt;/bvar&gt;
    &lt;/diff&gt;
    &lt;cn cellml:units="dimensionless"&gt;1&lt;/cn&gt;
  &lt;/apply&gt;
&lt;/math&gt;</literal_block>
            </container>
        </section>
        <section ids="assign-by-applying-a-reset" names="5.\ assign\ by\ applying\ a\ reset">
            <title>5. Assign by applying a reset</title>
            <paragraph>Resets allow a variable to have prescribed discontinuity in value at some stage in the simulation process.
                This means that the value of the variable must be allowed to change (that is, it must not appear in a statement like in point 1 above).
                In contrast to the mathematical <emphasis>equations</emphasis> defined inside <literal classes="code">math</literal> elements, the MathML statements within a reset’s <literal classes="code">reset_value</literal> block is an <emphasis>assignment</emphasis>.
                By their nature, the mathematics of resets are only temporarily true, and so anything written there is a one-off assignment when the reset item is active.
                This means that even though the reset variable’s value can’t be defined as a constant (as in point 1), it could still be part of an equation (as in point 2).
                It must not be a variable of integration (as in point 4) or a base variable (as in point 6).</paragraph>
        </section>
        <section ids="assign-as-a-variable-of-integration" names="6.\ assign\ as\ a\ variable\ of\ integration">
            <title>6. Assign as a variable of integration</title>
            <paragraph>These don’t need to be given a value inside CellML as their value will be set during the simulation.</paragraph>
        </section>
    </section>
</document>
