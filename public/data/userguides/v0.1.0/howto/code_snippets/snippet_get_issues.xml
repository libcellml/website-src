<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.16 -->
<document source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code_snippets/snippet_get_issues.rst">
    <target refid="snippet-get-issues"></target>
    <container classes="toggle" ids="snippet-get-issues" names="snippet_get_issues">
        <container classes="header-left">
            <paragraph>Utility functions to retrieve issues</paragraph>
        </container>
        <container classes="sphinx-tabs">
            <container>
                <container classes="item">
                    <container>
                        <paragraph>C++</paragraph>
                    </container>
                </container>
                <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-0-0 active">
                    <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/utilities/utilities.cpp" xml:space="preserve">void printIssues(const libcellml::LoggerPtr &amp;item) {

    // Get the number of issues attached to the logger item.  Note that this will 
    // return issues of all levels.  To retrieve the total number of a specific level
    // of issues, use the errorCount(), warningCount(), hintCount(), or messageCount() functions. 
    size_t num = item-&gt;issueCount();
    std::cout &lt;&lt; "Recorded " &lt;&lt; num &lt;&lt; " issues";

    if (num != 0) {
        std::cout &lt;&lt; ":" &lt;&lt; std::endl;
        for (size_t i = 0; i &lt; num; ++i) {

            // Retrieve the issue at index i.  Note that this is agnostic as to the level of issue.
            // Specific issue levels can be retrieved using the functions item-&gt;error(i), item-&gt;warning(i) 
            // etc, where the index must be within appropriate limits.
            libcellml::IssuePtr issue = item-&gt;issue(i);

            // Issues created by the Validator class contain a reference heading number, which indicates
            // the section reference within the normative specification relevant to the issue.
            std::string errorReference = issue-&gt;referenceHeading();

            // The level of an issue is retrieved using the level() function as an enum value.  
            std::cout &lt;&lt; "Issue " &lt;&lt; i &lt;&lt; " is " &lt;&lt; getIssueLevelFromEnum(issue-&gt;level()) &lt;&lt; ":" &lt;&lt; std::endl;

            // Each issue has a descriptive text field, accessible through the description() function.
            std::cout &lt;&lt; "    description: " &lt;&lt; issue-&gt;description() &lt;&lt; std::endl;
            if (errorReference != "") {
                std::cout &lt;&lt; "    see section " &lt;&lt; errorReference
                          &lt;&lt; " in the CellML specification." &lt;&lt; std::endl;
            }

            // An optional URL is given for some issues which directs the user to more detailed information.
            if(!issue-&gt;url().empty()){
                std::cout &lt;&lt; "    more information at: " &lt;&lt;issue-&gt;url() &lt;&lt; std::endl;
            }

            // Each issue is associated with an item.  In order to properly deal with the item stored, its type is 
            // recorded too in an enumeration.
            std::cout &lt;&lt; "    stored item type: " &lt;&lt; getCellmlElementTypeFromEnum(issue-&gt;cellmlElementType()) &lt;&lt; std::endl;
        }
        std::cout &lt;&lt; std::endl &lt;&lt; std::endl;
    }
    else {
        std::cout &lt;&lt; "!" &lt;&lt; std::endl &lt;&lt; std::endl;
    }
}
</literal_block>
                    <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/utilities/utilities.cpp" xml:space="preserve">std::map&lt;libcellml::CellmlElementType, std::string&gt; itemTypeToString = 
    {{libcellml::CellmlElementType::COMPONENT, "COMPONENT"},
    {libcellml::CellmlElementType::COMPONENT_REF, "COMPONENT_REF"},
    {libcellml::CellmlElementType::CONNECTION, "CONNECTION"},
    {libcellml::CellmlElementType::ENCAPSULATION, "ENCAPSULATION" },
    {libcellml::CellmlElementType::IMPORT, "IMPORT"},
    {libcellml::CellmlElementType::MAP_VARIABLES, "MAP_VARIABLES"},
    {libcellml::CellmlElementType::MATH, "MATH"},
    {libcellml::CellmlElementType::MODEL, "MODEL"},
    {libcellml::CellmlElementType::RESET, "RESET"},
    {libcellml::CellmlElementType::RESET_VALUE, "RESET_VALUE"},
    {libcellml::CellmlElementType::TEST_VALUE, "TEST_VALUE"},
    {libcellml::CellmlElementType::UNDEFINED, "UNDEFINED"},
    {libcellml::CellmlElementType::UNIT, "UNIT"},
    {libcellml::CellmlElementType::UNITS, "UNITS"}, 
    {libcellml::CellmlElementType::VARIABLE, "VARIABLE"}};

std::string getCellmlElementTypeFromEnum(libcellml::CellmlElementType t) {
    return itemTypeToString.at(t);
}
</literal_block>
                    <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/utilities/utilities.cpp" xml:space="preserve">std::string getIssueLevelFromEnum(libcellml::Issue::Level myLevel)
{
    std::string myTypeAsString = "dunno";

    switch (myLevel) {
    case libcellml::Issue::Level::ERROR:
        myTypeAsString = "an ERROR";
        break;
    case libcellml::Issue::Level::WARNING:
        myTypeAsString = "a WARNING";
        break;
    case libcellml::Issue::Level::HINT:
        myTypeAsString = "a HINT";
        break;
    case libcellml::Issue::Level::MESSAGE:
        myTypeAsString = "a MESSAGE";
        break;
    }
    return myTypeAsString;
}
</literal_block>
                    <paragraph>Full context: <download_reference filename="1cdb9663c0a4a27bb109437f2a9ceacf/utilities.cpp" refdoc="howto/code_snippets/snippet_get_issues" refdomain="" refexplicit="True" reftarget="../../tutorials/utilities/utilities.cpp" reftype="download" refwarn="False"><literal classes="xref download">utilities.cpp</literal></download_reference></paragraph>
                </container>
            </container>
            <container>
                <container classes="item">
                    <container>
                        <paragraph>Python</paragraph>
                    </container>
                </container>
                <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-0-1">
                    <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/utilities/utilities.py" xml:space="preserve">def print_issues(item):

    # Get the number of issues attached to the logger item.  Note that this will 
    # return issues of all levels.  To retrieve the total number of a specific level
    # of issues, use the errorCount(), warningCount(), hintCount(), or messageCount() functions. 
    number_of_issues = item.issueCount()

    if number_of_issues != 0:
        print("\nThe {t} has found {n} issues:".format(
            t=type(item).__name__,
            n=number_of_issues)
        )

        for e in range(0, number_of_issues):

            # Retrieve the issue at index i.  Note that this is agnostic as to the level of issue.
            # Specific issue levels can be retrieved using the functions item.error(e), item.warning(e) 
            # etc, where the index must be within appropriate limits.
            i = item.issue(e)

            # The level of an issue is retrieved using the level() function as an enum value. 
            level = i.level()
            print("  {l}[{e}]:".format(
                l=level_as_string[level],
                e=e))

            # Each issue has a descriptive text field, accessible through the description() function.
            print("    Description: {d}".format(
                d=i.description()))

            # Issues created by the Validator class contain a reference heading number, which indicates
            # the section reference within the normative specification relevant to the issue.
            specification = i.referenceHeading()
            if specification != "":
                print("    See section {s} in the CellML specification.".format(
                    s=specification))

            # An optional URL is given for some issues which directs the user to more detailed information.
            url = i.url()
            if url != "":
                print("    More information is available at {url}".format(
                    url=url))

            # Each issue is associated with an item.  In order to properly deal with the item stored, its type is 
            # recorded too in an enumeration.
            print("    Stored item type: {}".format(get_cellml_element_type_from_enum(i.cellmlElementType())))

    else:
        print("\nThe {t} has not found any issues!".format(
            t=type(item).__name__)
        )
</literal_block>
                    <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/utilities/utilities.py" xml:space="preserve">def get_cellml_element_type_from_enum(my_cause):

    my_type_as_string = "dunno"

    if my_cause == CellmlElementType.COMPONENT:
        my_type_as_string = "COMPONENT"

    elif my_cause == CellmlElementType.COMPONENT_REF:
        my_type_as_string = "COMPONENT_REf"

    elif my_cause == CellmlElementType.CONNECTION:
        my_type_as_string = "CONNECTION"

    elif my_cause == CellmlElementType.ENCAPSULATION:
        my_type_as_string = "ENCAPSULATION"

    elif my_cause == CellmlElementType.IMPORT:
        my_type_as_string = "IMPORT"

    elif my_cause == CellmlElementType.MATH:
        my_type_as_string = "MATH"

    elif my_cause == CellmlElementType.MAP_VARIABLES:
        my_type_as_string = "MAP_VARIABLES"

    elif my_cause == CellmlElementType.MODEL:
        my_type_as_string = "MODEL"

    elif my_cause == CellmlElementType.RESET:
        my_type_as_string = "RESET"

    elif my_cause == CellmlElementType.RESET_VALUE:
        my_type_as_string = "RESET_VALUE"

    elif my_cause == CellmlElementType.TEST_VALUE:
        my_type_as_string = "TEST_VALUE"

    elif my_cause == CellmlElementType.UNDEFINED:
        my_type_as_string = "UNDEFINED"

    elif my_cause == CellmlElementType.UNIT:
        my_type_as_string = "UNIT"

    elif my_cause == CellmlElementType.UNITS:
        my_type_as_string = "UNITS"

    elif my_cause == CellmlElementType.VARIABLE:
        my_type_as_string = "VARIABLE"

    return my_type_as_string
</literal_block>
                    <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/utilities/utilities.py" xml:space="preserve">def get_issue_level_from_enum(my_level):

    my_type_as_string = "dunno"

    if my_level == Issue.Level.ERROR:
        my_type_as_string = "ERROR"

    elif my_level == Issue.Level.WARNING:
        my_type_as_string = "WARNING"
        
    elif my_level == Issue.Level.HINT:
        my_type_as_string = "HINT"

    elif my_level == Issue.Level.MESSAGE:
        my_type_as_string = "MESSAGE"

    return my_type_as_string
</literal_block>
                    <paragraph>Full context: <download_reference filename="ff49d9edc19b26fec19cd35b05aeada7/utilities.py" refdoc="howto/code_snippets/snippet_get_issues" refdomain="" refexplicit="True" reftarget="../../tutorials/utilities/utilities.py" reftype="download" refwarn="False"><literal classes="xref download">utilities.py</literal></download_reference></paragraph>
                </container>
            </container>
        </container>
    </container>
</document>
