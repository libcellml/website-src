<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.16 -->
<document source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/actions/get_issues.rst">
    <target refid="actions-get-issues"></target>
    <section ids="retrieve-issue-items actions-get-issues" names="retrieve\ issue\ items actions_get_issues">
        <title>Retrieve <literal>Issue</literal> items</title>
        <paragraph>Selected libCellML classes contain a <literal classes="code">Logger</literal> whose job it is to curate any issues encountered within the class, and return them to the user when asked.
            The classes are:</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph>the <literal classes="code">Parser</literal> class;</paragraph>
            </list_item>
            <list_item>
                <paragraph>the <literal classes="code">Validator</literal> class;</paragraph>
            </list_item>
            <list_item>
                <paragraph>the <literal classes="code">Printer</literal> class;</paragraph>
            </list_item>
            <list_item>
                <paragraph>the <literal classes="code">Analyser</literal> class;</paragraph>
            </list_item>
            <list_item>
                <paragraph>the <literal classes="code">Importer</literal> class; and</paragraph>
            </list_item>
            <list_item>
                <paragraph>the <literal classes="code">Generator</literal> class.</paragraph>
            </list_item>
        </bullet_list>
        <paragraph>Individual issues can be retrieved from the parent class by their index, an integer between 0 and <literal classes="code">issueCount()-1</literal>.
            Each issue contains a severity level indicator, one of four levels (<literal classes="code">ERROR</literal>, <literal classes="code">WARNING</literal>, <literal classes="code">HINT</literal>, or <literal classes="code">MESSAGE</literal>):</paragraph>
        <block_quote>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal classes="code">ERROR</literal> level indicates issues that must be resolved before the model is valid and runnable;</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="code">WARNING</literal> level indicates a non-fatal issue, but one that may cause hidden or unintended consequences;</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="code">HINT</literal> level indicates a commonly encountered valid-but-nonsense situation; and</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="code">MESSAGE</literal> level is for your information but does not require action.</paragraph>
                </list_item>
            </bullet_list>
        </block_quote>
        <paragraph>Issues can also be retrieved from subgroups based on their severity, as shown in the examples below.</paragraph>
        <container classes="toggle">
            <container classes="header">
                <paragraph>See C++ example</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Iterate through all the issues in a Validator, regardless of level, and print to the terminal.
for (size_t i = 0; i &lt; validator-&gt;issueCount(); ++i) {
  // Retrieve the i-th issue and store it in the variable "myIssue".
  libcellml::IssuePtr myIssue = validator-&gt;issue(i);

  // Print the issue's description:
  std::cout &lt;&lt; myIssue-&gt;description() &lt;&lt; std::endl;

  // Print the issue's URL.  This is a URL at which more
  // information could be found about the cause and corrections
  // are needed to avoid it.
  std::cout &lt;&lt; myIssue-&gt;url() &lt;&lt; std::endl;

  // Validator only: Print the issue's reference. This is
  // the heading reference in the normative specification which
  // relates to this issue.
  std::cout &lt;&lt; myIssue-&gt;referenceHeading() &lt;&lt; std::endl;
}

// Retrieve the second ERROR level issue from a Printer. Note indexing from 0.
auto secondError = printer-&gt;error(1);

// Retrieve the last WARNING level issue from a Parser.
auto lastWarning = parser-&gt;warning(parser-&gt;warningCount()-1);

// Iterate through all HINT level issues in a Generator.
for (size_t h = 0; h &lt; generator-&gt;hintCount(); ++h) {
  // Retrieve the h-th hint and store it in the variable "myHint".
  auto myHint = generator-&gt;hint(h);
}</literal_block>
        </container>
        <container classes="toggle">
            <container classes="header">
                <paragraph>See Python example</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Iterate through all the issues in a Validator, regardless of level, and print to the terminal.
for i in range(0, validator.issueCount()):
  # Retrieve the i-th issue and store it in the variable "my_issue".
  my_issue = validator.issue(i)

  # Print the issue's description:
  print(my_issue.description())

  # Print the issue's URL.  This is a URL at which more
  # information could be found about the cause and corrections
  # are needed to avoid it.
  print(my_issue.url())

  # Validator only: Print the issue's reference. This is
  # the heading reference in the normative specification which
  # relates to this issue.
  print(my_issue.referenceHeading())

# Retrieve the second ERROR level issue from a Printer. Note indexing from 0.
second_error = printer.error(1)

# Retrieve the last WARNING level issue from a Parser.
last_warning = parser.warning(parser.warningCount() - 1)

# Iterate through all HINT level issues in a Generator.
for h in range(0, generator.hintCount()):
  # Retrieve the h-th hint and store it in the variable "my_hint".
  my_hint = generator.hint(h)</literal_block>
        </container>
        <paragraph>Each <literal classes="code">Issue</literal> also contains the following attributes:</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph>A description: a brief statement about the problem and how it might be fixed;</paragraph>
            </list_item>
            <list_item>
                <paragraph>A reference heading: a chapter number pertaining to the formal <reference internal="False" refuri="https://cellml-specification.readthedocs.io/en/latest/">CellML 2.0 Specification</reference> document, for issues related to formatting and specification;</paragraph>
            </list_item>
            <list_item>
                <paragraph>A URL: a web address at which more detailed information and examples pertaining to the issue are available;</paragraph>
            </list_item>
            <list_item>
                <paragraph>A cause: an <literal classes="code">enum</literal> which reports the type of item responsible for the issue.
                    This is one of the enums:</paragraph>
            </list_item>
        </bullet_list>
        <container classes="shortlist">
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal classes="code">COMPONENT</literal>,</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="code">CONNECTION</literal>,</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="code">ENCAPSULATION</literal>,</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="code">IMPORT</literal>,</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="code">MAP_VARIABLES</literal>,</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="code">MATHML</literal>,</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="code">MODEL</literal>,</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="code">RESET</literal>,</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="code">RESET_VALUE</literal>,</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="code">TEST_VALUE</literal>,</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="code">UNDEFINED</literal>,</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="code">UNIT</literal>,</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="code">UNITS</literal>,</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="code">VARIABLE</literal>, and</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="code">XML</literal>.</paragraph>
                </list_item>
            </bullet_list>
        </container>
        <container classes="toggle">
            <container classes="header">
                <paragraph>See C++ examples</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Retrieve and print the description of the issue.
std::cout &lt;&lt; issue-&gt;description() &lt;&lt; std::endl;

// Retrieve and print the reference heading number, if related to CellML2.0 specification and format.
std::cout &lt;&lt; issue-&gt;referenceHeading() &lt;&lt; std::endl;

// Retrieve and print the URL for more help and information about the issue.
std::cout &lt;&lt; issue-&gt;url() &lt;&lt; std::endl;

// Retrieve the item type - a libcellml::CellmlElementType enum - for the issue.
auto myType = issue-&gt;CellmlElementType();

// Retrieve the level - a libcellml::Issue::LEVEL enum - for the issue.
auto myLevel = issue-&gt;level();</literal_block>
        </container>
        <container classes="toggle">
            <container classes="header">
                <paragraph>See Python examples</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Retrieve and print the description of the issue.
print(issue.description())

# Retrieve and print the reference heading number, if related to CellML2.0 specification and format.
print(issue.referenceHeading())

# Retrieve and print the URL for more help and information about the issue.
print(issue.url())

# Retrieve the cause - a libcellml.CellmlElementType enum - for the issue.
my_type = issue.cellmlElementType()

# Retrieve the level - a libcellml.Issue.LEVEL enum - for the issue.
my_level = issue.level()</literal_block>
        </container>
    </section>
    <section ids="useful-functions-for-dealing-with-issues" names="useful\ functions\ for\ dealing\ with\ issues">
        <title>Useful functions for dealing with issues</title>
        <target refid="snippet-get-issues"></target>
        <container classes="toggle" ids="snippet-get-issues" names="snippet_get_issues">
            <container classes="header-left">
                <paragraph>Utility functions to retrieve issues</paragraph>
            </container>
            <container classes="sphinx-tabs">
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>C++</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-0-0 active">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/utilities/utilities.cpp" xml:space="preserve">void printIssues(const libcellml::LoggerPtr &amp;item) {

    // Get the number of issues attached to the logger item.  Note that this will 
    // return issues of all levels.  To retrieve the total number of a specific level
    // of issues, use the errorCount(), warningCount(), hintCount(), or messageCount() functions. 
    size_t num = item-&gt;issueCount();
    std::cout &lt;&lt; "Recorded " &lt;&lt; num &lt;&lt; " issues";

    if (num != 0) {
        std::cout &lt;&lt; ":" &lt;&lt; std::endl;
        for (size_t i = 0; i &lt; num; ++i) {

            // Retrieve the issue at index i.  Note that this is agnostic as to the level of issue.
            // Specific issue levels can be retrieved using the functions item-&gt;error(i), item-&gt;warning(i) 
            // etc, where the index must be within appropriate limits.
            libcellml::IssuePtr issue = item-&gt;issue(i);

            // Issues created by the Validator class contain a reference heading number, which indicates
            // the section reference within the normative specification relevant to the issue.
            std::string errorReference = issue-&gt;referenceHeading();

            // The level of an issue is retrieved using the level() function as an enum value.  
            std::cout &lt;&lt; "Issue " &lt;&lt; i &lt;&lt; " is " &lt;&lt; getIssueLevelFromEnum(issue-&gt;level()) &lt;&lt; ":" &lt;&lt; std::endl;

            // Each issue has a descriptive text field, accessible through the description() function.
            std::cout &lt;&lt; "    description: " &lt;&lt; issue-&gt;description() &lt;&lt; std::endl;
            if (errorReference != "") {
                std::cout &lt;&lt; "    see section " &lt;&lt; errorReference
                          &lt;&lt; " in the CellML specification." &lt;&lt; std::endl;
            }

            // An optional URL is given for some issues which directs the user to more detailed information.
            if(!issue-&gt;url().empty()){
                std::cout &lt;&lt; "    more information at: " &lt;&lt;issue-&gt;url() &lt;&lt; std::endl;
            }

            // Each issue is associated with an item.  In order to properly deal with the item stored, its type is 
            // recorded too in an enumeration.
            std::cout &lt;&lt; "    stored item type: " &lt;&lt; getCellmlElementTypeFromEnum(issue-&gt;cellmlElementType()) &lt;&lt; std::endl;
        }
        std::cout &lt;&lt; std::endl &lt;&lt; std::endl;
    }
    else {
        std::cout &lt;&lt; "!" &lt;&lt; std::endl &lt;&lt; std::endl;
    }
}
</literal_block>
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/utilities/utilities.cpp" xml:space="preserve">std::map&lt;libcellml::CellmlElementType, std::string&gt; itemTypeToString = 
    {{libcellml::CellmlElementType::COMPONENT, "COMPONENT"},
    {libcellml::CellmlElementType::COMPONENT_REF, "COMPONENT_REF"},
    {libcellml::CellmlElementType::CONNECTION, "CONNECTION"},
    {libcellml::CellmlElementType::ENCAPSULATION, "ENCAPSULATION" },
    {libcellml::CellmlElementType::IMPORT, "IMPORT"},
    {libcellml::CellmlElementType::MAP_VARIABLES, "MAP_VARIABLES"},
    {libcellml::CellmlElementType::MATH, "MATH"},
    {libcellml::CellmlElementType::MODEL, "MODEL"},
    {libcellml::CellmlElementType::RESET, "RESET"},
    {libcellml::CellmlElementType::RESET_VALUE, "RESET_VALUE"},
    {libcellml::CellmlElementType::TEST_VALUE, "TEST_VALUE"},
    {libcellml::CellmlElementType::UNDEFINED, "UNDEFINED"},
    {libcellml::CellmlElementType::UNIT, "UNIT"},
    {libcellml::CellmlElementType::UNITS, "UNITS"}, 
    {libcellml::CellmlElementType::VARIABLE, "VARIABLE"}};

std::string getCellmlElementTypeFromEnum(libcellml::CellmlElementType t) {
    return itemTypeToString.at(t);
}
</literal_block>
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/utilities/utilities.cpp" xml:space="preserve">std::string getIssueLevelFromEnum(libcellml::Issue::Level myLevel)
{
    std::string myTypeAsString = "dunno";

    switch (myLevel) {
    case libcellml::Issue::Level::ERROR:
        myTypeAsString = "an ERROR";
        break;
    case libcellml::Issue::Level::WARNING:
        myTypeAsString = "a WARNING";
        break;
    case libcellml::Issue::Level::HINT:
        myTypeAsString = "a HINT";
        break;
    case libcellml::Issue::Level::MESSAGE:
        myTypeAsString = "a MESSAGE";
        break;
    }
    return myTypeAsString;
}
</literal_block>
                        <paragraph>Full context: <download_reference filename="ee16fae461b2d043e15c6fe09e31b8c2/utilities.cpp" refdoc="howto/actions/get_issues" refdomain="" refexplicit="True" reftarget="../../tutorials/utilities/utilities.cpp" reftype="download" refwarn="False"><literal classes="xref download">utilities.cpp</literal></download_reference></paragraph>
                    </container>
                </container>
                <container>
                    <container classes="item">
                        <container>
                            <paragraph>Python</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-0-1">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/utilities/utilities.py" xml:space="preserve">def print_issues(item):

    # Get the number of issues attached to the logger item.  Note that this will 
    # return issues of all levels.  To retrieve the total number of a specific level
    # of issues, use the errorCount(), warningCount(), hintCount(), or messageCount() functions. 
    number_of_issues = item.issueCount()

    if number_of_issues != 0:
        print("\nThe {t} has found {n} issues:".format(
            t=type(item).__name__,
            n=number_of_issues)
        )

        for e in range(0, number_of_issues):

            # Retrieve the issue at index i.  Note that this is agnostic as to the level of issue.
            # Specific issue levels can be retrieved using the functions item.error(e), item.warning(e) 
            # etc, where the index must be within appropriate limits.
            i = item.issue(e)

            # The level of an issue is retrieved using the level() function as an enum value. 
            level = i.level()
            print("  {l}[{e}]:".format(
                l=level_as_string[level],
                e=e))

            # Each issue has a descriptive text field, accessible through the description() function.
            print("    Description: {d}".format(
                d=i.description()))

            # Issues created by the Validator class contain a reference heading number, which indicates
            # the section reference within the normative specification relevant to the issue.
            specification = i.referenceHeading()
            if specification != "":
                print("    See section {s} in the CellML specification.".format(
                    s=specification))

            # An optional URL is given for some issues which directs the user to more detailed information.
            url = i.url()
            if url != "":
                print("    More information is available at {url}".format(
                    url=url))

            # Each issue is associated with an item.  In order to properly deal with the item stored, its type is 
            # recorded too in an enumeration.
            print("    Stored item type: {}".format(get_cellml_element_type_from_enum(i.cellmlElementType())))

    else:
        print("\nThe {t} has not found any issues!".format(
            t=type(item).__name__)
        )
</literal_block>
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/utilities/utilities.py" xml:space="preserve">def get_cellml_element_type_from_enum(my_cause):

    my_type_as_string = "dunno"

    if my_cause == CellmlElementType.COMPONENT:
        my_type_as_string = "COMPONENT"

    elif my_cause == CellmlElementType.COMPONENT_REF:
        my_type_as_string = "COMPONENT_REf"

    elif my_cause == CellmlElementType.CONNECTION:
        my_type_as_string = "CONNECTION"

    elif my_cause == CellmlElementType.ENCAPSULATION:
        my_type_as_string = "ENCAPSULATION"

    elif my_cause == CellmlElementType.IMPORT:
        my_type_as_string = "IMPORT"

    elif my_cause == CellmlElementType.MATH:
        my_type_as_string = "MATH"

    elif my_cause == CellmlElementType.MAP_VARIABLES:
        my_type_as_string = "MAP_VARIABLES"

    elif my_cause == CellmlElementType.MODEL:
        my_type_as_string = "MODEL"

    elif my_cause == CellmlElementType.RESET:
        my_type_as_string = "RESET"

    elif my_cause == CellmlElementType.RESET_VALUE:
        my_type_as_string = "RESET_VALUE"

    elif my_cause == CellmlElementType.TEST_VALUE:
        my_type_as_string = "TEST_VALUE"

    elif my_cause == CellmlElementType.UNDEFINED:
        my_type_as_string = "UNDEFINED"

    elif my_cause == CellmlElementType.UNIT:
        my_type_as_string = "UNIT"

    elif my_cause == CellmlElementType.UNITS:
        my_type_as_string = "UNITS"

    elif my_cause == CellmlElementType.VARIABLE:
        my_type_as_string = "VARIABLE"

    return my_type_as_string
</literal_block>
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/tutorials/utilities/utilities.py" xml:space="preserve">def get_issue_level_from_enum(my_level):

    my_type_as_string = "dunno"

    if my_level == Issue.Level.ERROR:
        my_type_as_string = "ERROR"

    elif my_level == Issue.Level.WARNING:
        my_type_as_string = "WARNING"
        
    elif my_level == Issue.Level.HINT:
        my_type_as_string = "HINT"

    elif my_level == Issue.Level.MESSAGE:
        my_type_as_string = "MESSAGE"

    return my_type_as_string
</literal_block>
                        <paragraph>Full context: <download_reference filename="a85afb093ebee610570a9ac61645e68b/utilities.py" refdoc="howto/actions/get_issues" refdomain="" refexplicit="True" reftarget="../../tutorials/utilities/utilities.py" reftype="download" refwarn="False"><literal classes="xref download">utilities.py</literal></download_reference></paragraph>
                    </container>
                </container>
            </container>
        </container>
    </section>
</document>
